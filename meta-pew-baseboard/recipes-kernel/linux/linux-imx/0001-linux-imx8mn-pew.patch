diff --git a/arch/arm64/boot/dts/freescale/Makefile b/arch/arm64/boot/dts/freescale/Makefile
index 9a7319c6b..daa86e58a 100644
--- a/arch/arm64/boot/dts/freescale/Makefile
+++ b/arch/arm64/boot/dts/freescale/Makefile
@@ -86,6 +86,7 @@ dtb-$(CONFIG_ARCH_MXC) += imx8mm-icore-mx8mm-ctouch2.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mm-icore-mx8mm-edimm2.2.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mm-nitrogen-r2.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mn-evk.dtb imx8mn-evk-rm67191.dtb imx8mn-evk-rpmsg.dtb
+dtb-$(CONFIG_ARCH_MXC) += imx8mn-pew-mon.dtb imx8mn-pew-gw.dtb imx8mn-pew-bizgw.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mm-ab2.dtb imx8mm-ab2-m4.dtb imx8mm-ddr4-ab2.dtb imx8mm-ddr4-ab2-m4.dtb \
 			  imx8mm-ddr4-ab2-revb.dtb imx8mm-ddr4-ab2-m4-revb.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mn-evk.dtb imx8mn-evk-rm67191.dtb imx8mn-evk-rpmsg.dtb imx8mn-evk-ak5558.dtb \
diff --git a/arch/arm64/boot/dts/freescale/imx8mn-pew-bizgw.dts b/arch/arm64/boot/dts/freescale/imx8mn-pew-bizgw.dts
new file mode 100644
index 000000000..183c4fbf3
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mn-pew-bizgw.dts
@@ -0,0 +1,164 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+ /*
+  * Copyright 2022-2023 Panasonic Corporation
+  */
+
+#include "imx8mn-pew-common.dtsi"
+
+/ {
+	model = "Panasonic Electric Works i.MX8MN NXGW business gateway type board";
+	compatible = "fsl,imx8mn-pew-bizgw", "fsl,imx8mn-pew", "fsl,imx8mn";
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0 0x20000000>;	/* DDR512MB */
+	};
+
+	reg_usbotg1_vbus: regulator-usbotg1-vbus {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_usbotg1_vbus>;
+		regulator-name = "USBOTG1_VBUS";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&gpio4 21 GPIO_ACTIVE_HIGH>;	/* LTE USB-HiSideSW */
+		enable-active-high;
+	};
+};
+
+&i2c4 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4>;
+	status = "okay";
+
+	/* RS485#A */
+	rl78uart_a: rl78uart@41 {
+		compatible = "panasonic,rl78uart";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rs485a>;
+		reg = <0x41>;
+		serial-line = <0>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <12 IRQ_TYPE_LEVEL_LOW>;		/* RS485#A IRQ         */
+		led-gpio = <&gpio1 6 GPIO_ACTIVE_HIGH>;		/* RS485 ch1 LED       */
+		status = "okay";
+	};
+
+	/* RS485#B */
+	rl78uart_b: rl78uart@40 {
+		compatible = "panasonic,rl78uart";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rs485b>;
+		reg = <0x40>;
+		serial-line = <1>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <29 IRQ_TYPE_LEVEL_LOW>;		/* RS485#B IRQ         */
+		led-gpio = <&gpio1 7 GPIO_ACTIVE_HIGH>;		/* RS485 ch2 LED       */
+		status = "okay";
+	};
+};
+
+/* USB(LTE) */
+&usbotg1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_lte>;
+	dr_mode = "host"; /* HOST固定 */
+	vbus-supply = <&reg_usbotg1_vbus>;
+	hnp-disable;
+	srp-disable;
+	adp-disable;
+	disable-over-current;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_common>, <&pinctrl_hog_bizgw>;
+
+	pinctrl_hog_bizgw: hogbizgwgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_GPIO1_IO00_GPIO1_IO0			0x116	/* NC              */
+			MX8MN_IOMUXC_GPIO1_IO01_GPIO1_IO1			0x116	/* NC              */
+			MX8MN_IOMUXC_GPIO1_IO13_GPIO1_IO13			0x100	/* NC              */
+			MX8MN_IOMUXC_ENET_TD3_GPIO1_IO18			0x116	/* サーバー状態LED */
+			MX8MN_IOMUXC_ENET_RXC_GPIO1_IO25			0x100	/* NC              */
+			MX8MN_IOMUXC_SD1_CLK_GPIO2_IO0				0x100	/* NC              */
+			MX8MN_IOMUXC_SD1_CMD_GPIO2_IO1				0x100	/* NC              */
+			MX8MN_IOMUXC_SD1_DATA0_GPIO2_IO2			0x100	/* NC              */
+			MX8MN_IOMUXC_SD1_DATA1_GPIO2_IO3			0x100	/* NC              */
+			MX8MN_IOMUXC_SD1_DATA2_GPIO2_IO4			0x100	/* NC              */
+			MX8MN_IOMUXC_SD1_DATA3_GPIO2_IO5			0x100	/* NC              */
+			MX8MN_IOMUXC_SD1_DATA7_GPIO2_IO9			0x100	/* NC              */
+			MX8MN_IOMUXC_SD1_STROBE_GPIO2_IO11			0x100	/* NC              */
+			MX8MN_IOMUXC_SD2_WP_GPIO2_IO20				0x100	/* 予備LED         */
+			MX8MN_IOMUXC_SAI5_RXC_GPIO3_IO20			0x116	/* NC              */
+			MX8MN_IOMUXC_SAI5_RXD0_GPIO3_IO21			0x116	/* NC              */
+			MX8MN_IOMUXC_SAI2_RXD0_GPIO4_IO23			0x116	/* NC              */
+			MX8MN_IOMUXC_SAI2_TXFS_GPIO4_IO24			0x116	/* NC              */
+			MX8MN_IOMUXC_SAI2_TXC_GPIO4_IO25			0x116	/* NC              */
+			MX8MN_IOMUXC_SAI2_TXD0_GPIO4_IO26			0x116	/* NC              */
+			MX8MN_IOMUXC_SAI3_RXFS_GPIO4_IO28			0x116	/* NC              */
+			MX8MN_IOMUXC_SAI3_RXC_GPIO4_IO29			0x116	/* NC              */
+			MX8MN_IOMUXC_SAI3_RXD_GPIO4_IO30			0x116	/* NC              */
+			MX8MN_IOMUXC_SAI3_TXFS_GPIO4_IO31			0x116	/* NC              */
+			MX8MN_IOMUXC_SAI3_TXC_GPIO5_IO0				0x116	/* NC              */
+			MX8MN_IOMUXC_SAI3_TXD_GPIO5_IO1				0x116	/* NC              */
+			MX8MN_IOMUXC_SAI3_MCLK_GPIO5_IO2			0x116	/* NC              */
+			MX8MN_IOMUXC_SPDIF_TX_GPIO5_IO3				0x116	/* NC              */
+			MX8MN_IOMUXC_SPDIF_RX_GPIO5_IO4				0x116	/* NC              */
+			MX8MN_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5		0x116	/* NC              */
+			MX8MN_IOMUXC_I2C3_SCL_GPIO5_IO18			0x116	/* NC              */
+			MX8MN_IOMUXC_I2C3_SDA_GPIO5_IO19			0x116	/* NC              */
+			MX8MN_IOMUXC_UART1_RXD_GPIO5_IO22			0x116	/* NC              */
+			MX8MN_IOMUXC_UART1_TXD_GPIO5_IO23			0x116	/* NC              */
+			MX8MN_IOMUXC_UART3_RXD_GPIO5_IO26			0x116	/* NC              */
+			MX8MN_IOMUXC_UART3_TXD_GPIO5_IO27			0x116	/* NC              */
+		>;
+	};
+
+	pinctrl_i2c4: i2c4grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C4_SCL_I2C4_SCL				0x400000c3
+			MX8MN_IOMUXC_I2C4_SDA_I2C4_SDA				0x400000c3
+		>;
+	};
+
+	pinctrl_rs485a: rs485agrp {
+		fsl,pins = <
+			/* I2C-UART用MCUのリセット解除はubootで行う */
+			MX8MN_IOMUXC_GPIO1_IO06_GPIO1_IO6			0x116	/* RS485 ch1 LED  */
+			MX8MN_IOMUXC_GPIO1_IO11_GPIO1_IO11			0x016	/* RS485#A MCU_RESET_B */
+			MX8MN_IOMUXC_GPIO1_IO12_GPIO1_IO12			0x016	/* RS485#A IRQ    */
+		>;
+	};
+
+	pinctrl_rs485b: rs485bgrp {
+		fsl,pins = <
+			/* I2C-UART用MCUのリセット解除はubootで行う */
+			MX8MN_IOMUXC_GPIO1_IO07_GPIO1_IO7			0x116	/* RS485 ch2 LED  */
+			MX8MN_IOMUXC_ENET_RD2_GPIO1_IO28			0x016	/* RS485#B MCU_RESET_B */
+			MX8MN_IOMUXC_ENET_RD3_GPIO1_IO29			0x016	/* RS485#A IRQ    */
+		>;
+	};
+
+	pinctrl_lte: ltegrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_GPIO1_IO14_GPIO1_IO14			0x116	/* LTE ch1 LED     */
+			MX8MN_IOMUXC_GPIO1_IO15_GPIO1_IO15			0x116	/* LTE ch2 LED     */
+			MX8MN_IOMUXC_NAND_ALE_GPIO3_IO0				0x116	/* LTE RESET_N    */
+			MX8MN_IOMUXC_NAND_CE0_B_GPIO3_IO1			0x116	/* LTE_PWRKEY     */
+			MX8MN_IOMUXC_NAND_DATA00_GPIO3_IO6			0x156	/* LTE_STATUS     */
+			MX8MN_IOMUXC_NAND_DATA01_GPIO3_IO7			0x156	/* LTE_WAKEUP_IN  */
+			MX8MN_IOMUXC_NAND_DATA02_GPIO3_IO8			0x156	/* LTE_AP_READY   */
+			MX8MN_IOMUXC_NAND_DATA03_GPIO3_IO9			0x156	/* LTE_W_DISABLE  */
+			MX8MN_IOMUXC_NAND_DQS_GPIO3_IO14			0x016	/* LTE_RI         */
+		>;
+	};
+
+	pinctrl_reg_usbotg1_vbus: usbotg1vbusgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SAI2_RXFS_GPIO4_IO21			0x016	/* LTE USB-HiSideSW */
+		>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mn-pew-common.dtsi b/arch/arm64/boot/dts/freescale/imx8mn-pew-common.dtsi
new file mode 100644
index 000000000..f4417dfbd
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mn-pew-common.dtsi
@@ -0,0 +1,472 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2020 NXP
+ * Copyright 2022-2023 Panasonic Corporation
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/usb/pd.h>
+#include "imx8mn.dtsi"
+
+/ {
+	model = "Panasonic Electric Works i.MX8MN NXGW board";
+	compatible = "fsl,imx8mn-pew", "fsl,imx8mn";
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_led>;
+		status = "okay";
+
+		status {
+			label = "status";
+			gpios = <&gpio3 25 GPIO_ACTIVE_HIGH>;	/* SYS_STATUS */
+			default-state = "on";
+		};
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_usdhc2_vmmc>;
+		regulator-name = "VSD_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio2 19 GPIO_ACTIVE_HIGH>;	/* SD2_NRST */
+		off-on-delay-us = <20000>;
+		enable-active-high;
+	};
+};
+
+&A53_0 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_1 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_2 {
+	cpu-supply = <&buck2>;
+};
+
+&A53_3 {
+	cpu-supply = <&buck2>;
+};
+
+&a53_opp_table {
+	opp-1000000000 {
+		opp-hz = /bits/ 64 <1000000000>;
+		opp-microvolt = <850000>;
+		opp-supported-hw = <0xb00>, <0x7>;
+		clock-latency-ns = <150000>;
+		opp-suspend;
+	};
+
+	opp-600000000 {
+		opp-hz = /bits/ 64 <600000000>;
+		opp-microvolt = <850000>;
+		opp-supported-hw = <0xb00>, <0x7>;
+		clock-latency-ns = <150000>;
+		opp-suspend;
+	};
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pmic@25 {
+		compatible = "nxp,pca9450b";
+		reg = <0x25>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_pmic>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+
+		regulators {
+			buck1: BUCK1{
+				regulator-name = "BUCK1";
+				regulator-min-microvolt = <950000>;
+				regulator-max-microvolt = <950000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+				nxp,dvs-run-voltage = <850000>;
+				nxp,dvs-standby-voltage = <850000>;
+			};
+
+			buck2: BUCK2 {
+				regulator-name = "BUCK2";
+				regulator-min-microvolt = <850000>;
+				regulator-max-microvolt = <950000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+			};
+
+			buck4: BUCK4{
+				regulator-name = "BUCK4";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck5: BUCK5{
+				regulator-name = "BUCK5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6: BUCK6 {
+				regulator-name = "BUCK6";
+				regulator-min-microvolt = <1100000>;
+				regulator-max-microvolt = <1100000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1: LDO1 {
+				regulator-name = "LDO1";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2: LDO2 {
+				regulator-name = "LDO2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3: LDO3 {
+				regulator-name = "LDO3";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4: LDO4 {
+				regulator-name = "LDO4";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1200000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo5: LDO5 {
+				regulator-name = "LDO5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	/* RTC */
+	pcf85063a: pcf85063a@51 {
+		compatible = "nxp,pcf85063a";
+		reg = <0x51>;
+		quartz-load-femtofarads = <7000>;	/* 負荷容量7pF */
+		status = "okay";
+	};
+};
+
+/* Console */
+&uart2 { 
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+/* SoC-MCU */
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	assigned-clocks = <&clk IMX8MN_CLK_UART3>;
+	assigned-clock-parents = <&clk IMX8MN_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+/* SoC-MCU */
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	assigned-clocks = <&clk IMX8MN_CLK_UART4>;
+	assigned-clock-parents = <&clk IMX8MN_SYS_PLL1_80M>;
+	status = "okay";
+};
+
+/* SD Card */
+&usdhc2 {
+	assigned-clocks = <&clk IMX8MN_CLK_USDHC2>;
+	assigned-clock-rates = <200000000>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_detect>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_detect>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_detect>;
+	cd-gpios = <&gpio2 12 GPIO_ACTIVE_LOW>;		/* SD2_Detect */
+	bus-width = <4>;
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	status = "okay";
+};
+
+/* eMMC */
+&usdhc3 {
+	assigned-clocks = <&clk IMX8MN_CLK_USDHC3_ROOT>;
+	assigned-clock-rates = <400000000>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+/* Ethernet */
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec1>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	fsl,magic-packet;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reset-gpios = <&gpio4 22 GPIO_ACTIVE_LOW>;	/* ENET_nRST */
+		reset-delay-us = <100>;
+		reset-post-delay-us = <2000>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0>;
+		};
+	};
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_common>;
+
+	pinctrl_hog_common: hogcommongrp {
+		fsl,pins = <
+			/* GPIO */
+			MX8MN_IOMUXC_GPIO1_IO05_GPIO1_IO5			0x100	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO08_GPIO1_IO8			0x116	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO09_GPIO1_IO9			0x019	/* Secure IC PWRDOWN_EN(JP選択、Default=未使用) */
+			MX8MN_IOMUXC_GPIO1_IO10_GPIO1_IO10			0x100	/* NC             */
+			MX8MN_IOMUXC_SD1_DATA4_GPIO2_IO6			0x011	/* DIP SW         */
+			MX8MN_IOMUXC_SD1_DATA5_GPIO2_IO7			0x011	/* DIP SW         */
+			MX8MN_IOMUXC_SD1_DATA6_GPIO2_IO8			0x011	/* DIP SW         */
+			MX8MN_IOMUXC_SD1_RESET_B_GPIO2_IO10			0x011	/* DIP SW         */
+			MX8MN_IOMUXC_NAND_READY_B_GPIO3_IO16		0x116	/* NC             */
+			MX8MN_IOMUXC_SAI5_RXFS_GPIO3_IO19			0x116	/* NC             */
+			MX8MN_IOMUXC_SAI5_RXD1_GPIO3_IO22			0x116	/* NC             */
+			MX8MN_IOMUXC_SAI5_RXD2_GPIO3_IO23			0x116	/* NC             */
+			MX8MN_IOMUXC_SAI5_RXD3_GPIO3_IO24			0x006	/* SYS_PRST       */
+			MX8MN_IOMUXC_SAI2_MCLK_GPIO4_IO27			0x016	/* NC             */
+			MX8MN_IOMUXC_ECSPI2_MISO_GPIO5_IO12			0x116	/* NC             */
+			MX8MN_IOMUXC_ECSPI2_SS0_GPIO5_IO13			0x116	/* NC             */
+			MX8MN_IOMUXC_UART4_RXD_GPIO5_IO28			0x016	/* CPU間通信用    */
+			MX8MN_IOMUXC_UART4_TXD_GPIO5_IO29			0x016	/* MCU_XSRST      */
+		>;
+	};
+
+	pinctrl_led: ledgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SAI5_MCLK_GPIO3_IO25			0x019	/* SYS_STATUS LED */
+		>;
+	};
+
+	pinctrl_pmic: pmicgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_GPIO1_IO03_GPIO1_IO3			0x016	/* PMIC_NINT    */
+		>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C1_SCL_I2C1_SCL				0x400000c3
+			MX8MN_IOMUXC_I2C1_SDA_I2C1_SDA				0x400000c3
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C2_SCL_I2C2_SCL				0x400000c3
+			MX8MN_IOMUXC_I2C2_SDA_I2C2_SDA				0x400000c3
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_UART2_RXD_UART2_DCE_RX			0x040
+			MX8MN_IOMUXC_UART2_TXD_UART2_DCE_TX			0x040
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ECSPI1_SCLK_UART3_DCE_RX		0x040
+			MX8MN_IOMUXC_ECSPI1_MOSI_UART3_DCE_TX		0x040
+			MX8MN_IOMUXC_ECSPI1_SS0_UART3_DCE_RTS_B		0x040
+			MX8MN_IOMUXC_ECSPI1_MISO_UART3_DCE_CTS_B	0x040
+		>;
+	};
+
+	pinctrl_uart4: uart4prp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ECSPI2_SCLK_UART4_DCE_RX		0x040
+			MX8MN_IOMUXC_ECSPI2_MOSI_UART4_DCE_TX		0x040
+		>;
+	};
+
+	pinctrl_fec1: fec1grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ENET_MDC_ENET1_MDC				0x003
+			MX8MN_IOMUXC_ENET_MDIO_ENET1_MDIO			0x003
+			MX8MN_IOMUXC_ENET_TD1_ENET1_RGMII_TD1		0x01f
+			MX8MN_IOMUXC_ENET_TD0_ENET1_RGMII_TD0		0x01f
+			MX8MN_IOMUXC_ENET_RD1_ENET1_RGMII_RD1		0x091
+			MX8MN_IOMUXC_ENET_RD0_ENET1_RGMII_RD0		0x091
+			MX8MN_IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL	0x091
+			MX8MN_IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL	0x01f
+			MX8MN_IOMUXC_ENET_TD2_ENET1_TX_CLK			0x01f
+			MX8MN_IOMUXC_ENET_TXC_GPIO1_IO23			0x156	/* ENET_INTR/PWRDN */
+			MX8MN_IOMUXC_SAI2_RXC_GPIO4_IO22			0x056	/* ENET_nRST       */
+		>;
+	};
+
+	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD2_RESET_B_GPIO2_IO19			0x041	/* SD2_NRST */
+		>;
+	};
+
+	pinctrl_usdhc2_detect: usdhc2detectgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD2_CD_B_GPIO2_IO12			0x056	/* SD2_Detect */
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD2_CLK_USDHC2_CLK				0x090
+			MX8MN_IOMUXC_SD2_CMD_USDHC2_CMD				0x0d0
+			MX8MN_IOMUXC_SD2_DATA0_USDHC2_DATA0			0x0d0
+			MX8MN_IOMUXC_SD2_DATA1_USDHC2_DATA1			0x0d0
+			MX8MN_IOMUXC_SD2_DATA2_USDHC2_DATA2			0x0d0
+			MX8MN_IOMUXC_SD2_DATA3_USDHC2_DATA3			0x0d0
+			MX8MN_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0x1d0	/* SD2_VSEL       */
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD2_CLK_USDHC2_CLK				0x094
+			MX8MN_IOMUXC_SD2_CMD_USDHC2_CMD				0x0d4
+			MX8MN_IOMUXC_SD2_DATA0_USDHC2_DATA0			0x0d4
+			MX8MN_IOMUXC_SD2_DATA1_USDHC2_DATA1			0x0d4
+			MX8MN_IOMUXC_SD2_DATA2_USDHC2_DATA2			0x0d4
+			MX8MN_IOMUXC_SD2_DATA3_USDHC2_DATA3			0x0d4
+			MX8MN_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0x1d4	/* SD2_VSEL       */
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD2_CLK_USDHC2_CLK				0x096
+			MX8MN_IOMUXC_SD2_CMD_USDHC2_CMD				0x0d6
+			MX8MN_IOMUXC_SD2_DATA0_USDHC2_DATA0			0x0d6
+			MX8MN_IOMUXC_SD2_DATA1_USDHC2_DATA1			0x0d6
+			MX8MN_IOMUXC_SD2_DATA2_USDHC2_DATA2			0x0d6
+			MX8MN_IOMUXC_SD2_DATA3_USDHC2_DATA3			0x0d6
+			MX8MN_IOMUXC_GPIO1_IO04_USDHC2_VSELECT		0x1d6	/* SD2_VSEL       */
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_NAND_WE_B_USDHC3_CLK			0x190
+			MX8MN_IOMUXC_NAND_WP_B_USDHC3_CMD			0x1d0
+			MX8MN_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d0
+			MX8MN_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d0
+			MX8MN_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d0
+			MX8MN_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d0
+			MX8MN_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d0
+			MX8MN_IOMUXC_NAND_RE_B_USDHC3_DATA4			0x1d0
+			MX8MN_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d0
+			MX8MN_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d0
+			MX8MN_IOMUXC_NAND_CLE_USDHC3_DATA7			0x1d0
+			MX8MN_IOMUXC_NAND_CE1_B_USDHC3_STROBE		0x190
+		>;
+	};
+
+	pinctrl_usdhc3_100mhz: usdhc3-100mhzgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_NAND_WE_B_USDHC3_CLK			0x194
+			MX8MN_IOMUXC_NAND_WP_B_USDHC3_CMD			0x1d4
+			MX8MN_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d4
+			MX8MN_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d4
+			MX8MN_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d4
+			MX8MN_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d4
+			MX8MN_IOMUXC_NAND_RE_B_USDHC3_DATA4			0x1d4
+			MX8MN_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d4
+			MX8MN_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d4
+			MX8MN_IOMUXC_NAND_CLE_USDHC3_DATA7			0x1d4
+			MX8MN_IOMUXC_NAND_CE1_B_USDHC3_STROBE		0x194
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3-200mhzgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_NAND_WE_B_USDHC3_CLK			0x196
+			MX8MN_IOMUXC_NAND_WP_B_USDHC3_CMD			0x1d6
+			MX8MN_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d6
+			MX8MN_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d6
+			MX8MN_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d6
+			MX8MN_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d6
+			MX8MN_IOMUXC_NAND_RE_B_USDHC3_DATA4			0x1d6
+			MX8MN_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d6
+			MX8MN_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d6
+			MX8MN_IOMUXC_NAND_CLE_USDHC3_DATA7			0x1d6
+			MX8MN_IOMUXC_NAND_CE1_B_USDHC3_STROBE		0x196
+		>;
+	};
+
+	pinctrl_wdog: wdoggrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_GPIO1_IO02_WDOG1_WDOG_B		0x0c6
+		>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mn-pew-gw.dts b/arch/arm64/boot/dts/freescale/imx8mn-pew-gw.dts
new file mode 100644
index 000000000..49597c5d8
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mn-pew-gw.dts
@@ -0,0 +1,255 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+ /*
+  * Copyright 2022-2023 Panasonic Corporation
+  */
+
+#include "imx8mn-pew-common.dtsi"
+
+/ {
+	model = "Panasonic Electric Works i.MX8MN NXGW gateway type board";
+	compatible = "fsl,imx8mn-pew-gw", "fsl,imx8mn-pew", "fsl,imx8mn";
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0 0x20000000>;	/* DDR512MB */
+	};
+
+	reg_usdhc1_vmmc: regulator-usdhc1 {
+		compatible = "regulator-fixed";
+		regulator-name = "VSD_1V8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	sound-tas2505 {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "tas2505-audio";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,frame-master = <&cpudai>;
+		simple-audio-card,bitclock-master = <&cpudai>;
+		simple-audio-card,mclk-fs = <256>;
+
+		cpudai: simple-audio-card,cpu {
+			sound-dai = <&sai3>;
+			dai-tdm-slot-num = <2>;
+			dai-tdm-slot-width = <32>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&tas2505>;
+			clocks = <&clk IMX8MN_CLK_SAI3_ROOT>;
+		};
+	};
+
+	bt_sco_codec: bt_sco_codec {
+		#sound-dai-cells = <1>;
+		compatible = "linux,bt-sco";
+	};
+
+	sound-bt-sco {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "bt-sco-audio";
+		simple-audio-card,format = "dsp_a";
+		simple-audio-card,bitclock-inversion;
+		simple-audio-card,frame-master = <&btcpu>;
+		simple-audio-card,bitclock-master = <&btcpu>;
+
+		btcpu: simple-audio-card,cpu {
+			sound-dai = <&sai2>;
+			dai-tdm-slot-num = <2>;
+			dai-tdm-slot-width = <16>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&bt_sco_codec 1>;
+		};
+	};
+};
+
+&i2c4 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4>;
+	status = "okay";
+
+	/* Audio Codec */
+	tas2505: tas2505@18 {
+		#sound-dai-cells = <0>;
+		compatible = "ti,tas2505";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_codec>;
+		gpio-reset = <&gpio5 5 GPIO_ACTIVE_HIGH>;	/* Codec PDN */
+		reg = <0x18>;
+		audio-cpu = <&sai3>;
+		status = "okay";
+	};
+};
+
+&sai2 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai2>;
+	assigned-clocks = <&clk IMX8MN_CLK_SAI2>;
+	assigned-clock-parents = <&clk IMX8MN_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <24576000>;
+	status = "okay";
+};
+
+&sai3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	assigned-clocks = <&clk IMX8MN_CLK_SAI3>;
+	assigned-clock-parents = <&clk IMX8MN_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <12288000>;
+	clocks = <&clk IMX8MN_CLK_SAI3_IPG>, <&clk IMX8MN_CLK_DUMMY>,
+		<&clk IMX8MN_CLK_SAI3_ROOT>, <&clk IMX8MN_CLK_DUMMY>,
+		<&clk IMX8MN_CLK_DUMMY>, <&clk IMX8MN_AUDIO_PLL1_OUT>,
+		<&clk IMX8MN_AUDIO_PLL2_OUT>;
+	clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3", "pll8k", "pll11k";
+	fsl,mclk-clkid = <1>;
+	status = "okay";
+};
+
+/* BT */
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clk IMX8MN_CLK_UART1>;
+	assigned-clock-parents = <&clk IMX8MN_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+/* WLAN/BT */
+&usdhc1 {
+	assigned-clocks = <&clk IMX8MN_CLK_USDHC1_ROOT>;
+	assigned-clock-rates = <400000000>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	bus-width = <4>;
+	cap-power-off-card;
+	pm-ignore-notify;
+	keep-power-in-suspend;
+	non-removable;
+	vqmmc-supply = <&reg_usdhc1_vmmc>;
+	status = "okay";
+};
+
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_common>, <&pinctrl_hog_gw>;
+
+	pinctrl_hog_gw: hoggwgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_GPIO1_IO00_GPIO1_IO0			0x116	/* REF_CLK_32K    */
+			MX8MN_IOMUXC_GPIO1_IO01_GPIO1_IO1			0x116	/* WIFIBT_PMIC_EN */
+			MX8MN_IOMUXC_GPIO1_IO06_GPIO1_IO6			0x116	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO07_GPIO1_IO7			0x116	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO11_GPIO1_IO11			0x016	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO12_GPIO1_IO12			0x016	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO13_GPIO1_IO13			0x100	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO14_GPIO1_IO14			0x116	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO15_GPIO1_IO15			0x116	/* NC             */
+			MX8MN_IOMUXC_ENET_TD3_GPIO1_IO18			0x116	/* NC             */
+			MX8MN_IOMUXC_ENET_RXC_GPIO1_IO25			0x100	/* NC             */
+			MX8MN_IOMUXC_ENET_RD2_GPIO1_IO28			0x016	/* NC             */
+			MX8MN_IOMUXC_ENET_RD3_GPIO1_IO29			0x016	/* NC             */
+			MX8MN_IOMUXC_SD1_DATA7_GPIO2_IO9			0x100	/* NC             */
+			MX8MN_IOMUXC_SD1_STROBE_GPIO2_IO11			0x100	/* NC             */
+			MX8MN_IOMUXC_SD2_WP_GPIO2_IO20				0x100	/* NC             */
+			MX8MN_IOMUXC_NAND_ALE_GPIO3_IO0				0x116	/* NC             */
+			MX8MN_IOMUXC_NAND_CE0_B_GPIO3_IO1			0x116	/* NC             */
+			MX8MN_IOMUXC_NAND_DATA00_GPIO3_IO6			0x156	/* NC             */
+			MX8MN_IOMUXC_NAND_DATA01_GPIO3_IO7			0x156	/* NC             */
+			MX8MN_IOMUXC_NAND_DATA02_GPIO3_IO8			0x156	/* NC             */
+			MX8MN_IOMUXC_NAND_DATA03_GPIO3_IO9			0x156	/* NC             */
+			MX8MN_IOMUXC_NAND_DQS_GPIO3_IO14			0x016	/* NC             */
+			MX8MN_IOMUXC_SAI5_RXC_GPIO3_IO20			0x116	/* NC             */
+			MX8MN_IOMUXC_SAI5_RXD0_GPIO3_IO21			0x116	/* NC             */
+			MX8MN_IOMUXC_SAI2_RXFS_GPIO4_IO21			0x016	/* NC             */
+			MX8MN_IOMUXC_SAI3_RXFS_GPIO4_IO28			0x116	/* HOST_WAKE_BT   */
+			MX8MN_IOMUXC_SAI3_RXC_GPIO4_IO29			0x116	/* BT_WAKE_HOST   */
+			MX8MN_IOMUXC_SPDIF_TX_GPIO5_IO3				0x116	/* HOST_WAKE_WLAN */
+			MX8MN_IOMUXC_SPDIF_RX_GPIO5_IO4				0x116	/* WL_WAKE_HOST   */
+			MX8MN_IOMUXC_I2C3_SCL_GPIO5_IO18			0x116	/* NC             */
+			MX8MN_IOMUXC_I2C3_SDA_GPIO5_IO19			0x116	/* NC             */
+		>;
+	};
+
+	pinctrl_i2c4: i2c4grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C4_SCL_I2C4_SCL				0x400001c3
+			MX8MN_IOMUXC_I2C4_SDA_I2C4_SDA				0x400001c3
+		>;
+	};
+
+	pinctrl_codec: codecgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5		0x116	/* Codec PDN */
+		>;
+	};
+
+	pinctrl_sai2: sai2grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SAI2_TXC_SAI2_TX_BCLK			0x116
+			MX8MN_IOMUXC_SAI2_TXFS_SAI2_TX_SYNC			0x116
+			MX8MN_IOMUXC_SAI2_TXD0_SAI2_TX_DATA0		0x116
+			MX8MN_IOMUXC_SAI2_RXD0_SAI2_RX_DATA0		0x116
+		>;
+	};
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SAI3_RXD_SAI3_RX_DATA0			0x116
+			MX8MN_IOMUXC_SAI3_TXFS_SAI3_TX_SYNC			0x116
+			MX8MN_IOMUXC_SAI3_TXC_SAI3_TX_BCLK			0x116
+			MX8MN_IOMUXC_SAI3_MCLK_SAI3_MCLK			0x116
+			MX8MN_IOMUXC_SAI3_TXD_SAI3_TX_DATA0			0x116
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_UART1_RXD_UART1_DCE_RX			0x040
+			MX8MN_IOMUXC_UART1_TXD_UART1_DCE_TX			0x040
+			MX8MN_IOMUXC_UART3_RXD_UART1_DCE_CTS_B		0x040
+			MX8MN_IOMUXC_UART3_TXD_UART1_DCE_RTS_B		0x040
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD1_CLK_USDHC1_CLK				0x190
+			MX8MN_IOMUXC_SD1_CMD_USDHC1_CMD				0x1d0
+			MX8MN_IOMUXC_SD1_DATA0_USDHC1_DATA0			0x1d0
+			MX8MN_IOMUXC_SD1_DATA1_USDHC1_DATA1			0x1d0
+			MX8MN_IOMUXC_SD1_DATA2_USDHC1_DATA2			0x1d0
+			MX8MN_IOMUXC_SD1_DATA3_USDHC1_DATA3			0x1d0
+		>;
+	};
+
+	pinctrl_usdhc1_100mhz: usdhc1-100mhzgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD1_CLK_USDHC1_CLK				0x194
+			MX8MN_IOMUXC_SD1_CMD_USDHC1_CMD				0x1d4
+			MX8MN_IOMUXC_SD1_DATA0_USDHC1_DATA0			0x1d4
+			MX8MN_IOMUXC_SD1_DATA1_USDHC1_DATA1			0x1d4
+			MX8MN_IOMUXC_SD1_DATA2_USDHC1_DATA2			0x1d4
+			MX8MN_IOMUXC_SD1_DATA3_USDHC1_DATA3			0x1d4
+		>;
+	};
+
+	pinctrl_usdhc1_200mhz: usdhc1-200mhzgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD1_CLK_USDHC1_CLK				0x196
+			MX8MN_IOMUXC_SD1_CMD_USDHC1_CMD				0x1d6
+			MX8MN_IOMUXC_SD1_DATA0_USDHC1_DATA0			0x1d6
+			MX8MN_IOMUXC_SD1_DATA1_USDHC1_DATA1			0x1d6
+			MX8MN_IOMUXC_SD1_DATA2_USDHC1_DATA2			0x1d6
+			MX8MN_IOMUXC_SD1_DATA3_USDHC1_DATA3			0x1d6
+		>;
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/imx8mn-pew-mon.dts b/arch/arm64/boot/dts/freescale/imx8mn-pew-mon.dts
new file mode 100644
index 000000000..8ff59dc0e
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mn-pew-mon.dts
@@ -0,0 +1,415 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+ /*
+  * Copyright 2022-2023 Panasonic Corporation
+  */
+
+#include "imx8mn-pew-common.dtsi"
+
+/ {
+	model = "Panasonic Electric Works i.MX8MN NXGW monitor type board";
+	compatible = "fsl,imx8mn-pew-mon", "fsl,imx8mn-pew", "fsl,imx8mn";
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0 0x40000000>;	/* DDR1GB*/
+	};
+
+	reg_usdhc1_vmmc: regulator-usdhc1 {
+		compatible = "regulator-fixed";
+		regulator-name = "VSD_1V8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	/* LCM backlight regurator */
+	reg_bl_3v3: regulator-bl-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "BL_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_bl>;
+		gpio = <&gpio1 25 GPIO_ACTIVE_HIGH>;	/* LCM PWR ON */
+               status = "okay";             
+	};
+
+	/* LCM regurator */
+	reg_lcm_10v5: regulator-lcm-10v5 {
+		compatible = "regulator-fixed";
+		regulator-name = "LCM_AVDD_10V5";
+		regulator-min-microvolt = <10500000>;
+		regulator-max-microvolt = <10500000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_lcm>;
+		gpio = <&gpio3 20 GPIO_ACTIVE_HIGH>;	/* LCD FLTB */
+		enable-active-high;
+	};
+
+	/* LCM backlight */
+	lcm_backlight: lcm-backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 100000 0>;	/* 10KHz */
+		power-supply = <&reg_bl_3v3>;
+		status = "okay";
+
+		brightness-levels = <
+					 0  1  2  3  4  5  6  7  8  9
+					10 11 12 13 14 15 16 17 18 19
+					20 21 22 23 24 25 26 27 28 29
+					30 31 32 33 34 35 36 37 38 39
+					40 41 42 43 44 45 46 47 48 49
+					50 51 52 53 54 55 56 57 58 59
+					60 61 62 63 64 65 66 67 68 69
+					70 71 72 73 74 75 76 77 78 79
+					80 81 82 83 84 85 86 87 88 89
+					90 91 92 93 94 95 96 97 98 99
+				    100>;
+		default-brightness-level = <80>;
+	};
+
+	sound-tas2505 {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "tas2505-audio";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,frame-master = <&cpudai>;
+		simple-audio-card,bitclock-master = <&cpudai>;
+		simple-audio-card,mclk-fs = <256>;
+
+		cpudai: simple-audio-card,cpu {
+			sound-dai = <&sai3>;
+			dai-tdm-slot-num = <2>;
+			dai-tdm-slot-width = <32>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&tas2505>;
+			clocks = <&clk IMX8MN_CLK_SAI3_ROOT>;
+		};
+	};
+
+	bt_sco_codec: bt_sco_codec {
+		#sound-dai-cells = <1>;
+		compatible = "linux,bt-sco";
+	};
+
+	sound-bt-sco {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "bt-sco-audio";
+		simple-audio-card,format = "dsp_a";
+		simple-audio-card,bitclock-inversion;
+		simple-audio-card,frame-master = <&btcpu>;
+		simple-audio-card,bitclock-master = <&btcpu>;
+
+		btcpu: simple-audio-card,cpu {
+			sound-dai = <&sai2>;
+			dai-tdm-slot-num = <2>;
+			dai-tdm-slot-width = <16>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&bt_sco_codec 1>;
+		};
+	};
+};
+
+/* LCM backlight pwm */
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_bl_pwm>;
+	status = "okay";
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+       /* techshine_panel_pmic */
+       max20067gtj: max20067gtj@20 {
+               compatible = "analogdevices,max20067gtj";
+               reg = <0x20>;
+		status = "okay";
+       };
+};
+
+&i2c4 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4>;
+	status = "okay";
+
+	/* Audio Codec */
+	tas2505: tas2505@18 {
+		#sound-dai-cells = <0>;
+		compatible = "ti,tas2505";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_codec>;
+		gpio-reset = <&gpio5 5 GPIO_ACTIVE_HIGH>;	/* Codec PDN */
+		reg = <0x18>;
+		audio-cpu = <&sai3>;
+		status = "okay";
+	};
+
+	/* Touch Panel */
+	gt928@5d {
+		compatible = "goodix,gt9xx";
+		reg = <0x5d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_touch>;
+		interrupts = <20 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpio4>;
+		irq-gpios = <&gpio4 20 GPIO_ACTIVE_HIGH>;	/* TP_INT   */
+		irq-flags = <IRQ_TYPE_EDGE_RISING>;
+		reset-gpios = <&gpio3 21 GPIO_ACTIVE_HIGH>;	/* TP_RESET */
+		status = "okay";
+
+		touchscreen-max-id = <2>;
+		touchscreen-size-x = <1024>;
+		touchscreen-size-y = <600>;
+		touchscreen-max-w = <512>;
+		touchscreen-max-p = <512>;
+		goodix,int-sync = <1>;
+		goodix,driver-send-cfg = <1>;
+		goodix,esd-protect = <1>;
+
+		/* チップから読み出した定義から以下を変更  */
+		/*   Touch No:10→2                        */
+		/*   INT trigger: faling edge→rising edge */
+		goodix,cfg-group0 = [
+			41 00 04 58 02 02 3c 01 01 8a 28 0c 50 32 03 05
+			00 00 00 00 00 00 06 18 1a 1e 14 8e 2d 77 30 32
+			12 0c 00 00 00 1b 02 2c 00 00 00 00 00 00 00 00
+			00 23 00 23 4b 94 c0 72 00 00 00 04 93 25 00 85
+			2c 00 7c 33 00 74 3b 00 6d 45 00 6d 70 00 00 00
+			10 08 0a 55 08 08 01 00 00 00 00 00 00 00 00 00
+			00 00 00 00 00 00 00 00 00 00 01 a7 00 00 00 00
+			00 01 04 05 06 07 08 09 0c 0d 0e 0f 10 11 ff ff
+			ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00 02
+			04 06 07 08 0a 0c 0d 0f 10 11 12 13 19 1b 1c 1e
+			1f 20 21 22 23 24 25 26 27 ff ff ff ff ff ff ff
+			ff ff ff ff ff ff ff ff f7 01
+		];
+	};
+};
+
+&mipi_dsi {
+	status = "okay";
+
+	/* LCM */
+	panel@0 {
+		compatible = "techshine,p0700095a";
+		reg = <0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_lcm>;
+		backlight = <&lcm_backlight>;
+		reset-gpio = <&gpio2 9 GPIO_ACTIVE_LOW>;	/* LCD RESET */
+		stbyb-gpio = <&gpio2 11 GPIO_ACTIVE_LOW>;	/* LCD STBYB */
+		power-supply = <&reg_lcm_10v5>;
+		status = "okay";
+	};
+};
+
+&lcdif {
+       status = "okay";
+};
+
+&sai2 {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai2>;
+	assigned-clocks = <&clk IMX8MN_CLK_SAI2>;
+	assigned-clock-parents = <&clk IMX8MN_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <24576000>;
+	status = "okay";
+};
+
+&sai3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	assigned-clocks = <&clk IMX8MN_CLK_SAI3>;
+	assigned-clock-parents = <&clk IMX8MN_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <12288000>;
+	clocks = <&clk IMX8MN_CLK_SAI3_IPG>, <&clk IMX8MN_CLK_DUMMY>,
+		<&clk IMX8MN_CLK_SAI3_ROOT>, <&clk IMX8MN_CLK_DUMMY>,
+		<&clk IMX8MN_CLK_DUMMY>, <&clk IMX8MN_AUDIO_PLL1_OUT>,
+		<&clk IMX8MN_AUDIO_PLL2_OUT>;
+	clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3", "pll8k", "pll11k";
+	fsl,mclk-clkid = <1>;
+	status = "okay";
+};
+
+/* BT */
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clk IMX8MN_CLK_UART1>;
+	assigned-clock-parents = <&clk IMX8MN_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+/* WLAN/BT */
+&usdhc1 {
+	assigned-clocks = <&clk IMX8MN_CLK_USDHC1_ROOT>;
+	assigned-clock-rates = <400000000>;
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>;
+	bus-width = <4>;
+	cap-power-off-card;
+	pm-ignore-notify;
+	keep-power-in-suspend;
+	non-removable;
+	vqmmc-supply = <&reg_usdhc1_vmmc>;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog_common>, <&pinctrl_hog_mon>;
+
+	pinctrl_hog_mon: hogmongrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_GPIO1_IO00_GPIO1_IO0			0x116	/* REF_CLK_32K    */
+			MX8MN_IOMUXC_GPIO1_IO01_GPIO1_IO1			0x116	/* WIFIBT_PMIC_EN */
+			MX8MN_IOMUXC_GPIO1_IO06_GPIO1_IO6			0x116	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO07_GPIO1_IO7			0x116	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO11_GPIO1_IO11			0x016	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO12_GPIO1_IO12			0x016	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO13_GPIO1_IO13			0x100	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO14_GPIO1_IO14			0x116	/* NC             */
+			MX8MN_IOMUXC_GPIO1_IO15_GPIO1_IO15			0x116	/* NC             */
+			MX8MN_IOMUXC_ENET_TD3_GPIO1_IO18			0x116	/* NC             */
+			MX8MN_IOMUXC_ENET_RD2_GPIO1_IO28			0x016	/* NC             */
+			MX8MN_IOMUXC_ENET_RD3_GPIO1_IO29			0x016	/* NC             */
+			MX8MN_IOMUXC_SD2_WP_GPIO2_IO20				0x100	/* NC             */
+			MX8MN_IOMUXC_NAND_ALE_GPIO3_IO0				0x116	/* NC             */
+			MX8MN_IOMUXC_NAND_CE0_B_GPIO3_IO1			0x116	/* NC             */
+			MX8MN_IOMUXC_NAND_DATA00_GPIO3_IO6			0x156	/* NC             */
+			MX8MN_IOMUXC_NAND_DATA01_GPIO3_IO7			0x156	/* NC             */
+			MX8MN_IOMUXC_NAND_DATA02_GPIO3_IO8			0x156	/* NC             */
+			MX8MN_IOMUXC_NAND_DATA03_GPIO3_IO9			0x156	/* NC             */
+			MX8MN_IOMUXC_NAND_DQS_GPIO3_IO14			0x016	/* NC             */
+			MX8MN_IOMUXC_SAI2_RXFS_GPIO4_IO21			0x016	/* NC             */
+			MX8MN_IOMUXC_SAI3_RXFS_GPIO4_IO28			0x116	/* HOST_WAKE_BT   */
+			MX8MN_IOMUXC_SAI3_RXC_GPIO4_IO29			0x116	/* BT_WAKE_HOST   */
+			MX8MN_IOMUXC_SPDIF_TX_GPIO5_IO3				0x116	/* HOST_WAKE_WLAN */
+			MX8MN_IOMUXC_SPDIF_RX_GPIO5_IO4				0x116	/* WL_WAKE_HOST   */
+		>;
+	};
+
+
+	pinctrl_i2c3: i2c3grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C3_SCL_I2C3_SCL				0x400000c3
+			MX8MN_IOMUXC_I2C3_SDA_I2C3_SDA				0x400000c3
+		>;
+	};
+
+	pinctrl_i2c4: i2c4grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_I2C4_SCL_I2C4_SCL				0x400000c3
+			MX8MN_IOMUXC_I2C4_SDA_I2C4_SDA				0x400000c3
+		>;
+	};
+
+	pinctrl_codec: codecgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SPDIF_EXT_CLK_GPIO5_IO5		0x116	/* Codec PDN */
+		>;
+	};
+
+	pinctrl_reg_bl: regblgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_ENET_RXC_GPIO1_IO25			0x100	/* LCD PWE ON */
+		>;
+	};
+
+	pinctrl_bl_pwm: blpwmgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_GPIO1_IO13_PWM2_OUT			0x100	/* LCM_PWM */
+		>;
+	};
+
+	pinctrl_reg_lcm: reglcmgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SAI5_RXC_GPIO3_IO20			0x116	/* LCD FLTB */
+		>;
+	};
+
+	pinctrl_lcm: lcmgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD1_DATA7_GPIO2_IO9			0x100	/* LCD RESET  */
+			MX8MN_IOMUXC_SD1_STROBE_GPIO2_IO11			0x100	/* LCD STBYBT */
+		>;
+	};
+
+	pinctrl_touch: touchgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SAI5_RXD0_GPIO3_IO21			0x116	/* TP_RESET */
+			/* MX8MN_IOMUXC_SAI1_MCLK_GPIO4_IO20			0x016 */ /* TP_INT (imx8mnにはGPIO4_IO20がない)  */
+		>;
+	};
+
+	pinctrl_sai2: sai2grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SAI2_TXC_SAI2_TX_BCLK			0x116
+			MX8MN_IOMUXC_SAI2_TXFS_SAI2_TX_SYNC			0x116
+			MX8MN_IOMUXC_SAI2_TXD0_SAI2_TX_DATA0		0x116
+			MX8MN_IOMUXC_SAI2_RXD0_SAI2_RX_DATA0		0x116
+		>;
+	};
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SAI3_RXD_SAI3_RX_DATA0			0x116
+			MX8MN_IOMUXC_SAI3_TXFS_SAI3_TX_SYNC			0x116
+			MX8MN_IOMUXC_SAI3_TXC_SAI3_TX_BCLK			0x116
+			MX8MN_IOMUXC_SAI3_MCLK_SAI3_MCLK			0x116
+			MX8MN_IOMUXC_SAI3_TXD_SAI3_TX_DATA0			0x116
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_UART1_RXD_UART1_DCE_RX			0x040
+			MX8MN_IOMUXC_UART1_TXD_UART1_DCE_TX			0x040
+			MX8MN_IOMUXC_UART3_RXD_UART1_DCE_CTS_B		0x040
+			MX8MN_IOMUXC_UART3_TXD_UART1_DCE_RTS_B		0x040
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD1_CLK_USDHC1_CLK				0x190
+			MX8MN_IOMUXC_SD1_CMD_USDHC1_CMD				0x1d0
+			MX8MN_IOMUXC_SD1_DATA0_USDHC1_DATA0			0x1d0
+			MX8MN_IOMUXC_SD1_DATA1_USDHC1_DATA1			0x1d0
+			MX8MN_IOMUXC_SD1_DATA2_USDHC1_DATA2			0x1d0
+			MX8MN_IOMUXC_SD1_DATA3_USDHC1_DATA3			0x1d0
+		>;
+	};
+
+	pinctrl_usdhc1_100mhz: usdhc1-100mhzgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD1_CLK_USDHC1_CLK				0x194
+			MX8MN_IOMUXC_SD1_CMD_USDHC1_CMD				0x1d4
+			MX8MN_IOMUXC_SD1_DATA0_USDHC1_DATA0			0x1d4
+			MX8MN_IOMUXC_SD1_DATA1_USDHC1_DATA1			0x1d4
+			MX8MN_IOMUXC_SD1_DATA2_USDHC1_DATA2			0x1d4
+			MX8MN_IOMUXC_SD1_DATA3_USDHC1_DATA3			0x1d4
+		>;
+	};
+
+	pinctrl_usdhc1_200mhz: usdhc1-200mhzgrp {
+		fsl,pins = <
+			MX8MN_IOMUXC_SD1_CLK_USDHC1_CLK				0x196
+			MX8MN_IOMUXC_SD1_CMD_USDHC1_CMD				0x1d6
+			MX8MN_IOMUXC_SD1_DATA0_USDHC1_DATA0			0x1d6
+			MX8MN_IOMUXC_SD1_DATA1_USDHC1_DATA1			0x1d6
+			MX8MN_IOMUXC_SD1_DATA2_USDHC1_DATA2			0x1d6
+			MX8MN_IOMUXC_SD1_DATA3_USDHC1_DATA3			0x1d6
+		>;
+	};
+};
diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
index 23efabcb0..8889fd99f 100644
--- a/arch/arm64/kernel/process.c
+++ b/arch/arm64/kernel/process.c
@@ -5,6 +5,7 @@
  * Original Copyright (C) 1995  Linus Torvalds
  * Copyright (C) 1996-2000 Russell King - Converted to ARM.
  * Copyright (C) 2012 ARM Ltd.
+ * Copyright 2022-2023 Panasonic Corporation
  */
 #include <linux/compat.h>
 #include <linux/efi.h>
@@ -40,6 +41,7 @@
 #include <linux/percpu.h>
 #include <linux/thread_info.h>
 #include <linux/prctl.h>
+#include <linux/gpio.h>		/* 2021.7.28.add */
 
 #include <asm/alternative.h>
 #include <asm/compat.h>
@@ -125,6 +127,26 @@ void machine_power_off(void)
  */
 void machine_restart(char *cmd)
 {
+	/* 2021.7.28.add : first, try to reset by /SYS_PRST */
+	#define  SYS_PRST (88)
+	int err = gpio_request(SYS_PRST, "SYS_PRST");
+	if (err) {
+		printk("Failed to set direction /SYS_PRST\n");
+	} else {
+		err = gpio_direction_output(SYS_PRST, 1);
+		mdelay(200);
+		if (err) {
+			printk("Failed to set direction /SYS_PRST\n");
+		} else {
+			gpio_set_value(SYS_PRST, 0);
+			printk("Can't /SYS_PRST\n");
+
+			/* wait for reset to assert... */
+			mdelay(500);
+		}
+	}
+	/* add.end */
+
 	/* Disable interrupts first */
 	local_irq_disable();
 	smp_send_stop();
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index bb2eb6808..79b282479 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -650,4 +650,13 @@ config DRM_PANEL_WKS_101WX001
 	  Say Y here if you want to enable support for the WKS
 	  101WX001 controller for 1280x800 LCD panel
 
+config DRM_PANEL_TECHSHINE_P0700095A
+	tristate "Techshine P0700095A panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for Techshine P0700095A
+	  panel. It has a resolution of 1024x600 pixels.
+
 endmenu
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index d15a67e92..317b578d9 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -67,3 +67,4 @@ obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_WIDECHIPS_WS2401) += panel-widechips-ws2401.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
 obj-$(CONFIG_DRM_PANEL_WKS_101WX001) += panel-wks-101wx001.o
+obj-$(CONFIG_DRM_PANEL_TECHSHINE_P0700095A) += panel-techshine-p0700095a.o
diff --git a/drivers/gpu/drm/panel/panel-techshine-p0700095a.c b/drivers/gpu/drm/panel/panel-techshine-p0700095a.c
new file mode 100644
index 000000000..acd4a5e24
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-techshine-p0700095a.c
@@ -0,0 +1,440 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2022 Panasonic Corporation
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regmap.h>
+#include <linux/i2c.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_device.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#define RETRY_MAX_TIMES 5
+struct techshine_panel {
+	struct drm_panel base;
+	struct mipi_dsi_device *link;
+
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *stbyb_gpio;
+
+	bool prepared;
+	bool enabled;
+};
+
+struct techshine_panel_priv {
+        struct device *dev;
+        struct regmap *regmap;
+};
+
+struct i2c_client *pmic_i2c_client = NULL;
+
+struct regmap_config techshine_panel_i2c_regmap = {
+       .reg_bits = 8,
+       .val_bits = 8,
+       .max_register = 0x0b,
+       .cache_type = REGCACHE_NONE
+};
+
+static const struct of_device_id max20067gtj_of_match[] = {
+        { .compatible = "analogdevices,max20067gtj" },
+        {},
+};
+MODULE_DEVICE_TABLE(of, _max20067gtj_of_match);
+
+static const struct i2c_device_id techshine_panel_i2c_id[] = {
+        { "max20067gtj", 0 },
+        {}
+};
+MODULE_DEVICE_TABLE(i2c, techshine_panel_i2c_id);
+
+static int techshine_panel_i2c_probe(struct i2c_client *i2c,
+        const struct i2c_device_id *id)
+{
+        int ret = 0;
+        struct techshine_panel_priv *techshine_panel;
+        struct device_node *np = i2c->dev.of_node;
+        const struct regmap_config *regmap_config = &techshine_panel_i2c_regmap;
+
+        techshine_panel = devm_kzalloc(&i2c->dev, sizeof(*techshine_panel), GFP_KERNEL);
+        if (techshine_panel == NULL)
+                return -ENOMEM;
+
+        techshine_panel->regmap = devm_regmap_init_i2c(i2c, regmap_config);
+        if (IS_ERR(techshine_panel->regmap)) {
+                ret = PTR_ERR(techshine_panel->regmap);
+                dev_err(&i2c->dev, "Failed to allocate register map: %d\n",
+                        ret);
+                return ret;
+        }
+
+       techshine_panel->dev = &i2c->dev;
+       dev_set_drvdata(techshine_panel->dev,techshine_panel);
+       pmic_i2c_client = i2c;
+       dev_info(&i2c->dev, "techshine_panel probe OK\n");
+       return 0;
+}
+
+static int techshine_panel_i2c_remove(struct i2c_client *i2c)
+{
+       pmic_i2c_client = NULL;
+       return 0;
+}
+
+static struct i2c_driver techshine_panel_i2c_driver = {
+        .driver = {
+                .name           = "analogdevices,max20067gtj",
+                .of_match_table = of_match_ptr(max20067gtj_of_match),
+        },
+        .probe          = techshine_panel_i2c_probe,
+        .remove         = techshine_panel_i2c_remove,
+        .id_table       = techshine_panel_i2c_id,
+};
+module_i2c_driver(techshine_panel_i2c_driver);
+
+static int i2c_write_byte(struct i2c_client *client, u8 addr, u8 data)
+{
+        struct i2c_msg msg;
+        int retry;
+        u8 buf[2];
+
+        buf[0] = addr;
+        buf[1] = data;
+        msg.addr = client->addr;
+        msg.flags = 0;
+        msg.len = 2;
+        msg.buf = buf;
+
+        for (retry = 0; retry < RETRY_MAX_TIMES; retry++)
+        {
+                if(likely(i2c_transfer(client->adapter, &msg, 1)))
+                        break;
+                dev_dbg(&client->dev, "I2c read retry[%d]:reg:0x%02x data:0x%02x\n",retry + 1, addr, data);
+                usleep_range(2000, 2100);
+        }
+        if(unlikely(retry == RETRY_MAX_TIMES))
+        {
+                dev_err(&client->dev,"I2c read failed,dev:%02x,reg:%02x,data:%02x\n",client->addr, addr, data);
+                return -EAGAIN;
+        }
+        return 0;
+}
+
+static inline
+struct techshine_panel *to_techshine_panel(struct drm_panel *panel)
+{
+	return container_of(panel, struct techshine_panel, base);
+}
+
+static int techshine_panel_disable(struct drm_panel *panel)
+{
+	struct techshine_panel *techshine = to_techshine_panel(panel);
+
+	if (!techshine->enabled)
+		return 0;
+
+	mipi_dsi_dcs_set_display_off(techshine->link);
+
+	techshine->enabled = false;
+
+	return 0;
+}
+
+static int techshine_panel_enable(struct drm_panel *panel)
+{
+	struct techshine_panel *techshine = to_techshine_panel(panel);
+	int err;
+
+	if (techshine->enabled)
+		return 0;
+
+	err = mipi_dsi_dcs_set_display_on(techshine->link);
+	if (err < 0) {
+		dev_err(panel->dev, "failed to set display on: %d\n", err);
+		return err;
+	}
+
+	techshine->enabled = true;
+
+	return 0;
+}
+
+static int techshine_panel_unprepare(struct drm_panel *panel)
+{
+	struct techshine_panel *techshine = to_techshine_panel(panel);
+
+	if (!techshine->prepared)
+		return 0;
+        if(!pmic_i2c_client)
+        {
+                dev_err(panel->dev, "i2c probe not called error");
+                return -ENODEV;
+        }
+        msleep(30);
+        gpiod_set_value_cansleep(techshine->stbyb_gpio, 1);
+        msleep(170);
+        i2c_write_byte(pmic_i2c_client,0x02,0x7d);
+        msleep(5);
+        i2c_write_byte(pmic_i2c_client,0x02,0x79);
+        msleep(5);
+        i2c_write_byte(pmic_i2c_client,0x02,0x71);
+        i2c_write_byte(pmic_i2c_client,0x02,0x30);
+
+        msleep(200);
+	mipi_dsi_dcs_enter_sleep_mode(techshine->link);
+	gpiod_set_value_cansleep(techshine->reset_gpio, 1);
+	regulator_disable(techshine->supply);
+
+	techshine->prepared = false;
+        dev_info(panel->dev, "power on success!\n");
+
+	return 0;
+}
+
+static int techshine_panel_prepare(struct drm_panel *panel)
+{
+	struct techshine_panel *techshine = to_techshine_panel(panel);
+	int err;
+
+	if (techshine->prepared)
+		return 0;
+
+        if(!pmic_i2c_client)
+        {
+                dev_err(panel->dev, "i2c probe not called error");
+                return -ENODEV;
+        }
+
+	err = regulator_enable(techshine->supply);
+	if (err < 0) {
+		dev_err(panel->dev, "failed to regulator enable: %d\n", err);
+		return err;
+	}
+   msleep(1);
+   gpiod_set_value_cansleep(techshine->stbyb_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(techshine->reset_gpio, 0);
+        msleep(10);
+	err = mipi_dsi_dcs_exit_sleep_mode(techshine->link);
+	if (err < 0) {
+		dev_err(panel->dev, "failed to exit sleep mode: %d\n", err);
+		goto poweroff;
+	}
+        msleep(10);
+        gpiod_set_value_cansleep(techshine->stbyb_gpio, 1);
+        msleep(30);
+        gpiod_set_value_cansleep(techshine->stbyb_gpio, 0);
+        msleep(55);
+        if(i2c_write_byte(pmic_i2c_client,0x06,0x23))
+        {
+                dev_err(panel->dev, "pmic i2c error [set vcom]\n");
+                goto poweroff;
+        }
+        if(i2c_write_byte(pmic_i2c_client,0x02,0x51))
+        {
+                dev_err(panel->dev, "pmic i2c error [on s]\n");
+                goto poweroff;
+        }
+        if(i2c_write_byte(pmic_i2c_client,0x02,0x53))
+        {
+                dev_err(panel->dev, "pmic i2c error [vcom on]\n");
+                goto poweroff;
+        }
+        msleep(5);
+        if(i2c_write_byte(pmic_i2c_client,0x02,0x5b))
+        {
+                dev_err(panel->dev, "pmic i2c error [VGL on]\n");
+                goto poweroff;
+        }
+        if(i2c_write_byte(pmic_i2c_client,0x02,0x5f))
+        {
+                dev_err(panel->dev, "pmic i2c error [VGH on]\n");
+                goto poweroff;
+        }
+        msleep(200);
+	techshine->prepared = true;
+        dev_info(panel->dev, "power on success!\n");
+	return 0;
+
+poweroff:
+        msleep(30);
+	gpiod_set_value_cansleep(techshine->stbyb_gpio, 1);
+        msleep(170);
+        i2c_write_byte(pmic_i2c_client,0x02,0x7d);
+        msleep(5);
+        i2c_write_byte(pmic_i2c_client,0x02,0x79);
+        msleep(5);
+        i2c_write_byte(pmic_i2c_client,0x02,0x71);
+        i2c_write_byte(pmic_i2c_client,0x02,0x30);
+
+        msleep(200);
+        mipi_dsi_dcs_enter_sleep_mode(techshine->link);
+	gpiod_set_value_cansleep(techshine->reset_gpio, 1);
+	regulator_disable(techshine->supply);
+
+	return err;
+}
+
+static const struct drm_display_mode default_mode = {
+	.clock = 51668,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 160,
+	.hsync_end = 1024 + 160 + 10,
+	.htotal = 1024 + 160 + 10 + 160,
+	.vdisplay = 600,
+	.vsync_start = 600 + 12,
+	.vsync_end = 600 + 12 + 1,
+	.vtotal = 600 + 12 + 1 + 23,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	.width_mm = 154,
+	.height_mm = 86,
+};
+
+static int techshine_panel_get_modes(struct drm_panel *panel,
+				       struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &default_mode);
+	if (!mode) {
+		dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+			default_mode.hdisplay, default_mode.vdisplay,
+			drm_mode_vrefresh(&default_mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs techshine_panel_funcs = {
+	.disable = techshine_panel_disable,
+	.unprepare = techshine_panel_unprepare,
+	.prepare = techshine_panel_prepare,
+	.enable = techshine_panel_enable,
+	.get_modes = techshine_panel_get_modes,
+};
+
+static const struct of_device_id techshine_of_match[] = {
+	{ .compatible = "techshine,p0700095a", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, techshine_of_match);
+
+static int techshine_panel_add(struct techshine_panel *techshine)
+{
+	struct device *dev = &techshine->link->dev;
+	int err;
+
+	techshine->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(techshine->supply)) {
+		err = PTR_ERR(techshine->supply);
+		dev_err(dev, "failed to request regulator: %d\n", err);
+		return err;
+	}
+
+	techshine->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+							   GPIOD_OUT_HIGH);
+	if (IS_ERR(techshine->reset_gpio)) {
+		err = PTR_ERR(techshine->reset_gpio);
+		dev_err(dev, "failed to get reset gpio: %d\n", err);
+		return err;
+	}
+
+	techshine->stbyb_gpio = devm_gpiod_get_optional(dev, "stbyb",
+							   GPIOD_OUT_HIGH);
+	if (IS_ERR(techshine->stbyb_gpio)) {
+		err = PTR_ERR(techshine->stbyb_gpio);
+		dev_err(dev, "failed to get stbyb gpio: %d\n", err);
+		return err;
+	}
+
+	drm_panel_init(&techshine->base, &techshine->link->dev,
+		       &techshine_panel_funcs, DRM_MODE_CONNECTOR_DSI);
+       dev_err(dev, "%x %x\n", &techshine->base,&techshine->base.dev);
+	err = drm_panel_of_backlight(&techshine->base);
+       if (err){ dev_err(dev, "failed to :drm_panel_of_backlight %d\n", err);
+               return err;}
+
+	drm_panel_add(&techshine->base);
+
+	return 0;
+}
+
+static void techshine_panel_del(struct techshine_panel *techshine)
+{
+	drm_panel_remove(&techshine->base);
+}
+
+static int techshine_panel_probe(struct mipi_dsi_device *dsi)
+{
+	struct techshine_panel *techshine;
+	int err;
+
+       dev_info(&pmic_i2c_client->dev, "techshine_panel probe in\n");
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+
+	techshine = devm_kzalloc(&dsi->dev, sizeof(*techshine), GFP_KERNEL);
+	if (!techshine)
+		return -ENOMEM;
+
+	mipi_dsi_set_drvdata(dsi, techshine);
+	techshine->link = dsi;
+
+	err = techshine_panel_add(techshine);
+	if (err < 0)
+		return err;
+       dev_info(&pmic_i2c_client->dev, "techshine_panel probe out\n");
+	return mipi_dsi_attach(dsi);
+}
+
+static int techshine_panel_remove(struct mipi_dsi_device *dsi)
+{
+	struct techshine_panel *techshine = mipi_dsi_get_drvdata(dsi);
+
+	drm_panel_disable(&techshine->base);
+	drm_panel_unprepare(&techshine->base);
+	mipi_dsi_detach(dsi);
+	techshine_panel_del(techshine);
+
+	return 0;
+}
+
+static void techshine_panel_shutdown(struct mipi_dsi_device *dsi)
+{
+	struct techshine_panel *techshine = mipi_dsi_get_drvdata(dsi);
+
+	drm_panel_disable(&techshine->base);
+	drm_panel_unprepare(&techshine->base);
+}
+
+static struct mipi_dsi_driver techshine_panel_driver = {
+	.driver = {
+		.name = "panel-techshine-p0700095a",
+		.of_match_table = techshine_of_match,
+	},
+	.probe = techshine_panel_probe,
+	.remove = techshine_panel_remove,
+	.shutdown = techshine_panel_shutdown,
+};
+module_mipi_dsi_driver(techshine_panel_driver);
+
+MODULE_DESCRIPTION("techshine p0700095a panel driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index f9d7cd3be..8cbb873df 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1392,6 +1392,7 @@ config TOUCHSCREEN_ZINITIX
 	  module will be called zinitix.
 
 source "drivers/input/touchscreen/synaptics_dsx/Kconfig"
+source "drivers/input/touchscreen/goodix_gt9xx/Kconfig"
 endif
 
 source "drivers/input/touchscreen/focaltech_touch/Kconfig"
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 4dd7f2399..1f63a585a 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -118,3 +118,4 @@ obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
 obj-$(CONFIG_TOUCHSCREEN_RASPBERRYPI_FW)	+= raspberrypi-ts.o
 obj-$(CONFIG_TOUCHSCREEN_IQS5XX)	+= iqs5xx.o
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX)	+= zinitix.o
+obj-$(CONFIG_TOUCHSCREEN_GT9XX)		+= goodix_gt9xx/
diff --git a/drivers/input/touchscreen/goodix_gt9xx/Kconfig b/drivers/input/touchscreen/goodix_gt9xx/Kconfig
new file mode 100644
index 000000000..f0eff1979
--- /dev/null
+++ b/drivers/input/touchscreen/goodix_gt9xx/Kconfig
@@ -0,0 +1,35 @@
+#
+# Goodix GT9xx Touchscreen driver
+#
+config TOUCHSCREEN_GT9XX
+	bool "Goodix touchpanel GT9xx series"
+	depends on I2C
+	help
+	  Say Y here if you have a Goodix GT9xx touchscreen
+	  controller.
+
+          If unsure, say N.
+
+config TOUCHSCREEN_GT9XX_UPDATE
+	tristate "Goodix GT9xx touch controller auto update support"
+	depends on TOUCHSCREEN_GT9XX
+	default y
+	help
+	  Enable this for support firmware update.
+
+	  Say Y here if you want update touch controller firmware.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_GT9XX_TOOL
+	tristate "Goodix GT9xx Tools for debuging"
+	depends on TOUCHSCREEN_GT9XX
+	default y
+	help
+	  This implement interface support for Goodix GT9xx
+	  touchscreen debug.
+
+	  Say Y here if you want to have a Android app debug interface
+	  to your system.
+
+	  If unsure, say N.
diff --git a/drivers/input/touchscreen/goodix_gt9xx/Makefile b/drivers/input/touchscreen/goodix_gt9xx/Makefile
new file mode 100644
index 000000000..73ed2e91b
--- /dev/null
+++ b/drivers/input/touchscreen/goodix_gt9xx/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the Goodix gt9xx touchscreen driver.
+#
+#subdir-ccflags-y += -DDEBUG
+obj-$(CONFIG_TOUCHSCREEN_GT9XX)		+= gt9xx.o
+obj-$(CONFIG_TOUCHSCREEN_GT9XX_UPDATE)	+= gt9xx_update.o
+obj-$(CONFIG_TOUCHSCREEN_GT9XX_TOOL)	+= goodix_tool.o
diff --git a/drivers/input/touchscreen/goodix_gt9xx/goodix_tool.c b/drivers/input/touchscreen/goodix_gt9xx/goodix_tool.c
new file mode 100644
index 000000000..c2a2fd9b2
--- /dev/null
+++ b/drivers/input/touchscreen/goodix_gt9xx/goodix_tool.c
@@ -0,0 +1,531 @@
+/*
+ * Goodix GT9xx touchscreen driver
+ *
+ * Copyright  (C)  2016 - 2017 Goodix. Ltd.
+ *
+ * Copyright 2022 Panasonic Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 2.8.0.1
+ * Release Date: 2017/11/24
+ */
+
+#include "gt9xx.h"
+
+#define DATA_LENGTH_UINT	512
+#define CMD_HEAD_LENGTH		(sizeof(struct st_cmd_head) - sizeof(u8 *))
+static char procname[20] = {0};
+
+#pragma pack(1)
+struct st_cmd_head {
+	u8	wr;		/*write read flag 0:R 1:W 2:PID 3:*/
+	u8	flag;		/*0:no need flag/int 1: need flag 2:need int*/
+	u8	flag_addr[2];	/*flag address*/
+	u8	flag_val;	/*flag val*/
+	u8	flag_relation;	/*flag_val:flag 0:not equal 1:equal 2:> 3:<*/
+	u16	circle;		/*polling cycle*/
+	u8	times;		/*plling times*/
+	u8	retry;		/*I2C retry times*/
+	u16	delay;		/*delay before read or after write*/
+	u16	data_len;	/*data length*/
+	u8	addr_len;	/*address length*/
+	u8	addr[2];	/*address*/
+	u8	res[3];		/*reserved*/
+	u8	*data; };	/*data pointer*/
+#pragma pack()
+struct st_cmd_head cmd_head;
+
+static struct i2c_client *gt_client;
+static struct proc_dir_entry *goodix_proc_entry;
+
+static ssize_t goodix_tool_read(struct file *, char __user *, size_t, loff_t *);
+static ssize_t goodix_tool_write(struct file *, const char __user *, size_t, loff_t *);
+static const struct proc_ops gtp_proc_ops = {
+	.proc_read = goodix_tool_read,
+	.proc_write = goodix_tool_write,
+};
+
+/* static s32 goodix_tool_write(struct file *filp,
+ * const char __user *buff, unsigned long len, void *data);
+ */
+/*static s32 goodix_tool_read( char *page, char
+ **start, off_t off, int count, int *eof, void *data );
+ */
+static s32 (*tool_i2c_read)(u8 *, u16);
+static s32 (*tool_i2c_write)(u8 *, u16);
+
+static s32 DATA_LENGTH = (s32)0;
+static s8 IC_TYPE[16] = "GT9XX";
+
+static void tool_set_proc_name(char *procname)
+{
+	snprintf(procname, 20, "gmnode"); /* modify for moto */
+}
+
+static s32 tool_i2c_read_no_extra(u8 *buf, u16 len)
+{
+	s32 ret = -1;
+	s32 i = 0;
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+	for (i = 0; i < cmd_head.retry; i++) {
+		ret = gtp_i2c_read(ts->client, buf, len + GTP_ADDR_LENGTH);
+		if (ret > 0)
+			break;
+	}
+	return ret;
+}
+
+static s32 tool_i2c_write_no_extra(u8 *buf, u16 len)
+{
+	s32 ret = -1;
+	s32 i = 0;
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+	for (i = 0; i < cmd_head.retry; i++) {
+		ret = gtp_i2c_write(ts->client, buf, len);
+		if (ret > 0)
+			break;
+	}
+
+	return ret;
+}
+
+static s32 tool_i2c_read_with_extra(u8 *buf, u16 len)
+{
+	s32 ret = -1;
+	u8 pre[2] = {0x0f, 0xff};
+	u8 end[2] = {0x80, 0x00};
+
+	tool_i2c_write_no_extra(pre, 2);
+	ret = tool_i2c_read_no_extra(buf, len);
+	tool_i2c_write_no_extra(end, 2);
+
+	return ret;
+}
+
+static s32 tool_i2c_write_with_extra(u8 *buf, u16 len)
+{
+	s32 ret = -1;
+	u8 pre[2] = {0x0f, 0xff};
+	u8 end[2] = {0x80, 0x00};
+
+	tool_i2c_write_no_extra(pre, 2);
+	ret = tool_i2c_write_no_extra(buf, len);
+	tool_i2c_write_no_extra(end, 2);
+
+	return ret;
+}
+
+static void register_i2c_func(void)
+{
+	/* if (!strncmp(IC_TYPE, "GT818", 5)
+	 *  || !strncmp(IC_TYPE, "GT816", 5)
+	 *  || !strncmp(IC_TYPE, "GT811", 5)
+	 *  || !strncmp(IC_TYPE, "GT818F", 6)
+	 *  || !strncmp(IC_TYPE, "GT827", 5)
+	 *  || !strncmp(IC_TYPE,"GT828", 5)
+	 *  || !strncmp(IC_TYPE, "GT813", 5))
+	 */
+	if (strncmp(IC_TYPE, "GT8110", 6) &&
+	    strncmp(IC_TYPE, "GT8105", 6) &&
+	    strncmp(IC_TYPE, "GT801", 5) &&
+	    strncmp(IC_TYPE, "GT800", 5) &&
+	    strncmp(IC_TYPE, "GT801PLUS", 9) &&
+	    strncmp(IC_TYPE, "GT811", 5) &&
+	    strncmp(IC_TYPE, "GTxxx", 5) &&
+	    strncmp(IC_TYPE, "GT9XX", 5)) {
+		tool_i2c_read = tool_i2c_read_with_extra;
+		tool_i2c_write = tool_i2c_write_with_extra;
+		dev_dbg(&gt_client->dev, "I2C function: with pre and end cmd!");
+	} else {
+		tool_i2c_read = tool_i2c_read_no_extra;
+		tool_i2c_write = tool_i2c_write_no_extra;
+		dev_info(&gt_client->dev, "I2C function: without pre and end cmd!");
+	}
+}
+
+static void unregister_i2c_func(void)
+{
+	tool_i2c_read = NULL;
+	tool_i2c_write = NULL;
+	dev_info(&gt_client->dev, "I2C function: unregister i2c transfer function!");
+}
+
+s32 init_wr_node(struct i2c_client *client)
+{
+	s32 i;
+
+	gt_client = client;
+	memset(&cmd_head, 0, sizeof(cmd_head));
+	cmd_head.data = NULL;
+
+	i = 6;
+	while ((!cmd_head.data) && i) {
+		cmd_head.data = kzalloc(i * DATA_LENGTH_UINT, GFP_KERNEL);
+		if (cmd_head.data)
+			break;
+		i--;
+	}
+	if (i) {
+		DATA_LENGTH = i * DATA_LENGTH_UINT - GTP_ADDR_LENGTH;
+		dev_info(&gt_client->dev,
+			 "Alloc memory size:%d.", DATA_LENGTH);
+	} else {
+		dev_err(&gt_client->dev, "Apply for memory failed.");
+		return FAIL;
+	}
+
+	cmd_head.addr_len = 2;
+	cmd_head.retry = 5;
+
+	register_i2c_func();
+
+	tool_set_proc_name(procname);
+	goodix_proc_entry = proc_create(procname, 0666, NULL, &gtp_proc_ops);
+	if (!goodix_proc_entry) {
+		dev_err(&gt_client->dev, "Couldn't create proc entry!");
+		return FAIL;
+	}
+
+	dev_info(&gt_client->dev, "Create proc entry success!");
+	return SUCCESS;
+}
+
+void uninit_wr_node(void)
+{
+	kfree(cmd_head.data);
+	cmd_head.data = NULL;
+	unregister_i2c_func();
+	remove_proc_entry(procname, NULL);
+}
+
+static u8 relation(u8 src, u8 dst, u8 rlt)
+{
+	u8 ret = 0;
+
+	switch (rlt) {
+	case 0:
+		ret = (src != dst) ? true : false;
+		break;
+
+	case 1:
+		ret = (src == dst) ? true : false;
+		dev_dbg(&gt_client->dev,
+			"equal:src:0x%02x  dst:0x%02x  ret:%d.",
+			src, dst, (s32)ret);
+		break;
+
+	case 2:
+		ret = (src > dst) ? true : false;
+		break;
+
+	case 3:
+		ret = (src < dst) ? true : false;
+		break;
+
+	case 4:
+		ret = (src & dst) ? true : false;
+		break;
+
+	case 5:
+		ret = (!(src | dst)) ? true : false;
+		break;
+
+	default:
+		ret = false;
+		break;
+	}
+
+	return ret;
+}
+
+/*******************************************************
+ * Function:
+ *	Comfirm function.
+ * Input:
+ *	None.
+ * Output:
+ *	Return write length.
+ ********************************************************/
+static u8 comfirm(void)
+{
+	s32 i = 0;
+	u8 buf[32];
+
+	memcpy(buf, cmd_head.flag_addr, cmd_head.addr_len);
+
+	for (i = 0; i < cmd_head.times; i++) {
+		if (tool_i2c_read(buf, 1) <= 0) {
+			dev_err(&gt_client->dev, "Read flag data failed!");
+			return FAIL;
+		}
+		if (true == relation(buf[GTP_ADDR_LENGTH],
+		 cmd_head.flag_val, cmd_head.flag_relation)) {
+			dev_dbg(&gt_client->dev, "value at flag addr:0x%02x.",
+				buf[GTP_ADDR_LENGTH]);
+			dev_dbg(&gt_client->dev, "flag value:0x%02x.",
+				cmd_head.flag_val);
+			break;
+		}
+
+		msleep(cmd_head.circle);
+	}
+
+	if (i >= cmd_head.times) {
+		dev_err(&gt_client->dev, "Can't get the continue flag!");
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+ssize_t goodix_tool_write(struct file *filp, const char __user *buff,
+			  size_t len, loff_t *off)
+{
+	s32 ret = 0;
+	struct goodix_ts_data *ts = i2c_get_clientdata(gt_client);
+
+	ret = copy_from_user(&cmd_head, buff, CMD_HEAD_LENGTH);
+	if (ret) {
+		dev_err(&gt_client->dev, "copy_from_user failed.");
+		return -EPERM;
+	}
+
+	dev_dbg(&gt_client->dev, "[Operation]wr: %02X", cmd_head.wr);
+	dev_dbg(&gt_client->dev,
+		"[Flag]flag: %02X,addr: %02X%02X,value: %02X,relation: %02X",
+		cmd_head.flag, cmd_head.flag_addr[0],
+		cmd_head.flag_addr[1], cmd_head.flag_val,
+		cmd_head.flag_relation);
+	dev_dbg(&gt_client->dev,
+		"[Retry]circle: %d,times: %d,retry: %d, delay: %d",
+		(s32)cmd_head.circle,
+		(s32)cmd_head.times, (s32)cmd_head.retry,
+		(s32)cmd_head.delay);
+
+	if (1 == cmd_head.wr) {
+		if (cmd_head.data_len > DATA_LENGTH) {
+			dev_err(&gt_client->dev,
+				"Tool write failed data too long");
+			return -EPERM;
+		}
+		ret = copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH],
+				     &buff[CMD_HEAD_LENGTH],
+				     cmd_head.data_len);
+		if (ret) {
+			dev_err(&gt_client->dev, "copy_from_user failed.");
+			return -EPERM;
+		}
+		memcpy(&cmd_head.data[GTP_ADDR_LENGTH - cmd_head.addr_len],
+		       cmd_head.addr, cmd_head.addr_len);
+
+		GTP_DEBUG_ARRAY(cmd_head.data, cmd_head.data_len +
+				cmd_head.addr_len);
+
+		if (1 == cmd_head.flag) {
+			if (FAIL == comfirm()) {
+				dev_err(&gt_client->dev,
+					"[WRITE]Comfirm fail!");
+				return -EPERM;
+			}
+		} else if (2 == cmd_head.flag) {
+			/*Need interrupt!*/
+		}
+		if (tool_i2c_write(&cmd_head.data[GTP_ADDR_LENGTH -
+				   cmd_head.addr_len], cmd_head.data_len +
+				   cmd_head.addr_len) <= 0) {
+			dev_err(&gt_client->dev, "[WRITE]Write data failed!");
+			return -EPERM;
+		}
+
+		GTP_DEBUG_ARRAY(&cmd_head.data[GTP_ADDR_LENGTH -
+				cmd_head.addr_len],
+				cmd_head.data_len + cmd_head.addr_len);
+		if (cmd_head.delay)
+			msleep(cmd_head.delay);
+	} else if (3 == cmd_head.wr) {
+		if (cmd_head.data_len > DATA_LENGTH) {
+			dev_err(&gt_client->dev,
+				"Tool write failed data too long");
+			return -EPERM;
+		}
+		ret = copy_from_user(&cmd_head.data[0], &buff[CMD_HEAD_LENGTH],
+				     cmd_head.data_len);
+		if (ret) {
+			dev_err(&gt_client->dev, "copy_from_user failed.");
+			return -EPERM;
+		}
+		memcpy(IC_TYPE, cmd_head.data, cmd_head.data_len);
+
+		register_i2c_func();
+	} else if (5 == cmd_head.wr) {
+		/*memcpy(IC_TYPE, cmd_head.data, cmd_head.data_len);*/
+	} else if (7 == cmd_head.wr) {/*disable irq!*/
+		gtp_work_control_enable(i2c_get_clientdata(gt_client), false);
+
+		if (ts->pdata->esd_protect)
+			gtp_esd_off(ts);
+	} else if (9 == cmd_head.wr) {/*enable irq!*/
+		gtp_work_control_enable(i2c_get_clientdata(gt_client), true);
+
+		if (ts->pdata->esd_protect)
+			gtp_esd_on(ts);
+	} else if (17 == cmd_head.wr) {
+		if (cmd_head.data_len > DATA_LENGTH) {
+			dev_err(&gt_client->dev,
+				"Tool write failed data too long");
+			return -EPERM;
+		}
+		ret = copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH],
+				     &buff[CMD_HEAD_LENGTH],
+				     cmd_head.data_len);
+		if (ret) {
+			dev_dbg(&gt_client->dev, "copy_from_user failed.");
+			return -EPERM;
+		}
+		if (cmd_head.data[GTP_ADDR_LENGTH]) {
+			dev_info(&gt_client->dev, "gtp enter rawdiff.");
+			set_bit(RAW_DATA_MODE, &ts->flags);
+		} else {
+			clear_bit(RAW_DATA_MODE, &ts->flags);
+			dev_info(&gt_client->dev, "gtp leave rawdiff.");
+		}
+	} else if (19 == cmd_head.wr) {
+		/* add new command: reset guitar */
+		gtp_reset_guitar(gt_client, 20);
+	}
+#ifdef CONFIG_TOUCHSCREEN_GT9XX_UPDATE
+	else if (11 == cmd_head.wr) {/*Enter update mode!*/
+		if (FAIL == gup_enter_update_mode(gt_client))
+			return -EPERM;
+	} else if (13 == cmd_head.wr) {/*Leave update mode!*/
+		gup_leave_update_mode(gt_client);
+	} else if (15 == cmd_head.wr) {/*Update firmware!*/
+		show_len = 0;
+		total_len = 0;
+		if (cmd_head.data_len > DATA_LENGTH) {
+			dev_err(&gt_client->dev,
+				"Tool write failed data too long");
+			return -EPERM;
+		}
+		memset(cmd_head.data, 0, DATA_LENGTH);
+		ret = copy_from_user(cmd_head.data,
+				     &buff[CMD_HEAD_LENGTH],
+				     cmd_head.data_len);
+		if (ret) {
+			dev_dbg(&gt_client->dev, "copy_from_user failed.");
+			return -EPERM;
+		}
+
+		if (FAIL == gup_update_proc((void *)cmd_head.data))
+			return -EPERM;
+	}
+#endif
+
+	return len;
+}
+
+/*******************************************************
+ * Function:
+ *	Goodix tool read function.
+ * Input:
+ *	standard proc read function param.
+ * Output:
+ *	Return read length.
+ ********************************************************/
+ssize_t goodix_tool_read(struct file *file, char __user *page,
+			 size_t size, loff_t *ppos)
+{
+	s32 ret = 0;
+
+	if (*ppos) {
+		/* ADB call again
+		 * dev_dbg(&gt_client->dev, "[HEAD]wr: %d", cmd_head.wr);
+		 * dev_dbg(&gt_client->dev,
+		 * "[PARAM]size: %d, *ppos: %d", size, (int)*ppos);
+		 * dev_dbg(&gt_client->dev,
+		 * "[TOOL_READ]ADB call again, return it.");
+		 */
+		*ppos = 0;
+		return 0;
+	}
+
+	if (cmd_head.wr % 2) {
+		return -EPERM;
+	} else if (!cmd_head.wr) {
+		u16 len, data_len, loc, addr;
+
+		if (1 == cmd_head.flag) {
+			if (FAIL == comfirm()) {
+				dev_err(&gt_client->dev, "[READ]Comfirm fail!");
+				return -EPERM;
+			}
+		} else if (2 == cmd_head.flag) {
+			/*Need interrupt!*/
+		}
+
+		if (cmd_head.delay)
+			msleep(cmd_head.delay);
+
+		data_len = cmd_head.data_len;
+		addr = (cmd_head.addr[0] << 8) + cmd_head.addr[1];
+		loc = 0;
+
+		while (data_len > 0) {
+			len = data_len > DATA_LENGTH ? DATA_LENGTH : data_len;
+			cmd_head.data[0] = (addr >> 8) & 0xFF;
+			cmd_head.data[1] = (addr & 0xFF);
+			if (tool_i2c_read(cmd_head.data, len) <= 0) {
+				dev_err(&gt_client->dev, "[READ]Read data failed!");
+				return -EPERM;
+			}
+			ret = simple_read_from_buffer(&page[loc], size, ppos,
+					&cmd_head.data[GTP_ADDR_LENGTH], len);
+			if (ret < 0)
+				return ret;
+			loc += len;
+			addr += len;
+			data_len -= len;
+		}
+		return cmd_head.data_len;
+	} else if (2 == cmd_head.wr) {
+		ret = simple_read_from_buffer(page, size, ppos,
+					      IC_TYPE, sizeof(IC_TYPE));
+		return ret;
+	}
+#ifdef CONFIG_TOUCHSCREEN_GT9XX_UPDATE
+	else if (4 == cmd_head.wr) {
+		u8 progress_buf[4];
+
+		progress_buf[0] = show_len >> 8;
+		progress_buf[1] = show_len & 0xff;
+		progress_buf[2] = total_len >> 8;
+		progress_buf[3] = total_len & 0xff;
+
+		ret = simple_read_from_buffer(page, size, ppos,
+					      progress_buf, 4);
+		return ret;
+	}
+#endif
+	else if (6 == cmd_head.wr) {
+		/*Read error code!*/
+	} else if (8 == cmd_head.wr) {	/*Read driver version*/
+		ret = simple_read_from_buffer(page, size, ppos,
+					      GTP_DRIVER_VERSION,
+					      strlen(GTP_DRIVER_VERSION));
+		return ret;
+	}
+
+	return -EPERM;
+}
diff --git a/drivers/input/touchscreen/goodix_gt9xx/gt9xx.c b/drivers/input/touchscreen/goodix_gt9xx/gt9xx.c
new file mode 100644
index 000000000..2fe78f0ae
--- /dev/null
+++ b/drivers/input/touchscreen/goodix_gt9xx/gt9xx.c
@@ -0,0 +1,2567 @@
+/*
+ * Goodix GT9xx touchscreen driver
+ *
+ * Copyright  (C)  2016 - 2017 Goodix. Ltd.
+ *
+ * Copyright 2022 Panasonic Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 2.8.0.1
+ * Release Date: 2017/11/24
+ */
+
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/input/mt.h>
+#include "gt9xx.h"
+
+#define GOODIX_COORDS_ARR_SIZE	4
+#define PROP_NAME_SIZE		24
+#define I2C_MAX_TRANSFER_SIZE   255
+#define GTP_PEN_BUTTON1		BTN_STYLUS
+#define GTP_PEN_BUTTON2		BTN_STYLUS2
+
+static const char *goodix_ts_name = "goodix-ts";
+static const char *goodix_input_phys = "input/ts";
+struct i2c_client *i2c_connect_client;
+static struct proc_dir_entry *gtp_config_proc;
+
+enum doze {
+	DOZE_DISABLED = 0,
+	DOZE_ENABLED = 1,
+	DOZE_WAKEUP = 2,
+};
+
+static enum doze doze_status = DOZE_DISABLED;
+
+static int gtp_i2c_test(struct i2c_client *client);
+static int gtp_enter_doze(struct goodix_ts_data *ts);
+
+static int gtp_unregister_powermanager(struct goodix_ts_data *ts);
+static int gtp_register_powermanager(struct goodix_ts_data *ts);
+
+static int gtp_esd_init(struct goodix_ts_data *ts);
+static void gtp_esd_check_func(struct work_struct *);
+static int gtp_init_ext_watchdog(struct i2c_client *client);
+
+/*
+ * return: 2 - ok, < 0 - i2c transfer error
+ */
+int gtp_i2c_read(struct i2c_client *client, u8 *buf, int len)
+{
+	unsigned int transfer_length = 0;
+	unsigned int pos = 0, address = (buf[0] << 8) + buf[1];
+	unsigned char get_buf[64], addr_buf[2];
+	int retry, r = 2;
+	struct i2c_msg msgs[] = {
+		{
+			.addr = client->addr,
+			.flags = !I2C_M_RD,
+			.buf = &addr_buf[0],
+			.len = GTP_ADDR_LENGTH,
+		}, {
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+		}
+	};
+
+	len -= GTP_ADDR_LENGTH;
+	if (likely(len < sizeof(get_buf))) {
+		/* code optimize, use stack memory */
+		msgs[1].buf = &get_buf[0];
+	} else {
+		msgs[1].buf = kzalloc(len > I2C_MAX_TRANSFER_SIZE
+				? I2C_MAX_TRANSFER_SIZE : len, GFP_KERNEL);
+		if (!msgs[1].buf)
+			return -ENOMEM;
+	}
+
+	while (pos != len) {
+		if (unlikely(len - pos > I2C_MAX_TRANSFER_SIZE))
+			transfer_length = I2C_MAX_TRANSFER_SIZE;
+		else
+			transfer_length = len - pos;
+		msgs[0].buf[0] = (address >> 8) & 0xFF;
+		msgs[0].buf[1] = address & 0xFF;
+		msgs[1].len = transfer_length;
+		for (retry = 0; retry < RETRY_MAX_TIMES; retry++) {
+			if (likely(i2c_transfer(client->adapter, msgs, 2) == 2)) {
+				memcpy(&buf[2 + pos], msgs[1].buf, transfer_length);
+				pos += transfer_length;
+				address += transfer_length;
+				break;
+			}
+			dev_dbg(&client->dev, "I2c read retry[%d]:0x%x\n",
+				retry + 1, address);
+			usleep_range(2000, 2100);
+		}
+		if (unlikely(retry == RETRY_MAX_TIMES)) {
+			dev_err(&client->dev,
+				"I2c read failed,dev:%02x,reg:%04x,size:%u\n",
+				client->addr, address, len);
+			r = -EAGAIN;
+			goto read_exit;
+		}
+	}
+read_exit:
+	if (len >= sizeof(get_buf))
+		kfree(msgs[1].buf);
+	return r;
+}
+
+/*******************************************************
+ * Function:
+ *	Write data to the i2c slave device.
+ * Input:
+ *	client: i2c device.
+ *	buf[0~1]: write start address.
+ *	buf[2~len-1]: data buffer
+ *	len: GTP_ADDR_LENGTH + write bytes count
+ * Output:
+ *	numbers of i2c_msgs to transfer:
+ *		1: succeed, otherwise: failed
+ *********************************************************/
+int gtp_i2c_write(struct i2c_client *client, u8 *buf, int len)
+
+{
+	unsigned int pos = 0, transfer_length = 0;
+	unsigned int address = (buf[0] << 8) + buf[1];
+	unsigned char put_buf[64];
+	int retry, r = 1;
+	struct i2c_msg msg = {
+			.addr = client->addr,
+			.flags = !I2C_M_RD,
+	};
+
+	if (likely(len < sizeof(put_buf))) {
+		/* code optimize,use stack memory*/
+		msg.buf = &put_buf[0];
+	} else {
+		msg.buf = kmalloc(len > I2C_MAX_TRANSFER_SIZE
+				  ? I2C_MAX_TRANSFER_SIZE : len, GFP_KERNEL);
+		if (!msg.buf)
+			return -ENOMEM;
+	}
+
+	len -= GTP_ADDR_LENGTH;
+	while (pos != len) {
+		if (unlikely(len - pos > I2C_MAX_TRANSFER_SIZE - GTP_ADDR_LENGTH))
+			transfer_length = I2C_MAX_TRANSFER_SIZE - GTP_ADDR_LENGTH;
+		else
+			transfer_length = len - pos;
+		msg.buf[0] = (unsigned char)((address >> 8) & 0xFF);
+		msg.buf[1] = (unsigned char)(address & 0xFF);
+		msg.len = transfer_length + 2;
+		memcpy(&msg.buf[2], &buf[2 + pos], transfer_length);
+		for (retry = 0; retry < RETRY_MAX_TIMES; retry++) {
+			if (likely(i2c_transfer(client->adapter, &msg, 1) == 1)) {
+				pos += transfer_length;
+				address += transfer_length;
+				break;
+			}
+			dev_dbg(&client->dev, "I2C write retry[%d]\n", retry + 1);
+			usleep_range(2000, 2100);
+		}
+		if (unlikely(retry == RETRY_MAX_TIMES)) {
+			dev_err(&client->dev,
+				"I2c write failed,dev:%02x,reg:%04x,size:%u\n",
+				client->addr, address, len);
+			r = -EAGAIN;
+			goto write_exit;
+		}
+	}
+write_exit:
+	if (len + GTP_ADDR_LENGTH >= sizeof(put_buf))
+		kfree(msg.buf);
+	return r;
+}
+
+/*******************************************************
+ * Function:
+ *	i2c read twice, compare the results
+ * Input:
+ *	client:	i2c device
+ *	addr: operate address
+ *	rxbuf: read data to store, if compare successful
+ *	len: bytes to read
+ * Output:
+ *	FAIL: read failed
+ *	SUCCESS: read successful
+ *********************************************************/
+s32 gtp_i2c_read_dbl_check(struct i2c_client *client,
+			   u16 addr, u8 *rxbuf, int len)
+{
+	u8 buf[16] = {0};
+	u8 confirm_buf[16] = {0};
+	u8 retry = 0;
+
+	if (len + 2 > sizeof(buf)) {
+		dev_warn(&client->dev,
+			 "%s, only support length less then %zu\n",
+			 __func__, sizeof(buf) - 2);
+		return FAIL;
+	}
+	while (retry++ < 3) {
+		memset(buf, 0xAA, 16);
+		buf[0] = (u8)(addr >> 8);
+		buf[1] = (u8)(addr & 0xFF);
+		gtp_i2c_read(client, buf, len + 2);
+
+		memset(confirm_buf, 0xAB, 16);
+		confirm_buf[0] = (u8)(addr >> 8);
+		confirm_buf[1] = (u8)(addr & 0xFF);
+		gtp_i2c_read(client, confirm_buf, len + 2);
+
+		if (!memcmp(buf, confirm_buf, len + 2)) {
+			memcpy(rxbuf, confirm_buf + 2, len);
+			return SUCCESS;
+		}
+	}
+	dev_err(&client->dev,
+		"I2C read 0x%04X, %d bytes, double check failed!\n",
+		addr, len);
+
+	return FAIL;
+}
+
+/*******************************************************
+ * Function:
+ *      Send config.
+ * Input:
+ *      client: i2c device.
+ * Output:
+ *      result of i2c write operation.
+ *              1: succeed, otherwise
+ *              0: Not executed
+ *		< 0: failed
+ *********************************************************/
+s32 gtp_send_cfg(struct i2c_client *client)
+{
+	s32 ret, i;
+	u8 check_sum;
+	s32 retry = 0;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+	struct goodix_config_data *cfg = &ts->pdata->config;
+
+	if (!cfg->length || !ts->pdata->driver_send_cfg) {
+		dev_info(&ts->client->dev,
+			 "No config data or error occurred in panel_init\n");
+		return 0;
+	}
+
+	check_sum = 0;
+	for (i = GTP_ADDR_LENGTH; i < cfg->length; i++)
+		check_sum += cfg->data[i];
+	cfg->data[cfg->length] = (~check_sum) + 1;
+
+	dev_info(&ts->client->dev, "Driver send config\n");
+	for (retry = 0; retry < RETRY_MAX_TIMES; retry++) {
+		ret = gtp_i2c_write(client, cfg->data,
+			GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
+		if (ret > 0)
+			break;
+	}
+
+	return ret;
+}
+
+/*******************************************************
+ * Function:
+ *	Control enable or disable of work thread.
+ * Input:
+ *      ts: goodix i2c_client private data
+ *	enable: enable var.
+ *********************************************************/
+void gtp_work_control_enable(struct goodix_ts_data *ts, bool enable)
+{
+	if (enable) {
+		set_bit(WORK_THREAD_ENABLED, &ts->flags);
+		dev_dbg(&ts->client->dev, "Input report thread enabled!\n");
+	} else {
+		clear_bit(WORK_THREAD_ENABLED, &ts->flags);
+		dev_dbg(&ts->client->dev, "Input report thread disabled!\n");
+	}
+}
+
+static int gtp_gesture_handler(struct goodix_ts_data *ts)
+{
+	u8 doze_buf[3] = {GTP_REG_DOZE_BUF >> 8, GTP_REG_DOZE_BUF & 0xFF};
+	int ret;
+
+	ret = gtp_i2c_read(ts->client, doze_buf, 3);
+	if (ret < 0) {
+		dev_err(&ts->client->dev, "Failed read doze buf");
+		return -EINVAL;
+	}
+
+	dev_dbg(&ts->client->dev, "0x814B = 0x%02X", doze_buf[2]);
+	if ((doze_buf[2] == 'a') || (doze_buf[2] == 'b') ||
+	    (doze_buf[2] == 'c') || (doze_buf[2] == 'd') ||
+	    (doze_buf[2] == 'e') || (doze_buf[2] == 'g') ||
+	    (doze_buf[2] == 'h') || (doze_buf[2] == 'm') ||
+	    (doze_buf[2] == 'o') || (doze_buf[2] == 'q') ||
+	    (doze_buf[2] == 's') || (doze_buf[2] == 'v') ||
+	    (doze_buf[2] == 'w') || (doze_buf[2] == 'y') ||
+	    (doze_buf[2] == 'z') || (doze_buf[2] == 0x5E) ||
+	    (doze_buf[2] == 0xAA) || (doze_buf[2] == 0xAB) ||
+	    (doze_buf[2] == 0xBA) || (doze_buf[2] == 0xBB) ||
+	    (doze_buf[2] == 0xCC)) {
+		doze_status = DOZE_WAKEUP;
+		input_report_key(ts->input_dev, KEY_POWER, 1);
+		input_sync(ts->input_dev);
+		input_report_key(ts->input_dev, KEY_POWER, 0);
+		input_sync(ts->input_dev);
+		/*  clear 0x814B */
+		doze_buf[2] = 0x00;
+		gtp_i2c_write(ts->client, doze_buf, 3);
+	} else {
+		/*  clear 0x814B */
+		doze_buf[2] = 0x00;
+		gtp_i2c_write(ts->client, doze_buf, 3);
+		gtp_enter_doze(ts);
+	}
+	return 0;
+}
+
+/*
+ * return touch state register value
+ * pen event id fixed with 9 and set tool type TOOL_PEN
+ *
+ */
+static u8 gtp_get_points(struct goodix_ts_data *ts,
+			 struct goodix_point_t *points,
+			 u8 *key_value)
+{
+	int ret;
+	int i;
+	u8 *coor_data = NULL;
+	u8 finger_state = 0;
+	u8 touch_num = 0;
+	u8 end_cmd[3] = { GTP_READ_COOR_ADDR >> 8,
+			  GTP_READ_COOR_ADDR & 0xFF, 0 };
+	u8 point_data[2 + 1 + 8 * GTP_MAX_TOUCH_ID + 1] = {
+			GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF };
+
+	ret = gtp_i2c_read(ts->client, point_data, 12);
+	if (ret < 0) {
+		dev_err(&ts->client->dev,
+			"I2C transfer error. errno:%d\n ", ret);
+		return 0;
+	}
+	finger_state = point_data[GTP_ADDR_LENGTH];
+	if (finger_state == 0x00)
+		return 0;
+
+	touch_num = finger_state & 0x0f;
+	if ((finger_state & MASK_BIT_8) == 0 ||
+	    touch_num > ts->pdata->max_touch_id) {
+		dev_err(&ts->client->dev,
+			"Invalid touch state: 0x%x", finger_state);
+		finger_state = 0;
+		goto exit_get_point;
+	}
+
+	if (touch_num > 1) {
+		u8 buf[8 * GTP_MAX_TOUCH_ID] = {
+					  (GTP_READ_COOR_ADDR + 10) >> 8,
+					  (GTP_READ_COOR_ADDR + 10) & 0xff };
+
+		ret = gtp_i2c_read(ts->client, buf, 2 + 8 * (touch_num - 1));
+		if (ret < 0) {
+			dev_err(&ts->client->dev, "I2C error. %d\n", ret);
+			finger_state = 0;
+			goto exit_get_point;
+		}
+		memcpy(&point_data[12], &buf[2], 8 * (touch_num - 1));
+	}
+
+	/* panel have touch key */
+	/* 0x20_UPKEY 0X10_DOWNKEY 0X40_ALLKEYDOWN */
+	*key_value = point_data[3 + 8 * touch_num];
+
+	memset(points, 0, sizeof(*points) * GTP_MAX_TOUCH_ID);
+	for (i = 0; i < touch_num; i++) {
+		coor_data = &point_data[i * 8 + 3];
+		points[i].id = coor_data[0];
+		points[i].x = coor_data[1] | (coor_data[2] << 8);
+		points[i].y = coor_data[3] | (coor_data[4] << 8);
+		points[i].w = coor_data[5] | (coor_data[6] << 8);
+		/* if pen hover points[].p must set to zero */
+		points[i].p = coor_data[5] | (coor_data[6] << 8);
+
+		if (ts->pdata->swap_x2y)
+			GTP_SWAP(points[i].x, points[i].y);
+
+		dev_dbg(&ts->client->dev, "[%d][%d %d %d]\n",
+			points[i].id, points[i].x, points[i].y, points[i].p);
+
+		/* pen device coordinate */
+		if (points[i].id & 0x80) {
+			points[i].tool_type = GTP_TOOL_PEN;
+			points[i].id = 10;
+			if (ts->pdata->pen_suppress_finger) {
+				points[0] = points[i];
+				memset(++points, 0, sizeof(*points) * (GTP_MAX_TOUCH_ID - 1));
+				finger_state &= 0xf0;
+				finger_state |= 0x01;
+				break;
+			}
+		} else {
+			points[i].tool_type = GTP_TOOL_FINGER;
+		}
+	}
+
+exit_get_point:
+	if (!test_bit(RAW_DATA_MODE, &ts->flags)) {
+		ret = gtp_i2c_write(ts->client, end_cmd, 3);
+		if (ret < 0)
+			dev_info(&ts->client->dev, "I2C write end_cmd error!");
+	}
+	return finger_state;
+}
+
+static void gtp_type_a_report(struct goodix_ts_data *ts, u8 touch_num,
+			      struct goodix_point_t *points)
+{
+	int i;
+	u16 cur_touch = 0;
+	static u16 pre_touch;
+	static u8 pre_pen_id;
+
+	if (touch_num)
+		input_report_key(ts->input_dev, BTN_TOUCH, 1);
+
+	for (i = 0; i < ts->pdata->max_touch_id; i++) {
+		if (touch_num && i == points->id) {
+			input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, points->id);
+
+			if (points->tool_type == GTP_TOOL_PEN) {
+				input_report_key(ts->input_dev, BTN_TOOL_PEN, true);
+				pre_pen_id = points->id;
+			} else {
+				input_report_key(ts->input_dev, BTN_TOOL_FINGER, true);
+			}
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_X,
+					 points->x);
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y,
+					 points->y);
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,
+					 points->w);
+			input_report_abs(ts->input_dev, ABS_MT_PRESSURE,
+					 points->p);
+			input_mt_sync(ts->input_dev);
+
+			cur_touch |= 0x01 << points->id;
+			points++;
+		} else if (pre_touch & 0x01 << i) {
+			if (pre_pen_id == i) {
+				input_report_key(ts->input_dev, BTN_TOOL_PEN, false);
+				/* valid id will < 10, so id to 0xff to indicate a invalid state */
+				pre_pen_id = 0xff;
+			} else {
+				input_report_key(ts->input_dev, BTN_TOOL_FINGER, false);
+			}
+		}
+	}
+
+	pre_touch = cur_touch;
+	if (!pre_touch) {
+		input_mt_sync(ts->input_dev);
+		input_report_key(ts->input_dev, BTN_TOUCH, 0);
+	}
+	input_sync(ts->input_dev);
+}
+
+static void gtp_mt_slot_report(struct goodix_ts_data *ts, u8 touch_num,
+			       struct goodix_point_t *points)
+{
+	int i;
+	u16 cur_touch = 0;
+	static u16 pre_touch;
+	static u8 pre_pen_id;
+
+	for (i = 0; i < ts->pdata->max_touch_id; i++) {
+		if (touch_num && i == points->id) {
+			input_mt_slot(ts->input_dev, points->id);
+
+			if (points->tool_type == GTP_TOOL_PEN) {
+				input_mt_report_slot_state(ts->input_dev,
+							   MT_TOOL_PEN, true);
+				pre_pen_id = points->id;
+			} else {
+				input_mt_report_slot_state(ts->input_dev,
+							   MT_TOOL_FINGER, true);
+			}
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_X,
+					 points->x);
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y,
+					 points->y);
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,
+					 points->w);
+			input_report_abs(ts->input_dev, ABS_MT_PRESSURE,
+					 points->p);
+
+			cur_touch |= 0x01 << points->id;
+			points++;
+		} else if (pre_touch & 0x01 << i) {
+			input_mt_slot(ts->input_dev, i);
+			if (pre_pen_id == i) {
+				input_mt_report_slot_state(ts->input_dev,
+							   MT_TOOL_PEN, false);
+				/* valid id will < 10, so set id to 0xff to
+				 * indicate a invalid state
+				 */
+				pre_pen_id = 0xff;
+			} else {
+				input_mt_report_slot_state(ts->input_dev,
+							   MT_TOOL_FINGER, false);
+			}
+		}
+	}
+
+	pre_touch = cur_touch;
+	/* report BTN_TOUCH event */
+	input_mt_sync_frame(ts->input_dev);
+	input_sync(ts->input_dev);
+}
+
+/*******************************************************
+ * Function:
+ *	Goodix touchscreen sensor report function
+ * Input:
+ *	ts: goodix tp private data
+ * Output:
+ *	None.
+ *********************************************************/
+static void gtp_work_func(struct goodix_ts_data *ts)
+{
+	u8 point_state = 0;
+	u8 key_value = 0;
+	s32 i = 0;
+	s32 ret = -1;
+	static u8 pre_key;
+	struct goodix_point_t points[GTP_MAX_TOUCH_ID];
+
+	if (test_bit(PANEL_RESETTING, &ts->flags))
+		return;
+	if (!test_bit(WORK_THREAD_ENABLED, &ts->flags))
+		return;
+
+	/* gesture event */
+	if (ts->pdata->slide_wakeup && test_bit(DOZE_MODE, &ts->flags)) {
+		ret =  gtp_gesture_handler(ts);
+		if (ret)
+			dev_err(&ts->client->dev,
+				"Failed handler gesture event %d\n", ret);
+		return;
+	}
+
+	point_state = gtp_get_points(ts, points, &key_value);
+	if (!point_state) {
+		dev_dbg(&ts->client->dev, "Invalid finger points\n");
+		return;
+	}
+
+	/* touch key event */
+	if (key_value & 0xf0 || pre_key & 0xf0) {
+		/* pen button */
+		switch (key_value) {
+		case 0x40:
+			input_report_key(ts->input_dev, GTP_PEN_BUTTON1, 1);
+			input_report_key(ts->input_dev, GTP_PEN_BUTTON2, 1);
+			break;
+		case 0x10:
+			input_report_key(ts->input_dev, GTP_PEN_BUTTON1, 1);
+			input_report_key(ts->input_dev, GTP_PEN_BUTTON2, 0);
+			dev_dbg(&ts->client->dev, "pen button1 down\n");
+			break;
+		case 0x20:
+			input_report_key(ts->input_dev, GTP_PEN_BUTTON1, 0);
+			input_report_key(ts->input_dev, GTP_PEN_BUTTON2, 1);
+			break;
+		default:
+			input_report_key(ts->input_dev, GTP_PEN_BUTTON1, 0);
+			input_report_key(ts->input_dev, GTP_PEN_BUTTON2, 0);
+			dev_dbg(&ts->client->dev, "button1 up\n");
+			break;
+		}
+		input_sync(ts->input_dev);
+		pre_key = key_value;
+	} else if (key_value & 0x0f || pre_key & 0x0f) {
+		/* panel key */
+		for (i = 0; i < ts->pdata->key_nums; i++) {
+			if ((pre_key | key_value) & (0x01 << i))
+				input_report_key(ts->input_dev,
+						 ts->pdata->key_map[i],
+						 key_value & (0x01 << i));
+		}
+		input_sync(ts->input_dev);
+		pre_key = key_value;
+	}
+
+	if (!ts->pdata->type_a_report)
+		gtp_mt_slot_report(ts, point_state & 0x0f, points);
+	else
+		gtp_type_a_report(ts, point_state & 0x0f, points);
+}
+
+/*******************************************************
+ * Function:
+ *	Timer interrupt service routine for polling mode.
+ * Input:
+ *	timer: timer struct pointer
+ * Output:
+ *	Timer work mode.
+ * HRTIMER_NORESTART:
+ *	no restart mode
+ *********************************************************/
+static enum hrtimer_restart gtp_timer_handler(struct hrtimer *timer)
+{
+	struct goodix_ts_data *ts =
+		container_of(timer, struct goodix_ts_data, timer);
+
+	gtp_work_func(ts);
+	hrtimer_start(&ts->timer, ktime_set(0, (GTP_POLL_TIME + 6) * 1000000),
+		      HRTIMER_MODE_REL);
+
+	return HRTIMER_NORESTART;
+}
+
+static irqreturn_t gtp_irq_handler(int irq, void *dev_id)
+{
+	struct goodix_ts_data *ts = dev_id;
+
+	gtp_work_func(ts);
+	return IRQ_HANDLED;
+}
+
+void gtp_int_output(struct goodix_ts_data *ts, int level)
+{
+	if (!ts->pdata->int_sync)
+		return;
+
+	if (level == 0) {
+		if (ts->pinctrl.pinctrl)
+			pinctrl_select_state(ts->pinctrl.pinctrl,
+					     ts->pinctrl.int_out_low);
+		else if (gpio_is_valid(ts->pdata->irq_gpio))
+			gpio_direction_output(ts->pdata->irq_gpio, 0);
+		else
+			dev_err(&ts->client->dev,
+				"Failed set int pin output low\n");
+	} else {
+		if (ts->pinctrl.pinctrl)
+			pinctrl_select_state(ts->pinctrl.pinctrl,
+					     ts->pinctrl.int_out_high);
+		else if (gpio_is_valid(ts->pdata->irq_gpio))
+			gpio_direction_output(ts->pdata->irq_gpio, 1);
+		else
+			dev_err(&ts->client->dev,
+				"Failed set int pin output high\n");
+	}
+}
+
+void gtp_int_sync(struct goodix_ts_data *ts, s32 ms)
+{
+	if (!ts->pdata->int_sync)
+		return;
+
+	if (ts->pinctrl.pinctrl) {
+		gtp_int_output(ts, 0);
+		msleep(ms);
+		pinctrl_select_state(ts->pinctrl.pinctrl,
+				     ts->pinctrl.int_input);
+	} else if (gpio_is_valid(ts->pdata->irq_gpio)) {
+		gpio_direction_output(ts->pdata->irq_gpio, 0);
+		msleep(ms);
+		gpio_direction_input(ts->pdata->irq_gpio);
+	} else {
+		dev_err(&ts->client->dev, "Failed sync int pin\n");
+	}
+}
+
+/*******************************************************
+ * Function:
+ *	Reset chip. Control the reset pin and int-pin(if
+ *	defined),
+ * Input:
+ *	client:	i2c device.
+ *	ms: reset time in millisecond
+ * Output:
+ *	None.
+ *******************************************************/
+void gtp_reset_guitar(struct i2c_client *client, s32 ms)
+{
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	dev_info(&client->dev, "Guitar reset");
+	set_bit(PANEL_RESETTING, &ts->flags);
+	if (!gpio_is_valid(ts->pdata->rst_gpio)) {
+		dev_warn(&client->dev, "reset failed no valid reset gpio");
+		return;
+	}
+
+	gpio_direction_output(ts->pdata->rst_gpio, 0);
+	usleep_range(ms * 1000, ms * 1000 + 100);	/*  T2: > 10ms */
+
+	gtp_int_output(ts, client->addr == 0x14);
+
+	usleep_range(2000, 3000);		/*  T3: > 100us (2ms)*/
+	gpio_direction_output(ts->pdata->rst_gpio, 1);
+
+	usleep_range(6000, 7000);		/*  T4: > 5ms */
+	//gpio_direction_input(ts->pdata->rst_gpio);
+
+	gtp_int_sync(ts, 50);
+	if (ts->pdata->esd_protect)
+		gtp_init_ext_watchdog(client);
+
+	clear_bit(PANEL_RESETTING, &ts->flags);
+}
+
+/*******************************************************
+ * Function:
+ *	Enter doze mode for sliding wakeup.
+ * Input:
+ *	ts: goodix tp private data
+ * Output:
+ *	1: succeed, otherwise failed
+ *******************************************************/
+static int gtp_enter_doze(struct goodix_ts_data *ts)
+{
+	int ret = -1;
+	int retry = 0;
+	u8 i2c_control_buf[3] = { (u8)(GTP_REG_COMMAND >> 8),
+				  (u8)GTP_REG_COMMAND, 8 };
+
+	/*  resend doze command
+	 * if (test_and_set_bit(DOZE_MODE, &ts->flags)) {
+	 *	dev_info(&ts->client->dev, "Already in doze mode\n");
+	 *	return SUCCESS;
+	 * }
+	 */
+	set_bit(DOZE_MODE, &ts->flags);
+	dev_dbg(&ts->client->dev, "Entering gesture mode.");
+	while (retry++ < 5) {
+		i2c_control_buf[0] = (u8)(GTP_REG_COMMAND_CHECK >> 8);
+		i2c_control_buf[1] = (u8)GTP_REG_COMMAND_CHECK;
+		ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
+		if (ret < 0) {
+			dev_dbg(&ts->client->dev,
+				"failed to set doze flag into 0x8046, %d\n",
+				retry);
+			continue;
+		}
+		i2c_control_buf[0] = (u8)(GTP_REG_COMMAND >> 8);
+		i2c_control_buf[1] = (u8)GTP_REG_COMMAND;
+		ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
+		if (ret > 0) {
+			dev_dbg(&ts->client->dev, "Gesture mode enabled\n");
+			return ret;
+		}
+		usleep_range(10000, 11000);
+	}
+
+	dev_err(&ts->client->dev, "Failed enter doze mode\n");
+	clear_bit(DOZE_MODE, &ts->flags);
+	return ret;
+}
+
+static s8 gtp_enter_sleep(struct goodix_ts_data *ts)
+{
+	s8 ret = -1;
+	s8 retry = 0;
+	u8 i2c_control_buf[3] = { (u8)(GTP_REG_COMMAND >> 8),
+				  (u8)GTP_REG_COMMAND, 5 };
+
+	gtp_int_output(ts, 0);
+	usleep_range(5000, 6000);
+
+	while (retry++ < 5) {
+		ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
+		if (ret > 0) {
+			dev_info(&ts->client->dev, "Enter sleep mode\n");
+
+			return ret;
+		}
+		usleep_range(10000, 11000);
+	}
+	dev_err(&ts->client->dev, "Failed send sleep cmd\n");
+
+	return ret;
+}
+
+static int gtp_wakeup_sleep(struct goodix_ts_data *ts)
+{
+	u8 retry = 0;
+	int ret = -1;
+
+	while (retry++ < 10) {
+		gtp_int_output(ts, 1);
+		usleep_range(5000, 6000);
+
+		ret = gtp_i2c_test(ts->client);
+		if (!ret) {
+			dev_dbg(&ts->client->dev, "Success wakeup sleep\n");
+
+			gtp_int_sync(ts, 25);
+			if (ts->pdata->esd_protect)
+				gtp_init_ext_watchdog(ts->client);
+
+			return ret;
+		}
+		gtp_reset_guitar(ts->client, 20);
+	}
+
+	dev_err(&ts->client->dev, "Failed wakeup from sleep mode\n");
+	return -EINVAL;
+}
+
+static int gtp_find_valid_cfg_data(struct goodix_ts_data *ts)
+{
+	int ret = -1;
+	u8 sensor_id = 0;
+	struct goodix_config_data *cfg = &ts->pdata->config;
+
+	/* if defined CONFIG_OF, parse config data from dtsi
+	 * else parse config data form header file.
+	 */
+	cfg->length = 0;
+
+#ifndef	CONFIG_OF
+	u8 cfg_info_group0[] = CTP_CFG_GROUP0;
+	u8 cfg_info_group1[] = CTP_CFG_GROUP1;
+	u8 cfg_info_group2[] = CTP_CFG_GROUP2;
+	u8 cfg_info_group3[] = CTP_CFG_GROUP3;
+	u8 cfg_info_group4[] = CTP_CFG_GROUP4;
+	u8 cfg_info_group5[] = CTP_CFG_GROUP5;
+
+	u8 *send_cfg_buf[] = { cfg_info_group0, cfg_info_group1,
+			       cfg_info_group2, cfg_info_group3,
+			       cfg_info_group4, cfg_info_group5 };
+	u8 cfg_info_len[] = { CFG_GROUP_LEN(cfg_info_group0),
+			      CFG_GROUP_LEN(cfg_info_group1),
+			      CFG_GROUP_LEN(cfg_info_group2),
+			      CFG_GROUP_LEN(cfg_info_group3),
+			      CFG_GROUP_LEN(cfg_info_group4),
+			      CFG_GROUP_LEN(cfg_info_group5)};
+
+	dev_dbg(&ts->client->dev,
+		"Config Groups\' Lengths: %d, %d, %d, %d, %d, %d",
+		cfg_info_len[0], cfg_info_len[1], cfg_info_len[2],
+		cfg_info_len[3], cfg_info_len[4], cfg_info_len[5]);
+#endif
+
+	/* read sensor id */
+	ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_SENSOR_ID,
+				     &sensor_id, 1);
+	if (SUCCESS != ret || sensor_id >= 0x06) {
+		dev_err(&ts->client->dev,
+			"Failed get valid sensor_id(0x%02X), No Config Sent\n",
+			sensor_id);
+		return -EINVAL;
+	}
+
+	dev_dbg(&ts->client->dev, "Sensor_ID: %d", sensor_id);
+	/* parse config data */
+#ifdef CONFIG_OF
+	dev_dbg(&ts->client->dev, "Get config data from device tree\n");
+	ret = gtp_parse_dt_cfg(&ts->client->dev,
+			       &cfg->data[GTP_ADDR_LENGTH],
+			       &cfg->length, sensor_id);
+	if (ret < 0) {
+		dev_err(&ts->client->dev,
+			"Failed to parse config data form device tree\n");
+		cfg->length = 0;
+		return -EPERM;
+	}
+#else
+	dev_dbg(&ts->client->dev, "Get config data from header file\n");
+	if ((!cfg_info_len[1]) && (!cfg_info_len[2]) &&
+	    (!cfg_info_len[3]) && (!cfg_info_len[4]) &&
+	    (!cfg_info_len[5])) {
+		sensor_id = 0;
+	}
+	cfg->length = cfg_info_len[sensor_id];
+	memset(&cfg->data[GTP_ADDR_LENGTH], 0, GTP_CONFIG_MAX_LENGTH);
+	memcpy(&cfg->data[GTP_ADDR_LENGTH], send_cfg_buf[sensor_id],
+	       cfg->length);
+#endif
+
+	if (cfg->length < GTP_CONFIG_MIN_LENGTH) {
+		dev_err(&ts->client->dev,
+			"Failed get valid config data with sensor id %d\n",
+			sensor_id);
+		cfg->length = 0;
+		return -EPERM;
+	}
+
+	dev_info(&ts->client->dev, "Config group%d used,length: %d\n",
+		 sensor_id, cfg->length);
+
+	return 0;
+}
+
+/*******************************************************
+ * Function:
+ *	Get valid config data from dts or .h file.
+ *	Read firmware version info and judge firmware
+ *	working state
+ * Input:
+ *	ts: goodix private data
+ * Output:
+ *	Executive outcomes.
+ *		0: succeed, otherwise: failed
+ *******************************************************/
+static s32 gtp_init_panel(struct goodix_ts_data *ts)
+{
+	s32 ret = -1;
+	u8 opr_buf[16] = {0};
+	u8 drv_cfg_version = 0;
+	u8 flash_cfg_version = 0;
+	struct goodix_config_data *cfg = &ts->pdata->config;
+
+	if (!ts->pdata->driver_send_cfg) {
+		dev_info(&ts->client->dev, "Driver set not send config\n");
+		cfg->length = GTP_CONFIG_MAX_LENGTH;
+		ret = gtp_i2c_read(ts->client,
+				   cfg->data, cfg->length +
+				   GTP_ADDR_LENGTH);
+		if (ret < 0)
+			dev_err(&ts->client->dev, "Read origin Config Failed\n");
+
+		return 0;
+	}
+
+	gtp_find_valid_cfg_data(ts);
+
+	/* check firmware */
+	ret = gtp_i2c_read_dbl_check(ts->client, 0x41E4, opr_buf, 1);
+	if (SUCCESS == ret) {
+		if (opr_buf[0] != 0xBE) {
+			set_bit(FW_ERROR, &ts->flags);
+			dev_err(&ts->client->dev,
+				"Firmware error, no config sent!\n");
+			return -EINVAL;
+		}
+	}
+
+	ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CONFIG_DATA,
+				     &opr_buf[0], 1);
+	if (ret == SUCCESS) {
+		dev_dbg(&ts->client->dev,
+			"Config Version: %d; IC Config Version: %d\n",
+			cfg->data[GTP_ADDR_LENGTH], opr_buf[0]);
+		flash_cfg_version = opr_buf[0];
+		drv_cfg_version = cfg->data[GTP_ADDR_LENGTH];
+
+		if (flash_cfg_version < 90 &&
+		    flash_cfg_version > drv_cfg_version)
+			cfg->data[GTP_ADDR_LENGTH] = 0x00;
+	} else {
+		dev_err(&ts->client->dev,
+			"Failed to get ic config version!No config sent\n");
+		return -EPERM;
+	}
+
+	ret = gtp_send_cfg(ts->client);
+	if (ret < 0)
+		dev_err(&ts->client->dev, "Send config error\n");
+	else
+		usleep_range(10000, 11000); /* 10 ms */
+
+	/* restore config version */
+	cfg->data[GTP_ADDR_LENGTH] = drv_cfg_version;
+
+	return 0;
+}
+
+static ssize_t gtp_config_read_proc(struct file *file, char __user *page,
+				    size_t size, loff_t *ppos)
+{
+	int i, ret;
+	char *ptr;
+	size_t data_len = 0;
+	char temp_data[GTP_CONFIG_MAX_LENGTH + 2] = {
+					(u8)(GTP_REG_CONFIG_DATA >> 8),
+					(u8)GTP_REG_CONFIG_DATA };
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+	struct goodix_config_data *cfg = &ts->pdata->config;
+
+	ptr = kzalloc(4096, GFP_KERNEL);
+	if (!ptr) {
+		dev_err(&ts->client->dev, "Failed alloc memory for config\n");
+		return -ENOMEM;
+	}
+
+	data_len += snprintf(ptr + data_len, 4096 - data_len,
+			     "====init value====\n");
+	for (i = 0 ; i < GTP_CONFIG_MAX_LENGTH ; i++) {
+		data_len += snprintf(ptr + data_len, 4096 - data_len,
+				     "0x%02X ", cfg->data[i + 2]);
+
+		if (i % 8 == 7)
+			data_len += snprintf(ptr + data_len,
+					     4096 - data_len, "\n");
+	}
+	data_len += snprintf(ptr + data_len, 4096 - data_len, "\n");
+
+	data_len += snprintf(ptr + data_len, 4096 - data_len,
+			     "====real value====\n");
+	ret = gtp_i2c_read(i2c_connect_client, temp_data,
+			   GTP_CONFIG_MAX_LENGTH + 2);
+	if (ret < 0) {
+		data_len += snprintf(ptr + data_len, 4096 - data_len,
+				     "Failed read real config data\n");
+	} else {
+		for (i = 0; i < GTP_CONFIG_MAX_LENGTH; i++) {
+			data_len += snprintf(ptr + data_len, 4096 - data_len,
+					     "0x%02X ", temp_data[i + 2]);
+
+			if (i % 8 == 7)
+				data_len += snprintf(ptr + data_len,
+						     4096 - data_len, "\n");
+		}
+	}
+
+	data_len = simple_read_from_buffer(page, size, ppos, ptr, data_len);
+	kfree(ptr);
+	ptr = NULL;
+	return data_len;
+}
+
+static u8 ascii2hex(u8 a)
+{
+	s8 value = 0;
+
+	if (a >= '0' && a <= '9')
+		value = a - '0';
+	else if (a >= 'A' && a <= 'F')
+		value = a - 'A' + 0x0A;
+	else if (a >= 'a' && a <= 'f')
+		value = a - 'a' + 0x0A;
+	else
+		value = 0xff;
+
+	return value;
+}
+
+int gtp_ascii_to_array(const u8 *src_buf, int src_len, u8 *dst_buf)
+{
+	int i, ret;
+	int cfg_len = 0;
+	u8 high, low;
+
+	for (i = 0; i < src_len;) {
+		if (src_buf[i] == ' ' || src_buf[i] == '\r' ||
+		    src_buf[i] == '\n') {
+			i++;
+			continue;
+		}
+
+		if ((src_buf[i] == '0') && ((src_buf[i + 1] == 'x') ||
+					    (src_buf[i + 1] == 'X'))) {
+			high = ascii2hex(src_buf[i + 2]);
+			low = ascii2hex(src_buf[i + 3]);
+
+			if ((high == 0xFF) || (low == 0xFF)) {
+				ret = -1;
+				goto convert_failed;
+			}
+
+			if (cfg_len < GTP_CONFIG_MAX_LENGTH) {
+				dst_buf[cfg_len++] = (high << 4) + low;
+				i += 5;
+			} else {
+				ret = -2;
+				goto convert_failed;
+			}
+		} else {
+			ret = -3;
+			goto convert_failed;
+		}
+	}
+	return cfg_len;
+
+convert_failed:
+	return ret;
+}
+
+static ssize_t gtp_config_write_proc(struct file *filp,
+				     const char __user *buffer,
+				     size_t count, loff_t *off)
+{
+	u8 *temp_buf;
+	u8 *file_config;
+	int file_cfg_len;
+	s32 ret = 0, i;
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+	dev_dbg(&ts->client->dev, "write count %zu\n", count);
+
+	if (count > PAGE_SIZE) {
+		dev_err(&ts->client->dev, "config to long %zu\n", count);
+		return -EFAULT;
+	}
+
+	temp_buf = kzalloc(count, GFP_KERNEL);
+	if (!temp_buf) {
+		dev_err(&ts->client->dev, "failed alloc temp memory");
+		return -ENOMEM;
+	}
+
+	file_config = kzalloc(GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH,
+			      GFP_KERNEL);
+	if (!file_config) {
+		dev_err(&ts->client->dev, "failed alloc config memory");
+		kfree(temp_buf);
+		return -ENOMEM;
+	}
+	file_config[0] = GTP_REG_CONFIG_DATA >> 8;
+	file_config[1] = GTP_REG_CONFIG_DATA & 0xff;
+
+	if (copy_from_user(temp_buf, buffer, count)) {
+		dev_err(&ts->client->dev, "Failed copy from user\n");
+		ret = -EFAULT;
+		goto send_cfg_err;
+	}
+
+	file_cfg_len = gtp_ascii_to_array(temp_buf, (int)count,
+					  &file_config[GTP_ADDR_LENGTH]);
+	if (file_cfg_len < 0) {
+		dev_err(&ts->client->dev, "failed covert ascii to hex");
+		ret = -EFAULT;
+		goto send_cfg_err;
+	}
+
+	GTP_DEBUG_ARRAY(file_config + GTP_ADDR_LENGTH, file_cfg_len);
+
+	i = 0;
+	while (i++ < 5) {
+		ret = gtp_i2c_write(ts->client, file_config, file_cfg_len + 2);
+		if (ret > 0) {
+			dev_info(&ts->client->dev, "Send config SUCCESS.");
+			break;
+		}
+		dev_err(&ts->client->dev, "Send config i2c error.");
+		ret = -EFAULT;
+		goto send_cfg_err;
+	}
+
+	ret = count;
+send_cfg_err:
+	kfree(temp_buf);
+	kfree(file_config);
+	return ret;
+}
+
+static const struct proc_ops config_proc_ops = {
+	.proc_read = gtp_config_read_proc,
+	.proc_write = gtp_config_write_proc,
+};
+
+static ssize_t gtp_workmode_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	size_t data_len = 0;
+	struct goodix_ts_data *data = dev_get_drvdata(dev);
+
+	if (test_bit(DOZE_MODE, &data->flags))
+		data_len = scnprintf(buf, PAGE_SIZE, "%s\n",
+				     "doze_mode");
+	else if (test_bit(SLEEP_MODE, &data->flags))
+		data_len = scnprintf(buf, PAGE_SIZE, "%s\n",
+				     "sleep_mode");
+	else
+		data_len = scnprintf(buf, PAGE_SIZE, "%s\n",
+				     "normal_mode");
+
+	return data_len;
+}
+static DEVICE_ATTR(workmode, 0444, gtp_workmode_show, NULL);
+
+#ifdef CONFIG_TOUCHSCREEN_GT9XX_UPDATE
+#define FW_NAME_MAX_LEN	80
+static ssize_t gtp_dofwupdate_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct goodix_ts_data *ts = dev_get_drvdata(dev);
+	char update_file_name[FW_NAME_MAX_LEN];
+	int retval;
+
+	if (count > FW_NAME_MAX_LEN) {
+		dev_info(&ts->client->dev, "FW filename is too long\n");
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	strlcpy(update_file_name, buf, count);
+
+	ts->force_update = true;
+	retval = gup_update_proc(update_file_name);
+	if (retval == FAIL)
+		dev_err(&ts->client->dev, "Fail to update GTP firmware.\n");
+	else
+		dev_info(&ts->client->dev, "Update success\n");
+
+	return count;
+
+exit:
+	return retval;
+}
+static DEVICE_ATTR(dofwupdate, 0664, NULL, gtp_dofwupdate_store);
+#endif
+
+static ssize_t gtp_productinfo_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct goodix_ts_data *data = dev_get_drvdata(dev);
+	struct goodix_fw_info *fw_info = &data->fw_info;
+	
+	return scnprintf(buf, PAGE_SIZE, "GT%s_%x_%d\n",
+			 fw_info->pid, fw_info->version, fw_info->sensor_id);
+}
+static DEVICE_ATTR(productinfo, 0444, gtp_productinfo_show, NULL);
+
+static ssize_t gtp_drv_irq_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	unsigned long value = 0;
+	int err = 0;
+	struct goodix_ts_data *data = dev_get_drvdata(dev);
+
+	err = kstrtoul(buf, 10, &value);
+	if (err < 0) {
+		dev_err(dev, "Failed to convert value\n");
+		return -EINVAL;
+	}
+
+	switch (value) {
+	case 0:
+		/* Disable irq */
+		gtp_work_control_enable(data, false);
+		break;
+	case 1:
+		/* Enable irq */
+		gtp_work_control_enable(data, true);
+		break;
+	default:
+		dev_err(dev, "Invalid value\n");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t gtp_drv_irq_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct goodix_ts_data *data = dev_get_drvdata(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%s\n",
+			 test_bit(WORK_THREAD_ENABLED, &data->flags)
+			 ? "enabled" : "disabled");
+}
+static DEVICE_ATTR(drv_irq, 0664, gtp_drv_irq_show, gtp_drv_irq_store);
+
+static ssize_t gtp_reset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct goodix_ts_data *data = dev_get_drvdata(dev);
+
+	if ('1' != buf[0]) {
+		dev_err(dev, "Invalid argument for reset\n");
+		return -EINVAL;
+	}
+
+	gtp_reset_guitar(data->client, 20);
+
+	return count;
+}
+static DEVICE_ATTR(reset, 0220, NULL, gtp_reset_store);
+
+static struct attribute *gtp_attrs[] = {
+	&dev_attr_workmode.attr,
+	&dev_attr_productinfo.attr,
+
+#ifdef CONFIG_TOUCHSCREEN_GT9XX_UPDATE
+	&dev_attr_dofwupdate.attr,
+#endif
+
+	&dev_attr_drv_irq.attr,
+	&dev_attr_reset.attr,
+	NULL
+};
+
+static const struct attribute_group gtp_attr_group = {
+	.attrs = gtp_attrs,
+};
+
+static int gtp_create_file(struct goodix_ts_data *ts)
+{
+	int ret;
+	struct i2c_client *client = ts->client;
+
+	/*  Create proc file system */
+	gtp_config_proc = NULL;
+	gtp_config_proc = proc_create(GT91XX_CONFIG_PROC_FILE, 0664,
+				      NULL, &config_proc_ops);
+	if (!gtp_config_proc)
+		dev_err(&client->dev, "create_proc_entry %s failed\n",
+			GT91XX_CONFIG_PROC_FILE);
+	else
+		dev_info(&client->dev, "create proc entry %s success\n",
+			 GT91XX_CONFIG_PROC_FILE);
+
+	ret = sysfs_create_group(&client->dev.kobj, &gtp_attr_group);
+	if (ret) {
+		dev_err(&client->dev, "Failure create sysfs group %d\n", ret);
+		/*TODO: debug change */
+		goto exit_free_config_proc;
+	}
+	return 0;
+
+exit_free_config_proc:
+	remove_proc_entry(GT91XX_CONFIG_PROC_FILE, gtp_config_proc);
+	return -ENODEV;
+}
+
+s32 gtp_get_fw_info(struct i2c_client *client, struct goodix_fw_info *fw_info)
+{
+	s32 ret = -1;
+	u8 buf[8] = {GTP_REG_VERSION >> 8, GTP_REG_VERSION & 0xff};
+
+	ret = gtp_i2c_read(client, buf, sizeof(buf));
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed read fw_info\n");
+		return ret;
+	}
+
+	/* product id */
+	memset(fw_info, 0, sizeof(*fw_info));
+
+	if (buf[5] == 0x00) {
+		memcpy(fw_info->pid, buf + GTP_ADDR_LENGTH, 3);
+		dev_info(&client->dev, "IC Version: %c%c%c_%02X%02X\n",
+			 buf[2], buf[3], buf[4], buf[7], buf[6]);
+	} else {
+		memcpy(fw_info->pid, buf + GTP_ADDR_LENGTH, 4);
+		dev_info(&client->dev, "IC Version: %c%c%c%c_%02X%02X\n",
+			 buf[2], buf[3], buf[4], buf[5], buf[7], buf[6]);
+	}
+	
+	/* current firmware version */
+	fw_info->version = (buf[7] << 8) | buf[6];
+
+	/* read sensor id */
+	fw_info->sensor_id = 0xff;
+	ret = gtp_i2c_read_dbl_check(client, GTP_REG_SENSOR_ID,
+				     &fw_info->sensor_id, 1);
+	if (SUCCESS != ret || fw_info->sensor_id >= 0x06) {
+		dev_err(&client->dev,
+			"Failed get valid sensor_id(0x%02X), No Config Sent\n",
+			fw_info->sensor_id);
+
+		fw_info->sensor_id = 0xff;
+	}
+
+	return ret;
+}
+
+static int gtp_i2c_test(struct i2c_client *client)
+{
+	u8 test[3] = {GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff};
+	u8 retry = 0;
+	int ret = -1;
+
+	while (retry++ < 3) {
+		ret = gtp_i2c_read(client, test, 3);
+		if (ret == 2)
+			return 0;
+
+		dev_err(&client->dev, "GTP i2c test failed time %d\n", retry);
+		usleep_range(10000, 11000); /* 10 ms */
+	}
+
+	return -EAGAIN;
+}
+
+static int gtp_pinctrl_init(struct goodix_ts_data *ts)
+{
+	struct goodix_pinctrl *pinctrl = &ts->pinctrl;
+
+	pinctrl->pinctrl = devm_pinctrl_get(&ts->client->dev);
+	if (IS_ERR_OR_NULL(pinctrl->pinctrl)) {
+		dev_info(&ts->client->dev, "No pinctrl found\n");
+		pinctrl->pinctrl = NULL;
+		return 0;
+	}
+
+	pinctrl->default_sta = pinctrl_lookup_state(pinctrl->pinctrl,
+						    "default");
+	if (IS_ERR_OR_NULL(pinctrl->default_sta)) {
+		dev_info(&ts->client->dev,
+			 "Failed get pinctrl state:default state\n");
+		goto exit_pinctrl_init;
+	}
+
+	pinctrl->int_out_high = pinctrl_lookup_state(pinctrl->pinctrl,
+						     "int-output-high");
+	if (IS_ERR_OR_NULL(pinctrl->int_out_high)) {
+		dev_info(&ts->client->dev,
+			 "INFO: Failed get pinctrl state:output_high\n");
+		goto exit_pinctrl_init;
+	}
+
+	pinctrl->int_out_low = pinctrl_lookup_state(pinctrl->pinctrl,
+						    "int-output-low");
+	if (IS_ERR_OR_NULL(pinctrl->int_out_low)) {
+		dev_info(&ts->client->dev,
+			 "Failed get pinctrl state:output_low\n");
+		goto exit_pinctrl_init;
+	}
+
+	pinctrl->int_input = pinctrl_lookup_state(pinctrl->pinctrl,
+						  "int-input");
+	if (IS_ERR_OR_NULL(pinctrl->int_input)) {
+		dev_info(&ts->client->dev,
+			 "Failed get pinctrl state:int-input\n");
+		goto exit_pinctrl_init;
+	}
+	dev_info(&ts->client->dev, "Success init pinctrl\n");
+	return 0;
+exit_pinctrl_init:
+	devm_pinctrl_put(pinctrl->pinctrl);
+	pinctrl->pinctrl = NULL;
+	pinctrl->int_out_high = NULL;
+	pinctrl->int_out_low = NULL;
+	pinctrl->int_input = NULL;
+	return 0;
+}
+
+static void gtp_pinctrl_deinit(struct goodix_ts_data *ts)
+{
+	if (ts->pinctrl.pinctrl)
+		devm_pinctrl_put(ts->pinctrl.pinctrl);
+}
+
+static int gtp_request_io_port(struct goodix_ts_data *ts)
+{
+	int ret = 0;
+
+	if (gpio_is_valid(ts->pdata->irq_gpio)) {
+		ret = gpio_request(ts->pdata->irq_gpio, "goodix_ts_int");
+		if (ret < 0) {
+			dev_err(&ts->client->dev,
+				"Failed to request GPIO:%d, ERRNO:%d\n",
+				(s32)ts->pdata->irq_gpio, ret);
+			return -ENODEV;
+		}
+
+		gpio_direction_input(ts->pdata->irq_gpio);
+		dev_info(&ts->client->dev, "Success request irq-gpio\n");
+	}
+
+	if (gpio_is_valid(ts->pdata->rst_gpio)) {
+		ret = gpio_request(ts->pdata->rst_gpio, "goodix_ts_rst");
+		if (ret < 0) {
+			dev_err(&ts->client->dev,
+				"Failed to request GPIO:%d, ERRNO:%d\n",
+				(s32)ts->pdata->rst_gpio, ret);
+
+			if (gpio_is_valid(ts->pdata->irq_gpio))
+				gpio_free(ts->pdata->irq_gpio);
+
+			return -ENODEV;
+		}
+
+		//gpio_direction_input(ts->pdata->rst_gpio);
+		gpio_direction_output(ts->pdata->rst_gpio, 0);
+		dev_info(&ts->client->dev,  "Success request rst-gpio\n");
+	}
+
+	return 0;
+}
+
+/*******************************************************
+ * Function:
+ *	Request interrupt if define irq pin, else use hrtimer
+ *	as interrupt source
+ * Input:
+ *	ts: private data.
+ * Output:
+ *	Executive outcomes.
+ *		0: succeed, -1: failed.
+ *******************************************************/
+static int gtp_request_irq(struct goodix_ts_data *ts)
+{
+	int ret = -1;
+
+	/* use irq */
+	if (gpio_is_valid(ts->pdata->irq_gpio) || ts->client->irq > 0) {
+		if (gpio_is_valid(ts->pdata->irq_gpio))
+			ts->client->irq = gpio_to_irq(ts->pdata->irq_gpio);
+
+		dev_info(&ts->client->dev, "INT num %d, trigger type:%d\n",
+			 ts->client->irq, ts->pdata->irq_flags);
+		ret = request_threaded_irq(ts->client->irq, NULL,
+				gtp_irq_handler,
+				ts->pdata->irq_flags | IRQF_ONESHOT,
+				ts->client->name,
+				ts);
+		if (ret < 0) {
+			dev_err(&ts->client->dev,
+				"Failed to request irq %d\n", ts->client->irq);
+			return ret;
+		}
+	} else { /* use hrtimer */
+		dev_info(&ts->client->dev, "No hardware irq, use hrtimer\n");
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = gtp_timer_handler;
+		hrtimer_start(&ts->timer,
+			      ktime_set(0, (GTP_POLL_TIME + 6) * 1000000),
+			      HRTIMER_MODE_REL);
+		set_bit(HRTIMER_USED, &ts->flags);
+		ret = 0;
+	}
+	return ret;
+}
+
+static s8 gtp_request_input_dev(struct goodix_ts_data *ts)
+{
+	s8 ret = -1;
+	u8 index = 0;
+
+	ts->input_dev = input_allocate_device();
+	if (!ts->input_dev) {
+		dev_err(&ts->client->dev, "Failed to allocate input device\n");
+		return -ENOMEM;
+	}
+
+	ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY)
+		| BIT_MASK(EV_ABS);
+	if (!ts->pdata->type_a_report) {
+		input_mt_init_slots(ts->input_dev, 16, INPUT_MT_DIRECT);
+		dev_info(&ts->client->dev, "Use slot report protocol\n");
+	} else {
+		__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+		__set_bit(BTN_TOUCH, ts->input_dev->keybit);
+		dev_info(&ts->client->dev, "Use type A report protocol\n");
+	}
+
+	input_set_capability(ts->input_dev, EV_KEY, GTP_PEN_BUTTON1);
+	input_set_capability(ts->input_dev, EV_KEY, GTP_PEN_BUTTON2);
+
+	/* touch key register */
+	for (index = 0; index < ts->pdata->key_nums; index++)
+		input_set_capability(ts->input_dev, EV_KEY,
+				     ts->pdata->key_map[index]);
+
+	if (ts->pdata->slide_wakeup)
+		input_set_capability(ts->input_dev, EV_KEY, KEY_POWER);
+
+	if (ts->pdata->swap_x2y)
+		GTP_SWAP(ts->pdata->abs_size_x, ts->pdata->abs_size_y);
+
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0,
+			     ts->pdata->abs_size_x, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0,
+			     ts->pdata->abs_size_y, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0,
+			     ts->pdata->max_touch_width, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_PRESSURE, 0,
+			     ts->pdata->max_touch_pressure, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0,
+			     ts->pdata->max_touch_id, 0, 0);
+	if (!ts->pdata->type_a_report) {
+		input_set_abs_params(ts->input_dev, ABS_MT_TOOL_TYPE,
+				     0, MT_TOOL_MAX, 0, 0);
+	} else {
+		__set_bit(BTN_TOOL_PEN, ts->input_dev->keybit);
+		__set_bit(BTN_TOOL_FINGER, ts->input_dev->keybit);
+	}
+
+	ts->input_dev->name = goodix_ts_name;
+	ts->input_dev->phys = goodix_input_phys;
+	ts->input_dev->id.bustype = BUS_I2C;
+	ts->input_dev->id.vendor = 0xDEAD;
+	ts->input_dev->id.product = 0xBEEF;
+	ts->input_dev->id.version = 10427;
+
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		dev_err(&ts->client->dev, "Register %s input device failed\n",
+			ts->input_dev->name);
+		input_free_device(ts->input_dev);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/*
+ * Devices Tree support
+ */
+#ifdef CONFIG_OF
+static void gtp_parse_dt_coords(struct device *dev,
+				struct goodix_ts_platform_data *pdata)
+{
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	ret = of_property_read_u32(np, "touchscreen-max-id",
+				   &pdata->max_touch_id);
+	if (ret || pdata->max_touch_id > GTP_MAX_TOUCH_ID) {
+		dev_info(dev, "Unset touchscreen-max-id, use default\n");
+		pdata->max_touch_id = GTP_MAX_TOUCH_ID;
+	}
+
+	ret = of_property_read_u32(np, "touchscreen-size-x",
+				   &pdata->abs_size_x);
+	if (ret) {
+		dev_info(dev, "Unset touchscreen-size-x, use default\n");
+		pdata->abs_size_x = GTP_DEFAULT_MAX_X;
+	}
+
+	ret = of_property_read_u32(np, "touchscreen-size-y",
+				   &pdata->abs_size_y);
+	if (ret) {
+		dev_info(dev, "Unset touchscreen-size-y, use default\n");
+		pdata->abs_size_y = GTP_DEFAULT_MAX_Y;
+	}
+
+	ret = of_property_read_u32(np, "touchscreen-max-w",
+				   &pdata->max_touch_width);
+	if (ret) {
+		dev_info(dev, "Unset touchscreen-max-w, use default\n");
+		pdata->max_touch_width = GTP_DEFAULT_MAX_WIDTH;
+	}
+
+	ret = of_property_read_u32(np, "touchscreen-max-p",
+				   &pdata->max_touch_pressure);
+	if (ret) {
+		dev_info(dev, "Unset touchscreen-max-p, use default\n");
+		pdata->max_touch_pressure = GTP_DEFAULT_MAX_PRESSURE;
+	}
+	dev_info(dev, "touch input parameters is [id x y w p]<%d %d %d %d %d>\n",
+		 pdata->max_touch_id, pdata->abs_size_x, pdata->abs_size_y,
+		 pdata->max_touch_width, pdata->max_touch_pressure);
+}
+
+static int gtp_parse_dt(struct device *dev,
+			struct goodix_ts_platform_data *pdata)
+{
+	int ret;
+	u32  key_nums;
+	struct property *prop;
+	u32 key_map[MAX_KEY_NUMS];
+	struct device_node *np = dev->of_node;
+
+	gtp_parse_dt_coords(dev, pdata);
+
+	ret = of_property_read_u32(np, "irq-flags",
+				   &pdata->irq_flags);
+	if (ret) {
+		dev_info(dev,
+			 "Failed get int-trigger-type from dts,set default\n");
+		pdata->irq_flags = GTP_DEFAULT_INT_TRIGGER;
+	}
+	of_property_read_u32(np, "goodix,int-sync", &pdata->int_sync);
+	if (pdata->int_sync)
+		dev_info(dev, "int-sync enabled\n");
+
+	of_property_read_u32(np, "goodix,driver-send-cfg",
+			     &pdata->driver_send_cfg);
+	if (pdata->driver_send_cfg)
+		dev_info(dev, "driver-send-cfg enabled\n");
+
+	of_property_read_u32(np, "goodix,swap-x2y", &pdata->swap_x2y);
+	if (pdata->swap_x2y)
+		dev_info(dev, "swap-x2y enabled\n");
+
+	of_property_read_u32(np, "goodix,slide-wakeup", &pdata->slide_wakeup);
+	if (pdata->slide_wakeup)
+		dev_info(dev, "slide-wakeup enabled\n");
+
+	of_property_read_u32(np, "goodix,auto-update", &pdata->auto_update);
+	if (pdata->auto_update)
+		dev_info(dev, "auto-update enabled\n");
+
+	of_property_read_u32(np, "goodix,auto-update-cfg",
+			     &pdata->auto_update_cfg);
+	if (pdata->auto_update_cfg)
+		dev_info(dev, "auto-update-cfg enabled\n");
+
+	of_property_read_u32(np, "goodix,esd-protect", &pdata->esd_protect);
+	if (pdata->esd_protect)
+		dev_info(dev, "esd-protect enabled\n");
+
+	of_property_read_u32(np, "goodix,type-a-report",
+			     &pdata->type_a_report);
+	if (pdata->type_a_report)
+		dev_info(dev, "type-a-report enabled\n");
+
+	of_property_read_u32(np, "goodix,resume-in-workqueue",
+			     &pdata->resume_in_workqueue);
+	if (pdata->resume_in_workqueue)
+		dev_info(dev, "resume-in-workqueue enabled\n");
+
+	of_property_read_u32(np, "goodix,power-off-sleep",
+			     &pdata->power_off_sleep);
+	if (pdata->power_off_sleep)
+		dev_info(dev, "power-off-sleep enabled\n");
+
+	of_property_read_u32(np, "goodix,pen-suppress-finger",
+			     &pdata->pen_suppress_finger);
+	if (pdata->pen_suppress_finger)
+		dev_info(dev, "pen-suppress-finger enabled\n");
+
+	prop = of_find_property(np, "touchscreen-key-map", NULL);
+	if (prop) {
+		key_nums = prop->length / sizeof(key_map[0]);
+		key_nums = key_nums > MAX_KEY_NUMS ? MAX_KEY_NUMS : key_nums;
+
+		dev_dbg(dev, "key nums %d\n", key_nums);
+		ret = of_property_read_u32_array(np,
+				"touchscreen-key-map", key_map,
+				key_nums);
+		if (ret) {
+			dev_err(dev, "Unable to read key codes\n");
+			pdata->key_nums = 0;
+			memset(pdata->key_map, 0,
+			       MAX_KEY_NUMS * sizeof(pdata->key_map[0]));
+		}
+		pdata->key_nums = key_nums;
+		memcpy(pdata->key_map, key_map,
+		       key_nums * sizeof(pdata->key_map[0]));
+		dev_info(dev, "key-map is [%x %x %x %x]\n",
+			 pdata->key_map[0], pdata->key_map[1],
+			 pdata->key_map[2], pdata->key_map[3]);
+	}
+
+	pdata->irq_gpio = of_get_named_gpio(np, "irq-gpios", 0);
+	if (!gpio_is_valid(pdata->irq_gpio))
+		dev_err(dev, "No valid irq gpio");
+
+	pdata->rst_gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (!gpio_is_valid(pdata->rst_gpio))
+		dev_err(dev, "No valid rst gpio");
+
+	return 0;
+}
+
+/*******************************************************
+ * Function:
+ *	parse config data from devices tree.
+ * Input:
+ *	dev: device that this driver attached.
+ *	cfg: pointer of the config array.
+ *	cfg_len: pointer of the config length.
+ *	sid: sensor id.
+ * Output:
+ *	Executive outcomes.
+ *		0-succeed, -1-faileds.
+ *******************************************************/
+int gtp_parse_dt_cfg(struct device *dev, u8 *cfg, int *cfg_len, u8 sid)
+{
+	struct device_node *np = dev->of_node;
+	struct property *prop;
+	char cfg_name[18];
+	int ret;
+
+	snprintf(cfg_name, sizeof(cfg_name), "goodix,cfg-group%d", sid);
+	prop = of_find_property(np, cfg_name, cfg_len);
+	if (!prop || !prop->value || *cfg_len == 0 ||
+	    *cfg_len > GTP_CONFIG_MAX_LENGTH) {
+		*cfg_len = 0;
+		ret = -EPERM;/* failed */
+	} else {
+		memcpy(cfg, prop->value, *cfg_len);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+#endif
+
+static int gtp_power_on(struct goodix_ts_data *ts)
+{
+	int ret = 0;
+
+	if (ts->vdd_ana) {
+		ret = regulator_enable(ts->vdd_ana);
+		if (ret) {
+			dev_err(&ts->client->dev,
+				"Regulator vdd enable failed ret=%d\n",
+				ret);
+			goto err_enable_vdd_ana;
+		}
+	}
+
+	if (ts->vcc_i2c) {
+		ret = regulator_enable(ts->vcc_i2c);
+		if (ret) {
+			dev_err(&ts->client->dev,
+				"Regulator vcc_i2c enable failed ret=%d\n",
+				ret);
+			goto err_enable_vcc_i2c;
+		}
+	}
+	clear_bit(POWER_OFF_MODE, &ts->flags);
+	return 0;
+
+err_enable_vcc_i2c:
+	if (ts->vdd_ana)
+		regulator_disable(ts->vdd_ana);
+err_enable_vdd_ana:
+	set_bit(POWER_OFF_MODE, &ts->flags);
+	return ret;
+}
+
+static int gtp_power_off(struct goodix_ts_data *ts)
+{
+	int ret = 0;
+
+	if (ts->vcc_i2c) {
+		set_bit(POWER_OFF_MODE, &ts->flags);
+		ret = regulator_disable(ts->vcc_i2c);
+		if (ret) {
+			dev_err(&ts->client->dev,
+				"Regulator vcc_i2c disable failed ret=%d\n",
+				ret);
+			goto err_disable_vcc_i2c;
+		}
+		dev_info(&ts->client->dev,
+			 "Regulator vcc_i2c disabled\n");
+	}
+
+	if (ts->vdd_ana) {
+		set_bit(POWER_OFF_MODE, &ts->flags);
+		ret = regulator_disable(ts->vdd_ana);
+		if (ret) {
+			dev_err(&ts->client->dev,
+					"Regulator vdd disable failed ret=%d\n",
+					ret);
+			goto err_disable_vdd_ana;
+		}
+		dev_info(&ts->client->dev,
+			 "Regulator vdd_ana disabled\n");
+	}
+	return ret;
+
+err_disable_vdd_ana:
+	if (ts->vcc_i2c)
+		ret = regulator_enable(ts->vcc_i2c);
+err_disable_vcc_i2c:
+	clear_bit(POWER_OFF_MODE, &ts->flags);
+	return ret;
+}
+
+static int gtp_power_init(struct goodix_ts_data *ts)
+{
+	int ret;
+
+	ts->vdd_ana = regulator_get(&ts->client->dev, "vdd_ana");
+	if (IS_ERR(ts->vdd_ana)) {
+		ts->vdd_ana = NULL;
+		ret = PTR_ERR(ts->vdd_ana);
+		dev_info(&ts->client->dev,
+			 "Regulator get failed vdd ret=%d\n", ret);
+	}
+
+	ts->vcc_i2c = regulator_get(&ts->client->dev, "vcc_i2c");
+	if (IS_ERR(ts->vcc_i2c)) {
+		ts->vcc_i2c = NULL;
+		ret = PTR_ERR(ts->vcc_i2c);
+		dev_info(&ts->client->dev,
+			 "Regulator get failed vcc_i2c ret=%d\n", ret);
+	}
+	return 0;
+}
+
+static int gtp_power_deinit(struct goodix_ts_data *ts)
+{
+	if (ts->vdd_ana)
+		regulator_put(ts->vdd_ana);
+	if (ts->vcc_i2c)
+		regulator_put(ts->vcc_i2c);
+
+	return 0;
+}
+
+static void gtp_shutdown(struct i2c_client *client)
+{
+	struct goodix_ts_data *data = i2c_get_clientdata(client);
+
+	if (!data->init_done)
+		return;
+
+	gtp_work_control_enable(data, false);
+	gtp_power_off(data);
+
+	return;
+}
+
+static int gtp_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret = -1;
+	struct goodix_ts_data *ts;
+	struct goodix_ts_platform_data *pdata;
+
+	/* do NOT remove these logs */
+	dev_info(&client->dev, "GTP Driver Version: %s\n", GTP_DRIVER_VERSION);
+	dev_info(&client->dev, "GTP I2C Address: 0x%02x\n", client->addr);
+
+	i2c_connect_client = client;
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "Failed check I2C functionality");
+		return -ENODEV;
+	}
+
+	ts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);
+	if (!ts) {
+		dev_err(&client->dev, "Failed alloc ts memory");
+		return -ENOMEM;
+	}
+
+	pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(&client->dev, "Failed alloc pdata memory\n");
+		devm_kfree(&client->dev, ts);
+		return -EINVAL;
+	}
+
+	ts->init_done = false;
+
+#ifdef CONFIG_OF
+	if (client->dev.of_node) {
+		ret = gtp_parse_dt(&client->dev, pdata);
+		if (ret) {
+			dev_err(&client->dev, "Failed parse dts\n");
+			goto exit_free_client_data;
+		}
+	}
+#else
+	/* set parameters at here if you platform doesn't DTS */
+	pdata->rst_gpio = GTP_RST_PORT;
+	pdata->irq_gpio = GTP_INT_PORT;
+	pdata->slide_wakeup = false;
+	pdata->auto_update = true;
+	pdata->auto_update_cfg = false;
+	pdata->type_a_report = false;
+	pdata->esd_protect = false;
+	pdata->max_touch_id = GTP_MAX_TOUCH_ID;
+	pdata->abs_size_x = GTP_DEFAULT_MAX_X;
+	pdata->abs_size_y = GTP_DEFAULT_MAX_Y;
+	pdata->max_touch_width = GTP_DEFAULT_MAX_WIDTH;
+	pdata->max_touch_pressure = GTP_DEFAULT_MAX_PRESSURE;
+#endif
+
+	ts->client = client;
+	ts->pdata = pdata;
+
+	i2c_set_clientdata(client, ts);
+
+	ret = gtp_power_init(ts);
+	if (ret) {
+		dev_err(&client->dev, "Failed get regulator\n");
+		ret = -EINVAL;
+		goto exit_free_client_data;
+	}
+
+	ret = gtp_power_on(ts);
+	if (ret) {
+		dev_err(&client->dev, "Failed power on device\n");
+		ret = -EINVAL;
+		goto exit_deinit_power;
+	}
+
+	ret = gtp_pinctrl_init(ts);
+	if (ret < 0) {
+		/* if define pinctrl must define the following state
+		 * to let int-pin work normally: default, int_output_high,
+		 * int_output_low, int_input
+		 */
+		dev_err(&client->dev, "Failed get wanted pinctrl state\n");
+		goto exit_deinit_power;
+	}
+
+	ret = gtp_request_io_port(ts);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed request IO port\n");
+		goto exit_power_off;
+	}
+
+	gtp_reset_guitar(ts->client, 20);
+
+	ret = gtp_i2c_test(client);
+	if (ret) {
+		dev_err(&client->dev, "Failed communicate with IC use I2C\n");
+		goto exit_free_io_port;
+	}
+
+	dev_info(&client->dev, "I2C Addr is %x\n", client->addr);
+
+	ret = gtp_get_fw_info(client, &ts->fw_info);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed read FW version\n");
+		goto exit_free_io_port;
+	}
+
+	pdata->config.data[0] = GTP_REG_CONFIG_DATA >> 8;
+	pdata->config.data[1] = GTP_REG_CONFIG_DATA & 0xff;
+	ret = gtp_init_panel(ts);
+	if (ret < 0)
+		dev_info(&client->dev, "Panel un-initialize\n");
+
+#ifdef CONFIG_TOUCHSCREEN_GT9XX_UPDATE
+	if (ts->pdata->auto_update) {
+		ret = gup_init_update_proc(ts);
+		if (ret < 0)
+			dev_err(&client->dev, "Failed create update thread\n");
+	}
+#endif
+
+	ret = gtp_request_input_dev(ts);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed request input device\n");
+		goto exit_free_io_port;
+	}
+
+	mutex_init(&ts->lock);
+
+	ret = gtp_request_irq(ts);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed create work thread");
+		goto exit_unreg_input_dev;
+	}
+	gtp_work_control_enable(ts, false);
+	if (ts->pdata->slide_wakeup) {
+		dev_info(&client->dev, "slide wakeup enabled\n");
+		ret = enable_irq_wake(client->irq);
+		if (ret < 0)
+			dev_err(&client->dev, "Failed set irq wake\n");
+	}
+
+	gtp_register_powermanager(ts);
+
+	ret = gtp_create_file(ts);
+	if (ret) {
+		dev_info(&client->dev, "Failed create attributes file");
+		goto exit_powermanager;
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_GT9XX_TOOL
+	init_wr_node(client);/*TODO judge return value */
+#endif
+
+	gtp_esd_init(ts);
+	gtp_esd_on(ts);
+	/* probe init finished */
+	ts->init_done = true;
+	gtp_work_control_enable(ts, true);
+
+	return 0;
+
+exit_powermanager:
+	gtp_unregister_powermanager(ts);
+exit_unreg_input_dev:
+	input_unregister_device(ts->input_dev);
+exit_free_io_port:
+	if (gpio_is_valid(ts->pdata->rst_gpio))
+		gpio_free(ts->pdata->rst_gpio);
+	if (gpio_is_valid(ts->pdata->irq_gpio))
+		gpio_free(ts->pdata->irq_gpio);
+exit_power_off:
+	gtp_power_off(ts);
+	gtp_pinctrl_deinit(ts);
+exit_deinit_power:
+	gtp_power_deinit(ts);
+exit_free_client_data:
+	devm_kfree(&client->dev, pdata);
+	devm_kfree(&client->dev, ts);
+	i2c_set_clientdata(client, NULL);
+
+	return ret;
+}
+
+static int gtp_drv_remove(struct i2c_client *client)
+{
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	gtp_work_control_enable(ts, false);
+	gtp_unregister_powermanager(ts);
+
+	remove_proc_entry(GT91XX_CONFIG_PROC_FILE, gtp_config_proc);
+
+	sysfs_remove_group(&client->dev.kobj, &gtp_attr_group);
+
+#ifdef CONFIG_TOUCHSCREEN_GT9XX_TOOL
+	uninit_wr_node();
+#endif
+
+	if (ts->pdata->esd_protect)
+		gtp_esd_off(ts);
+
+	/* TODO: how to judge a irq numbers validity */
+	if (ts->client->irq)
+		free_irq(client->irq, ts);
+	else
+		hrtimer_cancel(&ts->timer);
+
+	if (gpio_is_valid(ts->pdata->rst_gpio))
+		gpio_free(ts->pdata->rst_gpio);
+
+	if (gpio_is_valid(ts->pdata->irq_gpio))
+		gpio_free(ts->pdata->irq_gpio);
+
+	gtp_power_off(ts);
+	gtp_power_deinit(ts);
+	gtp_pinctrl_deinit(ts);
+	dev_info(&client->dev, "goodix ts driver removed");
+	i2c_set_clientdata(client, NULL);
+	input_unregister_device(ts->input_dev);
+	mutex_destroy(&ts->lock);
+
+	devm_kfree(&client->dev, ts->pdata);
+	devm_kfree(&client->dev, ts);
+
+	return 0;
+}
+
+static void gtp_suspend(struct goodix_ts_data *ts)
+{
+	int ret = -1;
+
+	if (test_bit(FW_UPDATE_RUNNING, &ts->flags)) {
+		dev_warn(&ts->client->dev,
+			 "Fw upgrade in progress, can't go to suspend\n");
+		return;
+	}
+
+	if (test_and_set_bit(SLEEP_MODE, &ts->flags)) {
+		dev_info(&ts->client->dev, "Already in suspend state\n");
+		return;
+	}
+
+	dev_dbg(&ts->client->dev, "Try enter suspend mode\n");
+
+	gtp_esd_off(ts);
+	gtp_work_control_enable(ts, false);
+	if (ts->pdata->slide_wakeup) {
+		ret = gtp_enter_doze(ts);
+		gtp_work_control_enable(ts, true);
+	} else if (ts->pdata->power_off_sleep) {
+		/*TODO: power off routine */
+		gtp_power_off(ts);
+		ret = SUCCESS;
+	} else {
+		ret = gtp_enter_sleep(ts);
+	}
+
+	if (ret < 0)
+		dev_err(&ts->client->dev, "Failed enter suspend\n");
+
+	/*  to avoid waking up while not sleeping */
+	/*	delay 48 + 10ms to ensure reliability */
+	msleep(GTP_58_DLY_MS);
+}
+
+static int gtp_gesture_wakeup(struct goodix_ts_data *ts)
+{
+	int ret;
+	int retry = 10;
+
+	do {
+		gtp_reset_guitar(ts->client, 10);
+		ret = gtp_i2c_test(ts->client);
+		if (!ret)
+			break;
+	} while (--retry);
+
+	if (!retry)
+		ret = -EIO;
+
+	clear_bit(DOZE_MODE, &ts->flags);
+	return ret;
+}
+
+static void gtp_resume(struct goodix_ts_data *ts)
+{
+	int ret = 0;
+
+	if (test_bit(FW_UPDATE_RUNNING, &ts->flags)) {
+		dev_info(&ts->client->dev,
+			 "Fw upgrade in progress, can't do resume\n");
+		return;
+	}
+
+	if (!test_bit(SLEEP_MODE, &ts->flags)) {
+		dev_dbg(&ts->client->dev, "Already in awake state\n");
+		return;
+	}
+
+	dev_info(&ts->client->dev, "Try resume from sleep mode\n");
+
+	gtp_work_control_enable(ts, false);
+
+	if (ts->pdata->slide_wakeup && test_bit(DOZE_MODE, &ts->flags)) {
+		ret = gtp_gesture_wakeup(ts);
+		if (ret)
+			dev_warn(&ts->client->dev, "Failed wake up from gesture mode\n");
+	} else if (ts->pdata->power_off_sleep) {
+		ret = gtp_power_on(ts);
+		if (ret) {
+			dev_warn(&ts->client->dev, "Failed wake up from gesture mode\n");
+		} else {
+			gtp_reset_guitar(ts->client, 20);
+			ret = gtp_i2c_test(ts->client);
+			if (ret)
+				dev_warn(&ts->client->dev,
+					 "I2C communicate failed after power on\n");
+		}
+	} else {
+		ret = gtp_wakeup_sleep(ts);
+		if (ret)
+			dev_warn(&ts->client->dev,
+				 "Failed wakeup from sleep mode\n");
+	}
+
+	if (ret)
+		dev_warn(&ts->client->dev, "Later resume failed\n");
+	else
+		gtp_esd_on(ts);
+
+	clear_bit(SLEEP_MODE, &ts->flags);
+	gtp_work_control_enable(ts, true);
+}
+
+#if defined(CONFIG_FB)
+static void fb_notify_resume_work(struct work_struct *work)
+{
+	struct goodix_ts_data *ts =
+		container_of(work, struct goodix_ts_data, fb_notify_work);
+	dev_info(&ts->client->dev, "try resume in workqueue\n");
+	gtp_resume(ts);
+}
+
+/* frame buffer notifier block control the suspend/resume procedure */
+static int gtp_fb_notifier_callback(struct notifier_block *noti,
+				    unsigned long event, void *data)
+{
+	struct fb_event *ev_data = data;
+	struct goodix_ts_data *ts = container_of(noti,
+			struct goodix_ts_data, notifier);
+	int *blank;
+
+	if (ev_data && ev_data->data && event == FB_EVENT_BLANK && ts) {
+		blank = ev_data->data;
+		if (*blank == FB_BLANK_UNBLANK ||
+		    *blank == FB_BLANK_NORMAL) {
+			dev_dbg(&ts->client->dev, "ts_resume");
+			if (ts->pdata->resume_in_workqueue)
+				schedule_work(&ts->fb_notify_work);
+			else
+				gtp_resume(ts);
+		} else if (*blank == FB_BLANK_POWERDOWN) {
+			dev_dbg(&ts->client->dev, "ts_suspend");
+			if (ts->pdata->resume_in_workqueue)
+				flush_work(&ts->fb_notify_work);
+			gtp_suspend(ts);
+		}
+	}
+
+	return 0;
+}
+
+#elif defined(CONFIG_PM)
+static int gtp_pm_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts) {
+		dev_dbg(&ts->client->dev, "Suspend by i2c pm.");
+		gtp_suspend(ts);
+	}
+
+	return 0;
+}
+
+static int gtp_pm_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts) {
+		dev_dbg(&ts->client->dev, "Resume by i2c pm.");
+		gtp_resume(ts);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops gtp_pm_ops = {
+	.suspend = gtp_pm_suspend,
+	.resume  = gtp_pm_resume,
+};
+
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+static void gtp_early_suspend(struct early_suspend *h)
+{
+	struct goodix_ts_data *ts = container_of(h,
+			struct goodix_ts_data, early_suspend);
+
+	if (ts) {
+		dev_dbg(&ts->client->dev, "Suspend by earlysuspend module.");
+		gtp_suspend(ts);
+	}
+}
+
+static void gtp_late_resume(struct early_suspend *h)
+{
+	struct goodix_ts_data *ts = container_of(h,
+			struct goodix_ts_data, early_suspend);
+
+	if (ts) {
+		dev_dbg(&ts->client->dev, "Resume by earlysuspend module.");
+		gtp_resume(ts);
+	}
+}
+#endif
+
+static int gtp_register_powermanager(struct goodix_ts_data *ts)
+{
+	int ret;
+#if defined(CONFIG_FB)
+	INIT_WORK(&ts->fb_notify_work, fb_notify_resume_work);
+	ts->notifier.notifier_call = gtp_fb_notifier_callback;
+	ret = fb_register_client(&ts->notifier);
+	if (ret)
+		dev_err(&ts->client->dev,
+			"Unable to register fb_notifier: %d\n", ret);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = goodix_ts_early_suspend;
+	ts->early_suspend.resume = goodix_ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+	return ret;
+}
+
+static int gtp_unregister_powermanager(struct goodix_ts_data *ts)
+{
+#if defined(CONFIG_FB)
+		fb_unregister_client(&ts->notifier);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+		unregister_early_suspend(&ts->early_suspend);
+#endif
+
+	return 0;
+}
+
+/*******************************************************
+ * Function:
+ *	Initialize external watchdog for esd protect
+ * Input:
+ *	client: i2c device.
+ * Output:
+ *	result of i2c write operation.
+ *		0: succeed, otherwise: failed
+ ********************************************************/
+static int gtp_init_ext_watchdog(struct i2c_client *client)
+{
+	int ret;
+	u8 opr_buffer[3] = { (u8)(GTP_REG_ESD_CHECK >> 8),
+			     (u8)GTP_REG_ESD_CHECK,
+			     (u8)GTP_ESD_CHECK_VALUE };
+
+	dev_dbg(&client->dev, "[Esd]Init external watchdog\n");
+	ret = gtp_i2c_write(client, opr_buffer, 3);
+	if (ret == 1)
+		return 0;
+
+	dev_err(&client->dev, "Failed init ext watchdog\n");
+	return -EINVAL;
+}
+
+static void gtp_esd_check_func(struct work_struct *work)
+{
+	s32 i;
+	s32 ret = -1;
+	u8 esd_buf[5] = { (u8)(GTP_REG_COMMAND >> 8), (u8)GTP_REG_COMMAND };
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct goodix_ts_esd *ts_esd = container_of(dwork, struct goodix_ts_esd,
+						    delayed_work);
+	struct goodix_ts_data *ts = container_of(ts_esd, struct goodix_ts_data,
+						 ts_esd);
+
+	if (test_bit(SLEEP_MODE, &ts->flags) ||
+	    test_bit(FW_UPDATE_RUNNING, &ts->flags)) {
+		dev_dbg(&ts->client->dev,
+			"Esd cancled by power_suspend or fw_update!");
+		return;
+	}
+
+	if (ts_esd->esd_on == false)
+		return;
+
+	for (i = 0; i < 3; i++) {
+		ret = gtp_i2c_read(ts->client, esd_buf, 4);
+		if (ret < 0)
+			continue;
+
+		dev_dbg(&ts->client->dev,
+			"[Esd]0x8040 = 0x%02X, 0x8041 = 0x%02X",
+			esd_buf[2], esd_buf[3]);
+		if (esd_buf[2] == (u8)GTP_ESD_CHECK_VALUE ||
+		    esd_buf[3] != (u8)GTP_ESD_CHECK_VALUE) {
+			gtp_i2c_read(ts->client, esd_buf, 4);
+			if (ret < 0)
+				continue;
+
+			if (esd_buf[2] == (u8)GTP_ESD_CHECK_VALUE ||
+			    esd_buf[3] != (u8)GTP_ESD_CHECK_VALUE) {
+				i = 3;
+				break;
+			}
+		} else {
+			/* IC works normally, Write 0x8040 0xAA, feed the dog */
+			esd_buf[2] = (u8)GTP_ESD_CHECK_VALUE;
+			gtp_i2c_write(ts->client, esd_buf, 3);
+			break;
+		}
+	}
+	if (i >= 3) {
+		dev_err(&ts->client->dev, "IC working abnormally! Reset IC\n");
+		esd_buf[0] = 0x42;
+		esd_buf[1] = 0x26;
+		esd_buf[2] = 0x01;
+		esd_buf[3] = 0x01;
+		esd_buf[4] = 0x01;
+		gtp_i2c_write(ts->client, esd_buf, 5);
+		/* TODO: Is power off really need? */
+		msleep(GTP_50_DLY_MS);
+		gtp_power_off(ts);
+		msleep(GTP_20_DLY_MS);
+		gtp_power_on(ts);
+		msleep(GTP_20_DLY_MS);
+
+		gtp_reset_guitar(ts->client, 50);
+		msleep(GTP_50_DLY_MS);
+		gtp_send_cfg(ts->client);
+	}
+
+	if (ts_esd->esd_on == true && !test_bit(SLEEP_MODE, &ts->flags)) {
+		schedule_delayed_work(&ts_esd->delayed_work, 2 * HZ);
+		dev_dbg(&ts->client->dev, "ESD work rescheduled\n");
+	}
+}
+
+static int gtp_esd_init(struct goodix_ts_data *ts)
+{
+	struct goodix_ts_esd *ts_esd = &ts->ts_esd;
+
+	INIT_DELAYED_WORK(&ts_esd->delayed_work, gtp_esd_check_func);
+	mutex_init(&ts_esd->mutex);
+	ts_esd->esd_on = false;
+
+	return 0;
+}
+
+void gtp_esd_on(struct goodix_ts_data *ts)
+{
+	struct goodix_ts_esd *ts_esd = &ts->ts_esd;
+
+	if (!ts->pdata->esd_protect)
+		return;
+	mutex_lock(&ts_esd->mutex);
+	if (ts_esd->esd_on == false) {
+		ts_esd->esd_on = true;
+		schedule_delayed_work(&ts_esd->delayed_work, 2 * HZ);
+		dev_info(&ts->client->dev, "ESD on");
+	}
+	mutex_unlock(&ts_esd->mutex);
+}
+
+void gtp_esd_off(struct goodix_ts_data *ts)
+{
+	struct goodix_ts_esd *ts_esd = &ts->ts_esd;
+
+	if (!ts->pdata->esd_protect)
+		return;
+	mutex_lock(&ts_esd->mutex);
+	if (ts_esd->esd_on == true) {
+		ts_esd->esd_on = false;
+		cancel_delayed_work_sync(&ts_esd->delayed_work);
+		dev_info(&ts->client->dev, "ESD off");
+	}
+	mutex_unlock(&ts_esd->mutex);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id gtp_match_table[] = {
+	{.compatible = "goodix,gt9xx",},
+	{ },
+};
+#endif
+
+static const struct i2c_device_id gtp_device_id[] = {
+	{ GTP_I2C_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver goodix_ts_driver = {
+	.probe		= gtp_probe,
+	.remove		= gtp_drv_remove,
+	.id_table	= gtp_device_id,
+	.shutdown	= gtp_shutdown,
+	.driver = {
+		.name	  = GTP_I2C_NAME,
+		.owner	  = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = gtp_match_table,
+#endif
+#if !defined(CONFIG_FB) && defined(CONFIG_PM)
+		.pm		  = &gtp_pm_ops,
+#endif
+	},
+};
+
+static int __init gtp_init(void)
+{
+	s32 ret;
+
+	pr_info("Gt9xx driver installing..\n");
+	ret = i2c_add_driver(&goodix_ts_driver);
+
+	return ret;
+}
+
+static void __exit gtp_exit(void)
+{
+	pr_info("Gt9xx driver exited\n");
+	i2c_del_driver(&goodix_ts_driver);
+}
+
+module_init(gtp_init);
+module_exit(gtp_exit);
+
+MODULE_DESCRIPTION("GT9 serials touch controller Driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/input/touchscreen/goodix_gt9xx/gt9xx.h b/drivers/input/touchscreen/goodix_gt9xx/gt9xx.h
new file mode 100644
index 000000000..2e1c66587
--- /dev/null
+++ b/drivers/input/touchscreen/goodix_gt9xx/gt9xx.h
@@ -0,0 +1,384 @@
+/*
+ * Goodix GT9xx touchscreen driver
+ *
+ * Copyright  (C)  2016 - 2017 Goodix. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 2.8.0.2
+ * Release Date: 2017/12/14
+ */
+
+#ifndef _GOODIX_GT9XX_H_
+#define _GOODIX_GT9XX_H_
+
+#include <linux/kernel.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/major.h>
+#include <linux/kdev_t.h>
+#ifdef CONFIG_OF
+#include <linux/of_gpio.h>
+#endif
+#ifdef CONFIG_FB
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/usb.h>
+#include <linux/power_supply.h>
+
+#define GTP_TOOL_PEN	1
+#define GTP_TOOL_FINGER 2
+
+#define MAX_KEY_NUMS 4
+#define GTP_CONFIG_MAX_LENGTH 240
+#define GTP_ADDR_LENGTH       2
+
+/***************************PART1:ON/OFF define*******************************/
+#define GTP_DEBUG_ON          1
+#define GTP_DEBUG_ARRAY_ON    0
+#define GTP_DEBUG_FUNC_ON     0
+
+struct goodix_point_t {
+	int id;
+	int x;
+	int y;
+	int w;
+	int p;
+	int tool_type;
+};
+
+struct goodix_config_data {
+	int length;
+	u8 data[GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH];
+};
+
+struct goodix_ts_platform_data {
+	int irq_gpio;
+	int rst_gpio;
+	u32 irq_flags;
+	u32 abs_size_x;
+	u32 abs_size_y;
+	u32 max_touch_id;
+	u32 max_touch_width;
+	u32 max_touch_pressure;
+	u32 key_map[MAX_KEY_NUMS];
+	u32 key_nums;
+	u32 int_sync;
+	u32 driver_send_cfg;
+	u32 swap_x2y;
+	u32 slide_wakeup;
+	u32 auto_update;
+	u32 auto_update_cfg;
+	u32 esd_protect;
+	u32 type_a_report;
+	u32 power_off_sleep;
+	u32 resume_in_workqueue;
+	u32 pen_suppress_finger;
+	struct goodix_config_data config;
+};
+
+struct goodix_ts_esd {
+	struct delayed_work delayed_work;
+	struct mutex mutex;
+	bool esd_on;
+};
+
+enum {
+	WORK_THREAD_ENABLED = 0,
+	HRTIMER_USED,
+	FW_ERROR,
+
+	DOZE_MODE,
+	SLEEP_MODE,
+	POWER_OFF_MODE,
+	RAW_DATA_MODE,
+
+	FW_UPDATE_RUNNING,
+	PANEL_RESETTING
+};
+
+struct goodix_pinctrl {
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *default_sta;
+	struct pinctrl_state *int_out_high;
+	struct pinctrl_state *int_out_low;
+	struct pinctrl_state *int_input;
+};
+
+struct goodix_fw_info {
+	u8 pid[6];
+	u16 version;
+	u8 sensor_id;
+};
+
+struct goodix_ts_data {
+	unsigned long flags; /* This member record the device status */
+
+	struct goodix_ts_esd ts_esd;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct input_dev *pen_dev;
+	struct goodix_ts_platform_data *pdata;
+	/* use pinctrl control int-pin output low or high */
+	struct goodix_pinctrl pinctrl;
+	struct hrtimer timer;
+	struct mutex lock;
+	struct notifier_block ps_notif;
+	struct regulator *vdd_ana;
+	struct regulator *vcc_i2c;
+#if defined(CONFIG_FB)
+	struct notifier_block notifier;
+	struct work_struct fb_notify_work;
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif
+	struct goodix_fw_info fw_info;
+	bool force_update;
+	bool init_done;
+};
+
+/************************* PART2:TODO define *******************************/
+/* STEP_1(REQUIRED): Define Configuration Information Group(s)
+ Sensor_ID Map:
+	 sensor_opt1 sensor_opt2 Sensor_ID
+		GND         GND          0
+		VDDIO      GND          1
+		NC           GND          2
+		GND         NC/300K    3
+		VDDIO      NC/300K    4
+		NC           NC/300K    5
+*/
+/* TODO: define your own default or for Sensor_ID == 0 config here.
+	 The predefined one is just a sample config,
+	 which is not suitable for your tp in most cases. */
+#define CTP_CFG_GROUP0 {\
+	0x41, 0xD0, 0x02, 0x00, 0x05, 0x0A, 0x34, \
+	0x00, 0x01, 0x08, 0x28, 0x05, 0x50, 0x32, \
+	0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0x17, 0x19, 0x1E, 0x14, 0x8C, \
+	0x2D, 0x0E, 0x3C, 0x3E, 0x82, 0x0A, 0x82, \
+	0x0A, 0x00, 0x99, 0x33, 0x1D, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x2B, 0x19, 0x64, 0x94, 0xC0, 0x02, \
+	0x08, 0x00, 0x00, 0x04,	0xF2, 0x1C, 0x00, \
+	0xB9, 0x26, 0x00, 0x93, 0x32, 0x00, 0x77, \
+	0x42, 0x00, 0x62, 0x57, 0x00, 0x62, 0x00, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0xFF, 0x65, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x19, 0x46, 0x00, 0x00, 0x00, 0x00, 0x32, \
+	0x1C, 0x1A, 0x18, 0x16, 0x14, 0x12, 0x10, \
+	0x0E, 0x0C, 0x0A, 0x08, 0x06, 0x04, 0x02, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0x02,	0x04, 0x06, 0x08, \
+	0x0A, 0x0C, 0x0F, 0x10, 0x12, 0x13, 0x14, \
+	0x18, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, \
+	0x22, 0x24, 0x26, 0x28, 0x29, 0x2A, 0xFF, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
+	0x00, 0x00, 0xB8, 0x01\
+}
+
+/* TODO: define your config for Sensor_ID == 1 here, if needed */
+#define CTP_CFG_GROUP1 {\
+}
+
+/* TODO: define your config for Sensor_ID == 2 here, if needed */
+#define CTP_CFG_GROUP2 {\
+}
+
+/* TODO: define your config for Sensor_ID == 3 here, if needed */
+#define CTP_CFG_GROUP3 {\
+}
+/* TODO: define your config for Sensor_ID == 4 here, if needed */
+#define CTP_CFG_GROUP4 {\
+	0x53,0xD0,0x02,0x00,0x05,0x05,0xF5,0xD5,0x21,0x48,0x2D,0x0F,\
+	0x5A,0x41,0x0E,0x05,0x00,0x00,0x32,0x32,0x20,0x00,0x05,0x14,\
+	0x14,0x1A,0x14,0x8B,0x2B,0x0C,0xB5,0xB7,0xEB,0x04,0xFF,0xFE,\
+	0x00,0x22,0x33,0x10,0x3C,0x80,0x00,0x00,0x00,0x1E,0x12,0x41,\
+	0x23,0x12,0x5A,0xAA,0xBE,0x4A,0x55,0x04,0x00,0x14,0x19,0x04,\
+	0x80,0xAB,0x00,0x7F,0xAF,0x64,0x7E,0xB3,0x00,0x7E,0xB7,0x00,\
+	0x7B,0xBB,0x3C,0x7B,0x08,0x30,0x00,0x00,0xF8,0x70,0x50,0xFF,\
+	0xFF,0x17,0x00,0x46,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,\
+	0x08,0x46,0x80,0x08,0x0A,0x00,0xA0,0x00,0x3C,0x28,0x19,0x19,\
+	0x80,0x11,0x00,0x00,0x18,0x16,0x14,0x12,0x10,0x0E,0x0C,0x0A,\
+	0x08,0x06,0x04,0x02,0xFF,0xFF,0x28,0x00,0x32,0x20,0x00,0x06,\
+	0x00,0x00,0x0A,0x06,0x10,0x08,0x0A,0x22,0xEB,0x04,0x26,0x24,\
+	0x22,0x21,0x20,0x1F,0x1E,0x1D,0x1C,0x18,0x16,0x12,0x10,0x0F,\
+	0x0C,0x0A,0x08,0x06,0x04,0x02,0x00,0x13,0xFF,0xFF,0xFF,0xFF,\
+	0x00,0x00,0x00,0x02,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x28,0x0B,0x0B,0x00,0x00,0x00,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE6,0x10,0xEF,0x01\
+}
+
+/* TODO: define your config for Sensor_ID == 5 here, if needed */
+#define CTP_CFG_GROUP5 {\
+}
+
+/* STEP_2(REQUIRED): Customize your I/O ports & I/O operations */
+#define GTP_RST_PORT    64 /* EXYNOS4_GPX2(0) */
+#define GTP_INT_PORT    65 /* EXYNOS4_GPX2(1) */
+
+#define GTP_GPIO_AS_INPUT(pin)          (gpio_direction_input(pin))
+#define GTP_GPIO_AS_INT(pin)            (GTP_GPIO_AS_INPUT(pin))
+#define GTP_GPIO_GET_VALUE(pin)         gpio_get_value(pin)
+#define GTP_GPIO_OUTPUT(pin, level)      gpio_direction_output(pin, level)
+#define GTP_GPIO_REQUEST(pin, label)    gpio_request(pin, label)
+#define GTP_GPIO_FREE(pin)              gpio_free(pin)
+
+/* STEP_3(optional): Specify your special config info if needed */
+#define GTP_DEFAULT_MAX_X	 720    /* default coordinate max values */
+#define GTP_DEFAULT_MAX_Y	 1080
+#define GTP_DEFAULT_MAX_WIDTH	 1024
+#define GTP_DEFAULT_MAX_PRESSURE 1024
+#define GTP_DEFAULT_INT_TRIGGER	 1 /* 1 rising, 2 falling */
+#define GTP_MAX_TOUCH_ID	 16
+
+/* STEP_4(optional): If keys are available and reported as keys,
+config your key info here */
+#define GTP_KEY_TAB {KEY_MENU, KEY_HOME, KEY_BACK, KEY_HOMEPAGE, \
+	KEY_F1, KEY_F2, KEY_F3}
+
+/**************************PART3:OTHER define*******************************/
+#define GTP_DRIVER_VERSION	"V2.8.0.2<2017/12/14>"
+#define GTP_I2C_NAME		"goodix-ts"
+#define GT91XX_CONFIG_PROC_FILE	"gt9xx_config"
+#define GTP_POLL_TIME		10
+#define GTP_CONFIG_MIN_LENGTH	186
+#define GTP_ESD_CHECK_VALUE	0xAA
+#define RETRY_MAX_TIMES		5
+#define PEN_TRACK_ID		9
+#define MASK_BIT_8		0x80
+#define FAIL			0
+#define SUCCESS			1
+
+/* Registers define */
+#define GTP_REG_COMMAND		0x8040
+#define GTP_REG_ESD_CHECK	0x8041
+#define GTP_REG_COMMAND_CHECK	0x8046
+#define GTP_REG_CONFIG_DATA	0x8047
+#define GTP_REG_VERSION		0x8140
+#define GTP_REG_SENSOR_ID	0x814A
+#define GTP_REG_DOZE_BUF	0x814B
+#define GTP_READ_COOR_ADDR	0x814E
+
+/* Sleep time define */
+#define GTP_1_DLY_MS		1
+#define GTP_2_DLY_MS		2
+#define GTP_10_DLY_MS		10
+#define GTP_20_DLY_MS		20
+#define GTP_50_DLY_MS		50
+#define GTP_58_DLY_MS		58
+#define GTP_100_DLY_MS		100
+#define GTP_500_DLY_MS		500
+#define GTP_1000_DLY_MS		1000
+#define GTP_3000_DLY_MS		3000
+
+#define RESOLUTION_LOC        3
+#define TRIGGER_LOC           8
+
+#define CFG_GROUP_LEN(p_cfg_grp)  (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
+/* Log define */
+#define GTP_DEBUG(fmt, arg...) \
+do { \
+	if (GTP_DEBUG_ON) {\
+		pr_info("<<-GTP-DEBUG->> [%d]"fmt"\n", __LINE__, ##arg);\
+	} \
+} while (0)
+#define GTP_DEBUG_ARRAY(array, num) \
+do { \
+	s32 i;\
+	u8 *a = array;\
+	if (GTP_DEBUG_ARRAY_ON) {\
+		pr_warn("<<-GTP-DEBUG-ARRAY->>\n");\
+		for (i = 0; i < (num); i++) {\
+			pr_warn("%02x  ", (a)[i]);\
+			if ((i + 1) % 10 == 0) {\
+				pr_warn("\n");\
+			} \
+		} \
+		pr_warn("\n");\
+	} \
+} while (0)
+#define GTP_DEBUG_FUNC() \
+do {\
+	if (GTP_DEBUG_FUNC_ON) {\
+		pr_warn("<<-GTP-FUNC->>  Func:%s@Line:%d\n", \
+		__func__, __LINE__);\
+	} \
+} while (0)
+#define GTP_SWAP(x, y) \
+do {\
+	typeof(x) z = x;\
+	x = y;\
+	y = z;\
+} while (0)
+
+/******************************End of Part III********************************/
+#ifdef CONFIG_OF
+extern int gtp_parse_dt_cfg(struct device *dev, u8 *cfg, int *cfg_len, u8 sid);
+#endif
+
+extern void gtp_reset_guitar(struct i2c_client *client, s32 ms);
+extern void gtp_int_sync(struct goodix_ts_data *ts, s32 ms);
+extern void gtp_esd_on(struct goodix_ts_data *ts);
+extern void gtp_esd_off(struct goodix_ts_data *ts);
+extern void gtp_work_control_enable(struct goodix_ts_data *ts, bool enable);
+
+#ifdef CONFIG_TOUCHSCREEN_GT9XX_UPDATE
+extern u16 show_len;
+extern u16 total_len;
+extern u8 gup_init_update_proc(struct goodix_ts_data *);
+extern s32 gup_update_proc(void *dir);
+extern s32 gup_enter_update_mode(struct i2c_client *client);
+extern void gup_leave_update_mode(struct i2c_client *client);
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_GT9XX_TOOL
+extern s32 init_wr_node(struct i2c_client *);
+extern void uninit_wr_node(void);
+#endif
+
+/*********** For gt9xx_update Start *********/
+extern struct i2c_client *i2c_connect_client;
+extern void gtp_reset_guitar(struct i2c_client *client, s32 ms);
+extern void gtp_int_output(struct goodix_ts_data *ts, int level);
+extern s32 gtp_send_cfg(struct i2c_client *client);
+extern s32 gtp_get_fw_info(struct i2c_client *, struct goodix_fw_info *fw_info);
+extern s32 gtp_i2c_read_dbl_check(struct i2c_client *, u16, u8 *, int);
+extern int gtp_i2c_read(struct i2c_client *, u8 *, int);
+extern int gtp_i2c_write(struct i2c_client *, u8 *, int);
+extern s32 gtp_fw_startup(struct i2c_client *client);
+extern int gtp_ascii_to_array(const u8 *src_buf, int src_len, u8 *dst_buf);
+/*********** For gt9xx_update End *********/
+
+#endif /* _GOODIX_GT9XX_H_ */
diff --git a/drivers/input/touchscreen/goodix_gt9xx/gt9xx_update.c b/drivers/input/touchscreen/goodix_gt9xx/gt9xx_update.c
new file mode 100644
index 000000000..9329fde1b
--- /dev/null
+++ b/drivers/input/touchscreen/goodix_gt9xx/gt9xx_update.c
@@ -0,0 +1,2093 @@
+/*
+ * Goodix GT9xx touchscreen driver
+ *
+ * Copyright  (C)  2016 - 2017 Goodix. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be a reference
+ * to you, when you are integrating the GOODiX's CTP IC into your system,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Version: 2.8.0.1
+ * Release Date: 2017/11/24
+ */
+
+#include <linux/kthread.h>
+#include "gt9xx.h"
+
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <linux/firmware.h>
+#include <linux/ctype.h>
+
+#define GUP_REG_HW_INFO		0x4220
+#define GUP_REG_FW_MSG		0x41E4
+#define GUP_REG_PID_VID		0x8140
+
+#define FIRMWARE_NAME_LEN_MAX		256
+#define GOODIX_FIRMWARE_FILE_NAME	"goodix_firmware.bin"
+#define GOODIX_CONFIG_FILE_NAME		"goodix_config.cfg"
+
+#define FW_HEAD_LENGTH			14
+#define FW_SECTION_LENGTH		0x2000	/*  8K */
+#define FW_DSP_ISP_LENGTH		0x1000	/*  4K */
+#define FW_DSP_LENGTH			0x1000	/*  4K */
+#define FW_BOOT_LENGTH			0x800	/*  2K */
+#define FW_SS51_LENGTH		(4 * FW_SECTION_LENGTH)	/*  32K */
+#define FW_BOOT_ISP_LENGTH		0x800	/*  2k */
+#define FW_GLINK_LENGTH			0x3000	/*  12k */
+#define FW_GWAKE_LENGTH		(4 * FW_SECTION_LENGTH) /*  32k */
+
+#define PACK_SIZE			256
+#define MAX_FRAME_CHECK_TIME		5
+
+
+#define _bRW_MISCTL__SRAM_BANK		0x4048
+#define _bRW_MISCTL__MEM_CD_EN		0x4049
+#define _bRW_MISCTL__CACHE_EN		0x404B
+#define _bRW_MISCTL__TMR0_EN		0x40B0
+#define _rRW_MISCTL__SWRST_B0_		0x4180
+#define _bWO_MISCTL__CPU_SWRST_PULSE	0x4184
+#define _rRW_MISCTL__BOOTCTL_B0_	0x4190
+#define _rRW_MISCTL__BOOT_OPT_B0_	0x4218
+#define _rRW_MISCTL__BOOT_CTL_		0x5094
+
+#pragma pack(1)
+struct st_fw_head {
+	u8	hw_info[4];			 /* hardware info */
+	u8	pid[8];				 /* product id */
+	u16 vid;				 /* version id */
+};
+#pragma pack()
+
+struct st_update_msg {
+	u8 fw_damaged;
+	u8 fw_flag;
+	const u8 *fw_data;
+	struct file *cfg_file;
+	struct st_fw_head ic_fw_msg;
+	u32 fw_total_len;
+	u32 fw_burned_len;
+	const struct firmware *fw;
+} update_msg;
+
+struct st_update_msg update_msg;
+
+u16 show_len;
+u16 total_len;
+
+static u8 gup_burn_fw_gwake_section(struct i2c_client *client,
+				    u8 *fw_section, u16 start_addr,
+				    u32 len, u8 bank_cmd);
+
+static s32 gup_init_panel(struct goodix_ts_data *ts)
+{
+	s32 ret = 0;
+	u8 opr_buf[16];
+	u8 sensor_id = 0;
+	u8 drv_cfg_version;
+	u8 flash_cfg_version;
+	struct goodix_config_data *cfg = &ts->pdata->config;
+
+	if (cfg->length < GTP_CONFIG_MIN_LENGTH) {
+		dev_err(&ts->client->dev,
+			"No valid config with sensor_ID(%d) ",
+			sensor_id);
+
+		return -EPERM;
+	}
+
+	ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CONFIG_DATA,
+				     &opr_buf[0], 1);
+	if (ret == SUCCESS) {
+		dev_dbg(&ts->client->dev,
+			"CFG_GROUP%d Config Version: %d, IC Config Version: %d",
+			sensor_id, cfg->data[GTP_ADDR_LENGTH], opr_buf[0]);
+
+		flash_cfg_version = opr_buf[0];
+		drv_cfg_version = cfg->data[GTP_ADDR_LENGTH];
+
+		if (flash_cfg_version < 90 &&
+		    flash_cfg_version > drv_cfg_version)
+			cfg->data[GTP_ADDR_LENGTH] = 0x00;
+	} else {
+		dev_err(&ts->client->dev,
+			"Failed to get ic config version!No config sent!");
+		return -EPERM;
+	}
+
+	ret = gtp_send_cfg(ts->client);
+	if (ret < 0)
+		dev_err(&ts->client->dev, "Send config error.");
+	else
+		usleep_range(10000, 11000);
+
+	/* restore config vrsion */
+	cfg->data[GTP_ADDR_LENGTH] = drv_cfg_version;
+
+	return 0;
+}
+
+
+static u8 gup_get_ic_msg(struct i2c_client *client, u16 addr, u8 *msg, s32 len)
+{
+	s32 i = 0;
+
+	msg[0] = (addr >> 8) & 0xff;
+	msg[1] = addr & 0xff;
+
+	for (i = 0; i < 5; i++) {
+		if (gtp_i2c_read(client, msg, GTP_ADDR_LENGTH + len) > 0)
+			break;
+	}
+
+	if (i >= 5) {
+		dev_err(&client->dev,
+				"Read data from 0x%02x%02x failed!",
+				msg[0], msg[1]);
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+static u8 gup_set_ic_msg(struct i2c_client *client, u16 addr, u8 val)
+{
+	s32 i = 0;
+	u8 msg[3];
+
+	msg[0] = (addr >> 8) & 0xff;
+	msg[1] = addr & 0xff;
+	msg[2] = val;
+
+	for (i = 0; i < 5; i++) {
+		if (gtp_i2c_write(client, msg, GTP_ADDR_LENGTH + 1) > 0)
+			break;
+	}
+
+	if (i >= 5) {
+		dev_err(&client->dev,
+			"Set data to 0x%02x%02x failed!", msg[0], msg[1]);
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+static u8 gup_get_ic_fw_msg(struct i2c_client *client)
+{
+	s32 ret = -1;
+	u8	retry = 0;
+	u8	buf[16];
+	u8	i;
+
+	/*  step1:get hardware info */
+	ret = gtp_i2c_read_dbl_check(client, GUP_REG_HW_INFO,
+				     &buf[GTP_ADDR_LENGTH], 4);
+	if (FAIL == ret) {
+		dev_err(&client->dev, "[get_ic_fw_msg]get hw_info failed,exit");
+		return FAIL;
+	}
+
+	/*  buf[2~5]: 00 06 90 00
+	 *  hw_info: 00 90 06 00
+	 */
+	for (i = 0; i < 4; i++) {
+		update_msg.ic_fw_msg.hw_info[i] = buf[GTP_ADDR_LENGTH + 3 - i];
+	}
+	dev_dbg(&client->dev,
+		"IC Hardware info:%02x%02x%02x%02x",
+		update_msg.ic_fw_msg.hw_info[0],
+		update_msg.ic_fw_msg.hw_info[1],
+		update_msg.ic_fw_msg.hw_info[2],
+		update_msg.ic_fw_msg.hw_info[3]);
+	/*  step2:get firmware message */
+	for (retry = 0; retry < 2; retry++) {
+		ret = gup_get_ic_msg(client, GUP_REG_FW_MSG, buf, 1);
+		if (FAIL == ret) {
+			dev_err(&client->dev, "Read firmware message fail.");
+			return ret;
+		}
+
+		update_msg.fw_damaged = buf[GTP_ADDR_LENGTH];
+		if ((0xBE != update_msg.fw_damaged) && (!retry)) {
+			dev_info(&client->dev, "The check sum in ic is error.");
+			dev_info(&client->dev, "The IC will be updated by force.");
+			continue;
+		}
+		break;
+	}
+	dev_dbg(&client->dev,
+		"IC force update flag:0x%x", update_msg.fw_damaged);
+
+	/*  step3:get pid & vid */
+	ret = gtp_i2c_read_dbl_check(client, GUP_REG_PID_VID,
+				     &buf[GTP_ADDR_LENGTH], 6);
+	if (FAIL == ret) {
+		dev_err(&client->dev, "[get_ic_fw_msg]get pid & vid failed,exit");
+		return FAIL;
+	}
+
+	memset(update_msg.ic_fw_msg.pid, 0, sizeof(update_msg.ic_fw_msg.pid));
+	memcpy(update_msg.ic_fw_msg.pid, &buf[GTP_ADDR_LENGTH], 4);
+	dev_dbg(&client->dev, "IC Product id:%s", update_msg.ic_fw_msg.pid);
+
+	/* GT9XX PID MAPPING */
+	/*|-----FLASH-----RAM-----|
+	 *|------918------918-----|
+	 *|------968------968-----|
+	 *|------913------913-----|
+	 *|------913P-----913P----|
+	 *|------927------927-----|
+	 *|------927P-----927P----|
+	 *|------9110-----9110----|
+	 *|------9110P----9111----|*/
+	if (update_msg.ic_fw_msg.pid[0] != 0) {
+		if (!memcmp(update_msg.ic_fw_msg.pid, "9111", 4)) {
+			dev_dbg(&client->dev, "IC Mapping Product id:%s",
+					update_msg.ic_fw_msg.pid);
+			memcpy(update_msg.ic_fw_msg.pid, "9110P", 5);
+		}
+	}
+
+	update_msg.ic_fw_msg.vid = buf[GTP_ADDR_LENGTH + 4] +
+				   (buf[GTP_ADDR_LENGTH + 5] << 8);
+	dev_dbg(&client->dev, "IC version id:%04x", update_msg.ic_fw_msg.vid);
+
+	return SUCCESS;
+}
+
+s32 gup_enter_update_mode(struct i2c_client *client)
+{
+	s32 ret = -1;
+	s32 retry = 0;
+	u8 rd_buf[3];
+
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	/* step1:RST output low last at least 2ms */
+	if (!gpio_is_valid(ts->pdata->rst_gpio)) {
+		dev_err(&ts->client->dev, "update failed, no rst pin\n");
+		return FAIL;
+	}
+	gpio_direction_output(ts->pdata->rst_gpio, 0);
+	usleep_range(2000, 3000);
+
+	/* step2:select I2C slave addr,INT:0--0xBA;1--0x28. */
+	gtp_int_output(ts, client->addr == 0x14);
+	usleep_range(2000, 3000);
+
+	/* step3:RST output high reset guitar */
+	gpio_direction_output(ts->pdata->rst_gpio, 1);
+
+	/* 20121211 modify start */
+	usleep_range(5000, 6000);
+	while (retry++ < 200) {
+		/* step4:Hold ss51 & dsp */
+		ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+		if (ret <= 0) {
+			dev_dbg(&client->dev,
+				"Hold ss51 & dsp I2C error,retry:%d",
+				retry);
+			continue;
+		}
+
+		/* step5:Confirm hold */
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__SWRST_B0_, rd_buf, 1);
+		if (ret <= 0) {
+			dev_dbg(&client->dev,
+				"Hold ss51 & dsp I2C error,retry:%d",
+				retry);
+			continue;
+		}
+		if (0x0C == rd_buf[GTP_ADDR_LENGTH]) {
+			dev_dbg(&client->dev, "Hold ss51 & dsp confirm SUCCESS");
+			break;
+		}
+		dev_dbg(&client->dev,
+			"Hold ss51 & dsp confirm 0x4180 failed,value:%d",
+			rd_buf[GTP_ADDR_LENGTH]);
+	}
+	if (retry >= 200) {
+		dev_err(&client->dev, "Enter update Hold ss51 failed.");
+		return FAIL;
+	}
+
+	/* step6:DSP_CK and DSP_ALU_CK PowerOn */
+	ret = gup_set_ic_msg(client, 0x4010, 0x00);
+
+	/* 20121211 modify end */
+	return ret;
+}
+
+void gup_leave_update_mode(struct i2c_client *client)
+{
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->pdata->int_sync && ts->pinctrl.pinctrl)
+		pinctrl_select_state(ts->pinctrl.pinctrl,
+				     ts->pinctrl.int_input);
+	else if (ts->pdata->int_sync && gpio_is_valid(ts->pdata->irq_gpio))
+		gpio_direction_input(ts->pdata->irq_gpio);
+	dev_dbg(&client->dev, "[leave_update_mode]reset chip.");
+	gtp_reset_guitar(i2c_connect_client, 20);
+}
+
+static u8 gup_enter_update_judge(struct i2c_client *client,
+				 struct st_fw_head *fw_head)
+{
+	u16 u16_tmp;
+	s32 i = 0;
+	u32 fw_len = 0;
+	s32 pid_cmp_len = 0;
+
+	u16_tmp = fw_head->vid;
+	fw_head->vid = (u16)(u16_tmp>>8) + (u16)(u16_tmp<<8);
+
+	dev_info(&client->dev, "FILE HARDWARE INFO:%*ph\n", 4,
+		 &fw_head->hw_info[0]);
+	dev_info(&client->dev, "FILE PID:%s\n", fw_head->pid);
+	dev_info(&client->dev, "FILE VID:%04x\n", fw_head->vid);
+
+	dev_info(&client->dev, "IC HARDWARE INFO:%*ph\n", 4,
+		 &update_msg.ic_fw_msg.hw_info[0]);
+	dev_info(&client->dev, "IC PID:%s\n", update_msg.ic_fw_msg.pid);
+	dev_info(&client->dev, "IC VID:%04x\n", update_msg.ic_fw_msg.vid);
+
+	if (!memcmp(fw_head->pid, "9158", 4) &&
+	    !memcmp(update_msg.ic_fw_msg.pid, "915S", 4)) {
+		dev_info(&client->dev, "Update GT915S to GT9158 directly!");
+		return SUCCESS;
+	}
+	/* First two conditions */
+	if (!memcmp(fw_head->hw_info, update_msg.ic_fw_msg.hw_info,
+	sizeof(update_msg.ic_fw_msg.hw_info))) {
+		fw_len = 42 * 1024;
+	} else {
+		fw_len = fw_head->hw_info[3];
+		fw_len += (((u32)fw_head->hw_info[2]) << 8);
+		fw_len += (((u32)fw_head->hw_info[1]) << 16);
+		fw_len += (((u32)fw_head->hw_info[0]) << 24);
+	}
+	if (update_msg.fw_total_len != fw_len) {
+		dev_err(&client->dev,
+			"Inconsistent firmware size, Update aborted!");
+		dev_err(&client->dev,
+			" Default size: %d(%dK), actual size: %d(%dK)",
+			fw_len, fw_len/1024, update_msg.fw_total_len,
+			update_msg.fw_total_len/1024);
+		return FAIL;
+	}
+	dev_info(&client->dev, "Firmware length:%d(%dK)",
+		 update_msg.fw_total_len,
+		 update_msg.fw_total_len/1024);
+
+	if (update_msg.fw_damaged != 0xBE) {
+		dev_info(&client->dev, "FW chksum error,need enter update.");
+		return SUCCESS;
+	}
+
+	/*  20130523 start */
+	if (strlen(update_msg.ic_fw_msg.pid) < 3) {
+		dev_info(&client->dev, "Illegal IC pid, need enter update");
+		return SUCCESS;
+	}
+
+	/* check pid legality */
+	for (i = 0; i < 3; i++) {
+		if (!isdigit(update_msg.ic_fw_msg.pid[i])) {
+			dev_info(&client->dev,
+				 "Illegal IC pid, need enter update");
+			return SUCCESS;
+		}
+	}
+	/*  20130523 end */
+
+	pid_cmp_len = strlen(fw_head->pid);
+	if (pid_cmp_len < strlen(update_msg.ic_fw_msg.pid))
+		pid_cmp_len = strlen(update_msg.ic_fw_msg.pid);
+
+	if ((!memcmp(fw_head->pid, update_msg.ic_fw_msg.pid, pid_cmp_len)) ||
+			(!memcmp(update_msg.ic_fw_msg.pid, "91XX", 4)) ||
+			(!memcmp(fw_head->pid, "91XX", 4))) {
+		if (!memcmp(fw_head->pid, "91XX", 4))
+			dev_dbg(&client->dev,
+				"Force none same pid update mode.");
+		else
+			dev_dbg(&client->dev, "Get the same pid.");
+
+		/* The third condition */
+		if (fw_head->vid != update_msg.ic_fw_msg.vid) {
+			dev_info(&client->dev, "Need enter update.");
+			return SUCCESS;
+		}
+		dev_err(&client->dev, "File VID == Ic VID, update aborted!");
+	} else {
+		dev_err(&client->dev, "File PID != Ic PID, update aborted!");
+	}
+
+	return FAIL;
+}
+
+static int gup_update_config(struct i2c_client *client)
+{
+	s32 ret = 0;
+	s32 i = 0;
+	s32 file_cfg_len = 0;
+	u8 *file_config;
+	const struct firmware *fw_cfg;
+
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	ret = request_firmware(&fw_cfg, GOODIX_CONFIG_FILE_NAME,
+			       &client->dev);
+	if (ret < 0) {
+		dev_err(&client->dev,
+			"Cannot get config file - %s (%d)\n",
+			GOODIX_CONFIG_FILE_NAME, ret);
+		return -EFAULT;
+	}
+	if (!fw_cfg || !fw_cfg->data || fw_cfg->size > PAGE_SIZE) {
+		dev_err(&client->dev, "config file illegal");
+		ret = -EFAULT;
+		goto cfg_fw_err;
+	}
+
+	dev_dbg(&client->dev, "config firmware file len:%zu", fw_cfg->size);
+
+	file_config = kzalloc(GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH,
+			      GFP_KERNEL);
+	if (!file_config) {
+		dev_err(&ts->client->dev, "failed alloc memory");
+		ret = -ENOMEM;
+		goto cfg_fw_err;
+	}
+	file_config[0] = GTP_REG_CONFIG_DATA >> 8;
+	file_config[1] = GTP_REG_CONFIG_DATA & 0xff;
+	file_cfg_len = gtp_ascii_to_array(fw_cfg->data, fw_cfg->size,
+					  &file_config[GTP_ADDR_LENGTH]);
+	if (file_cfg_len < 0) {
+		dev_err(&client->dev, "failed covert ascii to hex");
+		ret = -EFAULT;
+		goto update_cfg_file_failed;
+	}
+
+	GTP_DEBUG_ARRAY(file_config + GTP_ADDR_LENGTH, file_cfg_len);
+
+	i = 0;
+	while (i++ < 5) {
+		ret = gtp_i2c_write(client, file_config, file_cfg_len + 2);
+		if (ret > 0) {
+			dev_info(&client->dev, "Send config SUCCESS.");
+			msleep(500);
+			break;
+		}
+		dev_err(&ts->client->dev, "Send config i2c error.");
+	}
+
+update_cfg_file_failed:
+	kfree(file_config);
+cfg_fw_err:
+	release_firmware(fw_cfg);
+	return ret;
+}
+
+static u8 gup_check_firmware_name(struct i2c_client *client,
+		u8 **path_p)
+{
+	u8 len;
+	u8 *fname;
+
+	if (!(*path_p)) {
+		*path_p = GOODIX_FIRMWARE_FILE_NAME;
+		return 0;
+	}
+
+	len = strnlen(*path_p, FIRMWARE_NAME_LEN_MAX);
+	if (len >= FIRMWARE_NAME_LEN_MAX) {
+		dev_err(&client->dev, "firmware name too long!");
+		return -EINVAL;
+	}
+
+	fname = strrchr(*path_p, '/');
+	if (fname) {
+		fname = fname + 1;
+		*path_p = fname;
+	}
+
+	return 0;
+}
+
+static u8 gup_get_update_file(struct i2c_client *client,
+				struct st_fw_head *fw_head, u8 *path)
+{
+	s32 ret = 0;
+	s32 i = 0;
+	s32 fw_checksum = 0;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->pdata->auto_update_cfg) {
+		ret = gup_update_config(client);
+		if (ret <= 0)
+			dev_err(&client->dev, "Update config failed.");
+	}
+
+	ret = gup_check_firmware_name(client, &path);
+	if (ret < 0)
+		return FAIL;
+
+	ret = request_firmware(&update_msg.fw, path, &client->dev);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed get firmware:%d\n", ret);
+		return FAIL;
+	}
+
+	dev_info(&client->dev, "FW File: %s size=%zu",
+		 path, update_msg.fw->size);
+	update_msg.fw_data = update_msg.fw->data;
+	update_msg.fw_total_len = update_msg.fw->size;
+
+	if (update_msg.fw_total_len <
+	    FW_HEAD_LENGTH + FW_SECTION_LENGTH * 4 + FW_DSP_ISP_LENGTH +
+	    FW_DSP_LENGTH + FW_BOOT_LENGTH) {
+		dev_err(&client->dev,
+			"INVALID bin file(size: %d), update aborted.",
+			update_msg.fw_total_len);
+		goto invalied_fw;
+	}
+
+	update_msg.fw_total_len -= FW_HEAD_LENGTH;
+
+	dev_dbg(&client->dev, "Bin firmware actual size: %d(%dK)",
+		update_msg.fw_total_len, update_msg.fw_total_len/1024);
+
+	memcpy(fw_head, update_msg.fw_data, FW_HEAD_LENGTH);
+
+	/* check firmware legality */
+	fw_checksum = 0;
+	for (i = 0; i < update_msg.fw_total_len; i += 2) {
+		u16 temp;
+
+		temp = (update_msg.fw_data[FW_HEAD_LENGTH + i] << 8) +
+			update_msg.fw_data[FW_HEAD_LENGTH + i + 1];
+		fw_checksum += temp;
+	}
+
+	dev_dbg(&client->dev, "firmware checksum:%x", fw_checksum&0xFFFF);
+	if (fw_checksum & 0xFFFF) {
+		dev_err(&client->dev, "Illegal firmware file.");
+		goto invalied_fw;
+	}
+
+	return SUCCESS;
+
+invalied_fw:
+	update_msg.fw_data = NULL;
+	update_msg.fw_total_len = 0;
+	release_firmware(update_msg.fw);
+	return FAIL;
+}
+
+static u8 gup_burn_proc(struct i2c_client *client, u8 *burn_buf,
+		u16 start_addr, u16 total_length)
+{
+	s32 ret = 0;
+	u16 burn_addr = start_addr;
+	u16 frame_length = 0;
+	u16 burn_length = 0;
+	u8 wr_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+	u8 rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+	u8 retry = 0;
+
+	dev_dbg(&client->dev, "Begin burn %dk data to addr 0x%x",
+		total_length / 1024, start_addr);
+	while (burn_length < total_length) {
+		dev_dbg(&client->dev,
+			"B/T:%04d/%04d", burn_length, total_length);
+		frame_length = ((total_length - burn_length)
+		> PACK_SIZE) ? PACK_SIZE : (total_length - burn_length);
+		wr_buf[0] = (u8)(burn_addr>>8);
+		rd_buf[0] = wr_buf[0];
+		wr_buf[1] = (u8)burn_addr;
+		rd_buf[1] = wr_buf[1];
+		memcpy(&wr_buf[GTP_ADDR_LENGTH],
+		&burn_buf[burn_length], frame_length);
+
+		for (retry = 0; retry < MAX_FRAME_CHECK_TIME; retry++) {
+			ret = gtp_i2c_write(client,
+			wr_buf, GTP_ADDR_LENGTH + frame_length);
+			if (ret <= 0) {
+				dev_err(&client->dev,
+					"Write frame data i2c error.");
+				continue;
+			}
+			ret = gtp_i2c_read(client, rd_buf,
+					   GTP_ADDR_LENGTH + frame_length);
+			if (ret <= 0) {
+				dev_err(&client->dev,
+					"Read back frame data i2c error.");
+				continue;
+			}
+			if (memcmp(&wr_buf[GTP_ADDR_LENGTH],
+				&rd_buf[GTP_ADDR_LENGTH], frame_length)) {
+				dev_err(&client->dev,
+					"Check frame data fail,not equal.");
+				dev_dbg(&client->dev, "write array:");
+				GTP_DEBUG_ARRAY(&wr_buf[GTP_ADDR_LENGTH],
+				frame_length);
+				dev_dbg(&client->dev, "read array:");
+				GTP_DEBUG_ARRAY(&rd_buf[GTP_ADDR_LENGTH],
+				frame_length);
+				continue;
+			} else {
+				/* dev_dbg(&client->dev,
+				 * "Check frame data success.");
+				 */
+				break;
+			}
+		}
+		if (retry >= MAX_FRAME_CHECK_TIME) {
+			dev_err(&client->dev,
+				"Burn frame data time out,exit.");
+			return FAIL;
+		}
+		burn_length += frame_length;
+		burn_addr += frame_length;
+	}
+
+	return SUCCESS;
+}
+
+static u8 gup_load_section_file(u8 *buf, u32 offset, u16 length, u8 set_or_end)
+{
+	if (!update_msg.fw_data ||
+	    update_msg.fw_total_len < offset + length) {
+		dev_err(&i2c_connect_client->dev,
+			"cannot load section data. fw_len=%d read end=%d\n",
+			update_msg.fw_total_len,
+			FW_HEAD_LENGTH + offset + length);
+		return FAIL;
+	}
+
+	if (SEEK_SET == set_or_end) {
+		memcpy(buf, &update_msg.fw_data[FW_HEAD_LENGTH + offset],
+		       length);
+	} else {
+		/* seek end */
+		memcpy(buf, &update_msg.fw_data[update_msg.fw_total_len +
+		       FW_HEAD_LENGTH - offset], length);
+	}
+
+	return SUCCESS;
+}
+
+static u8 gup_recall_check(struct i2c_client *client, u8 *chk_src,
+			   u16 start_rd_addr, u16 chk_length)
+{
+	u8 rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+	s32 ret = 0;
+	u16 recall_addr = start_rd_addr;
+	u16 recall_length = 0;
+	u16 frame_length = 0;
+
+	while (recall_length < chk_length) {
+		frame_length = ((chk_length - recall_length)
+				> PACK_SIZE) ? PACK_SIZE :
+				(chk_length - recall_length);
+		ret = gup_get_ic_msg(client, recall_addr, rd_buf, frame_length);
+		if (ret <= 0) {
+			dev_err(&client->dev, "recall i2c error,exit");
+			return FAIL;
+		}
+
+		if (memcmp(&rd_buf[GTP_ADDR_LENGTH],
+		&chk_src[recall_length], frame_length)) {
+			dev_err(&client->dev, "Recall frame data fail,not equal.");
+			dev_dbg(&client->dev, "chk_src array:");
+			GTP_DEBUG_ARRAY(&chk_src[recall_length], frame_length);
+			dev_dbg(&client->dev, "recall array:");
+			GTP_DEBUG_ARRAY(&rd_buf[GTP_ADDR_LENGTH], frame_length);
+			return FAIL;
+		}
+
+		recall_length += frame_length;
+		recall_addr += frame_length;
+	}
+	dev_dbg(&client->dev,
+			"Recall check %dk firmware success.",
+			(chk_length/1024));
+
+	return SUCCESS;
+}
+
+static u8 gup_burn_fw_section(struct i2c_client *client, u8 *fw_section,
+			      u16 start_addr, u8 bank_cmd)
+{
+	s32 ret = 0;
+	u8	rd_buf[5];
+
+	/* step1:hold ss51 & dsp */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_section]hold ss51 & dsp fail.");
+		return FAIL;
+	}
+
+	/* step2:set scramble */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_section]set scramble fail.");
+		return FAIL;
+	}
+
+	/* step3:select bank */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK,
+	(bank_cmd >> 4)&0x0F);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_section]select bank %d fail.",
+			(bank_cmd >> 4)&0x0F);
+		return FAIL;
+	}
+
+	/* step4:enable accessing code */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_section]enable accessing code fail.");
+		return FAIL;
+	}
+
+	/* step5:burn 8k fw section */
+	ret = gup_burn_proc(client, fw_section, start_addr, FW_SECTION_LENGTH);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_section]burn fw_section fail.");
+		return FAIL;
+	}
+
+	/* step6:hold ss51 & release dsp */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_section]hold ss51 & release dsp fail.");
+		return FAIL;
+	}
+	/* must delay */
+	usleep_range(1000, 2000);
+
+	/* step7:send burn cmd to move data to flash from sram */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd&0x0f);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_section]send burn cmd fail.");
+		return FAIL;
+	}
+	dev_dbg(&client->dev,
+		"[burn_fw_section]Wait for the burn is complete......");
+	do {
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+		if (ret <= 0) {
+			dev_err(&client->dev,
+				"[burn_fw_section]Get burn state fail");
+			return FAIL;
+		}
+		usleep_range(10000, 11000);
+	/* dev_dbg(&client->dev, "[burn_fw_section]Get burn state:%d.",
+	 * rd_buf[GTP_ADDR_LENGTH]);
+	 */
+	} while (rd_buf[GTP_ADDR_LENGTH]);
+
+	/* step8:select bank */
+	ret = gup_set_ic_msg(client,
+			     _bRW_MISCTL__SRAM_BANK, (bank_cmd >> 4) & 0x0F);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_section]select bank %d fail.",
+			(bank_cmd >> 4)&0x0F);
+		return FAIL;
+	}
+
+	/* step9:enable accessing code */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_section]enable accessing code fail.");
+		return FAIL;
+	}
+
+	/* step10:recall 8k fw section */
+	ret = gup_recall_check(client,
+	fw_section, start_addr, FW_SECTION_LENGTH);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_section]recall check %dk firmware fail.",
+			FW_SECTION_LENGTH / 1024);
+		return FAIL;
+	}
+
+	/* step11:disable accessing code */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_section]disable accessing code fail.");
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+static u8 gup_burn_dsp_isp(struct i2c_client *client)
+{
+	s32 ret = 0;
+	u8 *fw_dsp_isp = NULL;
+	u8	retry = 0;
+
+	dev_info(&client->dev, "[burn_dsp_isp]Begin burn dsp isp---->>");
+
+	/* step1:alloc memory */
+	dev_dbg(&client->dev, "[burn_dsp_isp]step1:alloc memory");
+	while (retry++ < 5) {
+		fw_dsp_isp = kzalloc(FW_DSP_ISP_LENGTH, GFP_KERNEL);
+		if (fw_dsp_isp == NULL) {
+			continue;
+		} else {
+			dev_info(&client->dev,
+				"[burn_dsp_isp]Alloc %dk byte memory success.",
+				FW_DSP_ISP_LENGTH / 1024);
+			break;
+		}
+	}
+	if (retry >= 5) {
+		dev_err(&client->dev, "[burn_dsp_isp]Alloc memory fail,exit.");
+		return FAIL;
+	}
+
+	/* step2:load dsp isp file data */
+	dev_dbg(&client->dev, "[burn_dsp_isp]step2:load dsp isp file data");
+	ret = gup_load_section_file(fw_dsp_isp, FW_DSP_ISP_LENGTH,
+				    FW_DSP_ISP_LENGTH, SEEK_END);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_dsp_isp]load firmware dsp_isp fail.");
+		goto exit_burn_dsp_isp;
+	}
+
+	/* step3:disable wdt,clear cache enable */
+	dev_dbg(&client->dev,
+		"[burn_dsp_isp]step3:disable wdt,clear cache enable");
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__TMR0_EN, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_dsp_isp]disable wdt fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
+	}
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__CACHE_EN, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_dsp_isp]clear cache enable fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
+	}
+
+	/* step4:hold ss51 & dsp */
+	dev_dbg(&client->dev, "[burn_dsp_isp]step4:hold ss51 & dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_dsp_isp]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
+	}
+
+	/* step5:set boot from sram */
+	dev_dbg(&client->dev, "[burn_dsp_isp]step5:set boot from sram");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_dsp_isp]set boot from sram fail");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
+	}
+
+	/* step6:software reboot */
+	dev_dbg(&client->dev, "[burn_dsp_isp]step6:software reboot");
+	ret = gup_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_dsp_isp]software reboot fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
+	}
+
+	/* step7:select bank2 */
+	dev_dbg(&client->dev, "[burn_dsp_isp]step7:select bank2");
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x02);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_dsp_isp]select bank2 fail");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
+	}
+
+	/* step8:enable accessing code */
+	dev_dbg(&client->dev, "[burn_dsp_isp]step8:enable accessing code");
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_dsp_isp]enable accessing code fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
+	}
+
+	/* step9:burn 4k dsp_isp */
+	dev_dbg(&client->dev, "[burn_dsp_isp]step9:burn 4k dsp_isp");
+	ret = gup_burn_proc(client, fw_dsp_isp, 0xC000, FW_DSP_ISP_LENGTH);
+	if (FAIL == ret) {
+		dev_err(&client->dev, "[burn_dsp_isp]burn dsp_isp fail.");
+		goto exit_burn_dsp_isp;
+	}
+
+	/* step10:set scramble */
+	dev_dbg(&client->dev, "[burn_dsp_isp]step10:set scramble");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_dsp_isp]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
+	}
+	update_msg.fw_burned_len += FW_DSP_ISP_LENGTH;
+	dev_dbg(&client->dev, "[burn_dsp_isp]Burned length:%d",
+			update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_dsp_isp:
+	kfree(fw_dsp_isp);
+
+	return ret;
+}
+
+static u8 gup_burn_fw_ss51(struct i2c_client *client)
+{
+	u8 *fw_ss51 = NULL;
+	u8	retry = 0;
+	s32 ret = 0;
+
+	dev_info(&client->dev, "[burn_fw_ss51]Begin burn ss51 firmware---->>");
+
+	/* step1:alloc memory */
+	dev_dbg(&client->dev, "[burn_fw_ss51]step1:alloc memory");
+	while (retry++ < 5) {
+		fw_ss51 = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_ss51 == NULL) {
+			continue;
+		} else {
+			dev_dbg(&client->dev,
+				"[burn_fw_ss51]Alloc %dk byte memory success.",
+				(FW_SECTION_LENGTH / 1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		dev_err(&client->dev, "[burn_fw_ss51]Alloc memory fail,exit.");
+		return FAIL;
+	}
+
+	dev_info(&client->dev, "[burn_fw_ss51]Reset first 8K of ss51 to 0xFF.");
+	dev_dbg(&client->dev, "[burn_fw_ss51]step2: reset bank0 0xC000~0xD000");
+	memset(fw_ss51, 0xFF, FW_SECTION_LENGTH);
+
+	/* step3:clear control flag */
+	dev_dbg(&client->dev, "[burn_fw_ss51]step3:clear control flag");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_ss51]clear control flag fail.");
+		ret = FAIL;
+		goto exit_burn_fw_ss51;
+	}
+
+	/* step4:burn ss51 firmware section 1 */
+	dev_dbg(&client->dev,
+		"[burn_fw_ss51]step4:burn ss51 firmware section 1");
+	ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x01);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_ss51]burn ss51 firmware section 1 fail.");
+		goto exit_burn_fw_ss51;
+	}
+
+	/* step5:load ss51 firmware section 2 file data */
+	dev_dbg(&client->dev,
+		"[burn_fw_ss51]step5:load ss51 firmware section 2 file data");
+	ret = gup_load_section_file(fw_ss51, FW_SECTION_LENGTH,
+				    FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_ss51]load ss51 firmware section 2 fail.");
+		goto exit_burn_fw_ss51;
+	}
+
+	/* step6:burn ss51 firmware section 2 */
+	dev_dbg(&client->dev,
+		"[burn_fw_ss51]step6:burn ss51 firmware section 2");
+	ret = gup_burn_fw_section(client, fw_ss51, 0xE000, 0x02);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_ss51]burn ss51 firmware section 2 fail.");
+		goto exit_burn_fw_ss51;
+	}
+
+	/* step7:load ss51 firmware section 3 file data */
+	dev_dbg(&client->dev,
+		"[burn_fw_ss51]step7:load ss51 firmware section 3 file data");
+	ret = gup_load_section_file(fw_ss51, 2 * FW_SECTION_LENGTH,
+				    FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_ss51]load ss51 firmware section 3 fail.");
+		goto exit_burn_fw_ss51;
+	}
+
+	/* step8:burn ss51 firmware section 3 */
+	dev_dbg(&client->dev,
+		"[burn_fw_ss51]step8:burn ss51 firmware section 3");
+	ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x13);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_ss51]burn ss51 firmware section 3 fail.");
+		goto exit_burn_fw_ss51;
+	}
+
+	/* step9:load ss51 firmware section 4 file data */
+	dev_dbg(&client->dev,
+		"[burn_fw_ss51]step9:load ss51 firmware section 4 file data");
+	ret = gup_load_section_file(fw_ss51, 3 * FW_SECTION_LENGTH,
+				    FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_ss51]load ss51 firmware section 4 fail.");
+		goto exit_burn_fw_ss51;
+	}
+
+	/* step10:burn ss51 firmware section 4 */
+	dev_dbg(&client->dev,
+		"[burn_fw_ss51]step10:burn ss51 firmware section 4");
+	ret = gup_burn_fw_section(client, fw_ss51, 0xE000, 0x14);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_ss51]burn ss51 firmware section 4 fail.");
+		goto exit_burn_fw_ss51;
+	}
+
+	update_msg.fw_burned_len += (FW_SECTION_LENGTH*4);
+	dev_dbg(&client->dev, "[burn_fw_ss51]Burned length:%d",
+		update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_ss51:
+	kfree(fw_ss51);
+	return ret;
+}
+
+static u8 gup_burn_fw_dsp(struct i2c_client *client)
+{
+	s32 ret = 0;
+	u8 *fw_dsp = NULL;
+	u8 retry = 0;
+	u8 rd_buf[5];
+
+	dev_info(&client->dev, "[burn_fw_dsp]Begin burn dsp firmware---->>");
+	/* step1:alloc memory */
+	dev_dbg(&client->dev, "[burn_fw_dsp]step1:alloc memory");
+	while (retry++ < 5) {
+		fw_dsp = kzalloc(FW_DSP_LENGTH, GFP_KERNEL);
+		if (fw_dsp == NULL) {
+			continue;
+		} else {
+			dev_dbg(&client->dev,
+				"[burn_fw_dsp]Alloc %dk byte memory success.",
+				FW_SECTION_LENGTH / 1024);
+			break;
+		}
+	}
+	if (retry >= 5) {
+		dev_err(&client->dev, "[burn_fw_dsp]Alloc memory fail,exit.");
+		return FAIL;
+	}
+
+	/* step2:load firmware dsp */
+	dev_dbg(&client->dev, "[burn_fw_dsp]step2:load firmware dsp");
+	ret = gup_load_section_file(fw_dsp, 4 * FW_SECTION_LENGTH,
+				    FW_DSP_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev, "[burn_fw_dsp]load firmware dsp fail.");
+		goto exit_burn_fw_dsp;
+	}
+
+	/* step3:select bank3 */
+	dev_dbg(&client->dev, "[burn_fw_dsp]step3:select bank3");
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_dsp]select bank3 fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
+	}
+
+	/* step4:hold ss51 & dsp */
+	dev_dbg(&client->dev, "[burn_fw_dsp]step4:hold ss51 & dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_dsp]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
+	}
+
+	/* step5:set scramble */
+	dev_dbg(&client->dev, "[burn_fw_dsp]step5:set scramble");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_dsp]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
+	}
+
+	/* step6:release ss51 & dsp */
+	dev_dbg(&client->dev, "[burn_fw_dsp]step6:release ss51 & dsp");
+	ret = gup_set_ic_msg(
+	client, _rRW_MISCTL__SWRST_B0_, 0x04);/* 20121211 */
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_dsp]release ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
+	}
+	/* must delay */
+	usleep_range(1000, 1100);
+
+	/* step7:burn 4k dsp firmware */
+	dev_dbg(&client->dev, "[burn_fw_dsp]step7:burn 4k dsp firmware");
+	ret = gup_burn_proc(client, fw_dsp, 0x9000, FW_DSP_LENGTH);
+	if (FAIL == ret) {
+		dev_err(&client->dev, "[burn_fw_dsp]burn fw_section fail.");
+		goto exit_burn_fw_dsp;
+	}
+
+	/* step8:send burn cmd to move data to flash from sram */
+	dev_dbg(&client->dev,
+	"[burn_fw_dsp]step8:send burn cmd to move data to flash from sram");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x05);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_dsp]send burn cmd fail.");
+		goto exit_burn_fw_dsp;
+	}
+	dev_dbg(&client->dev, "[burn_fw_dsp]Wait for the burn is complete......");
+	do {
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+		if (ret <= 0) {
+			dev_err(&client->dev, "[burn_fw_dsp]Get burn state fail");
+			goto exit_burn_fw_dsp;
+		}
+		usleep_range(10000, 11000);
+	/* dev_dbg(&client->dev, "[burn_fw_dsp]Get burn state:%d.",
+	rd_buf[GTP_ADDR_LENGTH]); */
+	} while (rd_buf[GTP_ADDR_LENGTH]);
+
+	/* step9:recall check 4k dsp firmware */
+	dev_dbg(&client->dev,
+		"[burn_fw_dsp]step9:recall check 4k dsp firmware");
+	ret = gup_recall_check(client, fw_dsp, 0x9000, FW_DSP_LENGTH);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_dsp]recall check 4k dsp firmware fail.");
+		goto exit_burn_fw_dsp;
+	}
+
+	update_msg.fw_burned_len += FW_DSP_LENGTH;
+	dev_dbg(&client->dev, "[burn_fw_dsp]Burned length:%d",
+			update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_dsp:
+	kfree(fw_dsp);
+
+	return ret;
+}
+
+static u8 gup_burn_fw_boot(struct i2c_client *client)
+{
+	s32 ret = 0;
+	u8 *fw_boot = NULL;
+	u8	retry = 0;
+	u8	rd_buf[5];
+
+	dev_info(&client->dev,
+		 "[burn_fw_boot]Begin burn bootloader firmware---->>");
+
+	/* step1:Alloc memory */
+	dev_dbg(&client->dev, "[burn_fw_boot]step1:Alloc memory");
+	while (retry++ < 5) {
+		fw_boot = kzalloc(FW_BOOT_LENGTH, GFP_KERNEL);
+		if (fw_boot == NULL) {
+			continue;
+		} else {
+			dev_dbg(&client->dev,
+				"[burn_fw_boot]Alloc %dk byte memory success.",
+				FW_BOOT_LENGTH / 1024);
+			break;
+		}
+	}
+	if (retry >= 5) {
+		dev_err(&client->dev, "[burn_fw_boot]Alloc memory fail,exit.");
+		return FAIL;
+	}
+
+	/* step2:load firmware bootloader */
+	dev_dbg(&client->dev, "[burn_fw_boot]step2:load firmware bootloader");
+	ret = gup_load_section_file(fw_boot,
+				    4 * FW_SECTION_LENGTH + FW_DSP_LENGTH,
+				    FW_BOOT_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_boot]load firmware bootcode fail.");
+		goto exit_burn_fw_boot;
+	}
+
+	/* step3:hold ss51 & dsp */
+	dev_dbg(&client->dev, "[burn_fw_boot]step3:hold ss51 & dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_boot]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
+	}
+
+	/* step4:set scramble */
+	dev_dbg(&client->dev, "[burn_fw_boot]step4:set scramble");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_boot]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
+	}
+
+	/* step5:hold ss51 & release dsp */
+	dev_dbg(&client->dev, "[burn_fw_boot]step5:hold ss51 & release dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
+	/* 20121211 */
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_boot]release ss51 & dsp fail");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
+	}
+	/* must delay */
+	usleep_range(1000, 1100);
+
+	/* step6:select bank3 */
+	dev_dbg(&client->dev, "[burn_fw_boot]step6:select bank3");
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_boot]select bank3 fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
+	}
+
+	/* step6:burn 2k bootloader firmware */
+	dev_dbg(&client->dev,
+		"[burn_fw_boot]step6:burn 2k bootloader firmware");
+	ret = gup_burn_proc(client, fw_boot, 0x9000, FW_BOOT_LENGTH);
+	if (FAIL == ret) {
+		dev_err(&client->dev, "[burn_fw_boot]burn fw_boot fail.");
+		goto exit_burn_fw_boot;
+	}
+
+	/* step7:send burn cmd to move data to flash from sram */
+	dev_dbg(&client->dev,
+	"[burn_fw_boot]step7:send burn cmd to move data to flash from sram");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x06);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_boot]send burn cmd fail.");
+		goto exit_burn_fw_boot;
+	}
+	dev_dbg(&client->dev,
+		"[burn_fw_boot]Wait for the burn is complete......");
+	do {
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+		if (ret <= 0) {
+			dev_err(&client->dev,
+				"[burn_fw_boot]Get burn state fail");
+			goto exit_burn_fw_boot;
+		}
+		usleep_range(10000, 11000);
+	/* dev_dbg(&client->dev, "[burn_fw_boot]Get burn state:%d.",
+	 * rd_buf[GTP_ADDR_LENGTH]);
+	 */
+	} while (rd_buf[GTP_ADDR_LENGTH]);
+
+	/* step8:recall check 2k bootloader firmware */
+	dev_dbg(&client->dev,
+		"[burn_fw_boot]step8:recall check 2k bootloader firmware");
+	ret = gup_recall_check(client, fw_boot, 0x9000, FW_BOOT_LENGTH);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_boot]recall check 2k bootcode firmware fail");
+		goto exit_burn_fw_boot;
+	}
+
+	update_msg.fw_burned_len += FW_BOOT_LENGTH;
+	dev_dbg(&client->dev, "[burn_fw_boot]Burned length:%d",
+		update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_boot:
+	kfree(fw_boot);
+
+	return ret;
+}
+static u8 gup_burn_fw_boot_isp(struct i2c_client *client)
+{
+	s32 ret = 0;
+	u8 *fw_boot_isp = NULL;
+	u8	retry = 0;
+	u8	rd_buf[5];
+
+	if (update_msg.fw_burned_len >= update_msg.fw_total_len) {
+		dev_dbg(&client->dev, "No need to upgrade the boot_isp code!");
+		return SUCCESS;
+	}
+	dev_info(&client->dev,
+		"[burn_fw_boot_isp]Begin burn boot_isp firmware---->>");
+
+	/* step1:Alloc memory */
+	dev_dbg(&client->dev, "[burn_fw_boot_isp]step1:Alloc memory");
+	while (retry++ < 5) {
+		fw_boot_isp = kzalloc(FW_BOOT_ISP_LENGTH, GFP_KERNEL);
+		if (fw_boot_isp == NULL) {
+			continue;
+		} else {
+			dev_dbg(&client->dev,
+				"[burn_fw_boot_isp]Alloc %dk byte memory success.",
+				(FW_BOOT_ISP_LENGTH/1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		dev_err(&client->dev,
+			"[burn_fw_boot_isp]Alloc memory fail,exit.");
+		return FAIL;
+	}
+
+	/* step2:load firmware bootloader */
+	dev_dbg(&client->dev,
+		"[burn_fw_boot_isp]step2:load firmware bootloader isp");
+	/* ret = gup_load_section_file(fw_boot_isp,
+	 * (4*FW_SECTION_LENGTH+FW_DSP_LENGTH +
+	 * FW_BOOT_LENGTH+FW_DSP_ISP_LENGTH), FW_BOOT_ISP_LENGTH, SEEK_SET);
+	 */
+	ret = gup_load_section_file(fw_boot_isp, (update_msg.fw_burned_len - FW_DSP_ISP_LENGTH),
+				    FW_BOOT_ISP_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_boot_isp]load firmware boot_isp fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+
+	/* step3:hold ss51 & dsp */
+	dev_dbg(&client->dev, "[burn_fw_boot_isp]step3:hold ss51 & dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_boot_isp]hold ss51 & dsp fail");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+
+	/* step4:set scramble */
+	dev_dbg(&client->dev, "[burn_fw_boot_isp]step4:set scramble");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_boot_isp]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+
+
+	/* step5:hold ss51 & release dsp */
+	dev_dbg(&client->dev,
+		"[burn_fw_boot_isp]step5:hold ss51 & release dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
+	/* 20121211 */
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_boot_isp]release ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+	/* must delay */
+	usleep_range(1000, 2000);
+
+	/* step6:select bank3 */
+	dev_dbg(&client->dev, "[burn_fw_boot_isp]step6:select bank3");
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_boot_isp]select bank3 fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+
+	/* step7:burn 2k bootload_isp firmware */
+	dev_dbg(&client->dev,
+		"[burn_fw_boot_isp]step7:burn 2k bootloader firmware");
+	ret = gup_burn_proc(client, fw_boot_isp, 0x9000, FW_BOOT_ISP_LENGTH);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_boot_isp]burn fw_section fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+
+	/* step7:send burn cmd to move data to flash from sram */
+	dev_dbg(&client->dev,
+	"[burn_fw_boot_isp]step8:send burn cmd to move data to flash from sram");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x07);
+	if (ret <= 0) {
+		dev_err(&client->dev, "[burn_fw_boot_isp]send burn cmd fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+	dev_dbg(&client->dev,
+		"[burn_fw_boot_isp]Wait for the burn is complete......");
+	do {
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+		if (ret <= 0) {
+			dev_err(&client->dev,
+				"[burn_fw_boot_isp]Get burn state fail");
+			goto exit_burn_fw_boot_isp;
+		}
+		usleep_range(10000, 11000);
+	/* dev_dbg(&client->dev, "[burn_fw_boot_isp]Get
+	 * burn state:%d.", rd_buf[GTP_ADDR_LENGTH]);
+	 */
+	} while (rd_buf[GTP_ADDR_LENGTH]);
+
+	/* step8:recall check 2k bootload_isp firmware */
+	dev_dbg(&client->dev,
+		"[burn_fw_boot_isp]step9:recall check 2k bootloader firmware");
+	ret = gup_recall_check(client, fw_boot_isp, 0x9000, FW_BOOT_ISP_LENGTH);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+		"[burn_fw_boot_isp]recall check 2k bootcode_isp firmware fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+
+	update_msg.fw_burned_len += FW_BOOT_ISP_LENGTH;
+	dev_dbg(&client->dev,
+		"[burn_fw_boot_isp]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_boot_isp:
+	kfree(fw_boot_isp);
+
+	return ret;
+}
+
+static u8 gup_burn_fw_link(struct i2c_client *client)
+{
+	u8 *fw_link = NULL;
+	u8	retry = 0;
+	s32 ret = 0;
+	u32 offset;
+
+	if (update_msg.fw_burned_len >= update_msg.fw_total_len) {
+		dev_dbg(&client->dev, "No need to upgrade the link code!");
+		return SUCCESS;
+	}
+	dev_info(&client->dev, "[burn_fw_link]Begin burn link firmware---->>");
+
+	/* step1:Alloc memory */
+	dev_dbg(&client->dev, "[burn_fw_link]step1:Alloc memory");
+	while (retry++ < 5) {
+		fw_link = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_link == NULL) {
+			continue;
+		} else {
+			dev_dbg(&client->dev,
+				"[burn_fw_link]Alloc %dk byte memory success.",
+				(FW_SECTION_LENGTH/1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		dev_err(&client->dev, "[burn_fw_link]Alloc memory fail,exit.");
+		return FAIL;
+	}
+
+	/* step2:load firmware link section 1 */
+	dev_dbg(&client->dev,
+		"[burn_fw_link]step2:load firmware link section 1");
+	offset = update_msg.fw_burned_len - FW_DSP_ISP_LENGTH;
+	ret = gup_load_section_file(fw_link, offset, FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_link]load firmware link section 1 fail.");
+		goto exit_burn_fw_link;
+	}
+
+	/* step3:burn link firmware section 1 */
+	dev_dbg(&client->dev,
+		"[burn_fw_link]step3:burn link firmware section 1");
+	ret = gup_burn_fw_gwake_section(
+	client, fw_link, 0x9000, FW_SECTION_LENGTH, 0x38);
+
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_link]burn link firmware section 1 fail.");
+		goto exit_burn_fw_link;
+	}
+
+	/* step4:load link firmware section 2 file data */
+	dev_dbg(&client->dev,
+		"[burn_fw_link]step4:load link firmware section 2 file data");
+	offset += FW_SECTION_LENGTH;
+	ret = gup_load_section_file(fw_link, offset,
+				    FW_GLINK_LENGTH - FW_SECTION_LENGTH, SEEK_SET);
+
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_link]load link firmware section 2 fail.");
+		goto exit_burn_fw_link;
+	}
+
+	/* step5:burn link firmware section 2 */
+	dev_dbg(&client->dev,
+		"[burn_fw_link]step4:burn link firmware section 2");
+	ret = gup_burn_fw_gwake_section(client,
+	fw_link, 0x9000, FW_GLINK_LENGTH - FW_SECTION_LENGTH, 0x39);
+
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_link]burn link firmware section 2 fail.");
+		goto exit_burn_fw_link;
+	}
+
+	update_msg.fw_burned_len += FW_GLINK_LENGTH;
+	dev_dbg(&client->dev,
+		"[burn_fw_link]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_link:
+	kfree(fw_link);
+
+	return ret;
+}
+
+static u8 gup_burn_fw_gwake_section(struct i2c_client *client,
+		u8 *fw_section, u16 start_addr, u32 len, u8 bank_cmd)
+{
+	s32 ret = 0;
+	u8	rd_buf[5];
+
+	/* step1:hold ss51 & dsp */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_app_section]hold ss51 & dsp fail.");
+		return FAIL;
+	}
+
+	/* step2:set scramble */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_app_section]set scramble fail.");
+		return FAIL;
+	}
+
+	/* step3:hold ss51 & release dsp */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_app_section]hold ss51 & release dsp fail.");
+		return FAIL;
+	}
+	/* must delay */
+	usleep_range(1000, 2000);
+
+	/* step4:select bank */
+	ret = gup_set_ic_msg(
+	client, _bRW_MISCTL__SRAM_BANK, (bank_cmd >> 4)&0x0F);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_section]select bank %d fail.",
+			(bank_cmd >> 4)&0x0F);
+		return FAIL;
+	}
+
+	/* step5:burn fw section */
+	ret = gup_burn_proc(client, fw_section, start_addr, len);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_app_section]burn fw_section fail.");
+		return FAIL;
+	}
+
+	/* step6:send burn cmd to move data to flash from sram */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd&0x0F);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_app_section]send burn cmd fail.");
+		return FAIL;
+	}
+	dev_dbg(&client->dev,
+		"[burn_fw_section]Wait for the burn is complete......");
+	do {
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+		if (ret <= 0) {
+			dev_err(&client->dev,
+				"[burn_fw_app_section]Get burn state fail");
+			return FAIL;
+		}
+		usleep_range(10000, 11000);
+	/* dev_dbg(&client->dev, "[burn_fw_app_section]Get burn state:%d."
+	 * rd_buf[GTP_ADDR_LENGTH]);
+	 */
+	} while (rd_buf[GTP_ADDR_LENGTH]);
+
+	/* step7:recall fw section */
+	ret = gup_recall_check(client, fw_section, start_addr, len);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_app_section]recall check %dk firmware fail.",
+			len/1024);
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+static u8 gup_burn_fw_gwake(struct i2c_client *client)
+{
+	u8 *fw_gwake = NULL;
+	u8	retry = 0;
+	s32 ret = 0;
+	u16 start_index = 4*FW_SECTION_LENGTH +
+	FW_DSP_LENGTH + FW_BOOT_LENGTH +
+	FW_BOOT_ISP_LENGTH + FW_GLINK_LENGTH;/* 32 + 4 + 2 + 4 = 42K */
+	/* u16 start_index; */
+
+	if (start_index >= update_msg.fw_total_len) {
+		dev_dbg(&client->dev, "No need to upgrade the gwake code!");
+		return SUCCESS;
+	}
+	/* start_index = update_msg.fw_burned_len - FW_DSP_ISP_LENGTH; */
+	dev_info(&client->dev,
+		 "[burn_fw_gwake]Begin burn gwake firmware---->>");
+
+	/* step1:alloc memory */
+	dev_dbg(&client->dev, "[burn_fw_gwake]step1:alloc memory");
+	while (retry++ < 5) {
+		fw_gwake =
+	kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_gwake == NULL) {
+			continue;
+		} else {
+			dev_dbg(&client->dev,
+				"[burn_fw_gwake]Alloc %dk byte memory success.",
+				(FW_SECTION_LENGTH/1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		dev_err(&client->dev, "[burn_fw_gwake]Alloc memory fail,exit.");
+		return FAIL;
+	}
+
+	/* clear control flag */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_finish]clear control flag fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	/* step2:load app_code firmware section 1 file data */
+	dev_dbg(&client->dev,
+		"[burn_fw_gwake]step2:load app_code firmware section 1 file data");
+	ret = gup_load_section_file(fw_gwake, start_index,
+				    FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_gwake]load app_code firmware section 1 fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	/* step3:burn app_code firmware section 1 */
+	dev_dbg(&client->dev,
+		"[burn_fw_gwake]step3:burn app_code firmware section 1");
+	ret = gup_burn_fw_gwake_section(client,
+	fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3A);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_gwake]burn app_code firmware section 1 fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	/* step5:load app_code firmware section 2 file data */
+	dev_dbg(&client->dev,
+		"[burn_fw_gwake]step5:load app_code firmware section 2 file data");
+	ret = gup_load_section_file(fw_gwake, start_index+FW_SECTION_LENGTH,
+				    FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_gwake]load app_code firmware section 2 fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	/* step6:burn app_code firmware section 2 */
+	dev_dbg(&client->dev,
+		"[burn_fw_gwake]step6:burn app_code firmware section 2");
+	ret = gup_burn_fw_gwake_section(client,
+	fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3B);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_gwake]burn app_code firmware section 2 fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	/* step7:load app_code firmware section 3 file data */
+	dev_dbg(&client->dev,
+		"[burn_fw_gwake]step7:load app_code firmware section 3 file data");
+	ret = gup_load_section_file(fw_gwake,
+				    start_index + 2 * FW_SECTION_LENGTH,
+				    FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_gwake]load app_code firmware section 3 fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	/* step8:burn app_code firmware section 3 */
+	dev_dbg(&client->dev,
+		"[burn_fw_gwake]step8:burn app_code firmware section 3");
+	ret = gup_burn_fw_gwake_section(
+	client, fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3C);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_gwake]burn app_code firmware section 3 fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	/* step9:load app_code firmware section 4 file data */
+	dev_dbg(&client->dev,
+		"[burn_fw_gwake]step9:load app_code firmware section 4 file data");
+	ret = gup_load_section_file(fw_gwake,
+				    start_index + 3 * FW_SECTION_LENGTH,
+				    FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_gwake]load app_code firmware section 4 fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	/* step10:burn app_code firmware section 4 */
+	dev_dbg(&client->dev,
+		"[burn_fw_gwake]step10:burn app_code firmware section 4");
+	ret = gup_burn_fw_gwake_section(
+	client, fw_gwake, 0x9000, FW_SECTION_LENGTH, 0x3D);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_gwake]burn app_code firmware section 4 fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	/* update_msg.fw_burned_len += FW_GWAKE_LENGTH; */
+	dev_dbg(&client->dev,
+		"[burn_fw_gwake]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_gwake:
+	kfree(fw_gwake);
+
+	return ret;
+}
+
+static u8 gup_burn_fw_finish(struct i2c_client *client)
+{
+	u8 *fw_ss51 = NULL;
+	u8	retry = 0;
+	s32 ret = 0;
+
+	dev_info(&client->dev,
+		 "[burn_fw_finish]burn first 8K of ss51 and finish update.");
+	/* step1:alloc memory */
+	dev_dbg(&client->dev, "[burn_fw_finish]step1:alloc memory");
+	while (retry++ < 5) {
+		fw_ss51 = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_ss51 == NULL) {
+			continue;
+		} else {
+			dev_dbg(&client->dev,
+				"[burn_fw_finish]Alloc %dk byte memory success.",
+				(FW_SECTION_LENGTH/1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		dev_err(&client->dev,
+			"[burn_fw_finish]Alloc memory fail,exit.");
+		return FAIL;
+	}
+
+	dev_dbg(&client->dev, "[burn_fw_finish]step2: burn ss51 first 8K.");
+	ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_finish]load ss51 firmware section 1 fail.");
+		goto exit_burn_fw_finish;
+	}
+
+	dev_dbg(&client->dev, "[burn_fw_finish]step3:clear control flag");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_finish]clear control flag fail.");
+		goto exit_burn_fw_finish;
+	}
+
+	dev_dbg(&client->dev,
+		"[burn_fw_finish]step4:burn ss51 firmware section 1");
+	ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x01);
+	if (FAIL == ret) {
+		dev_err(&client->dev,
+			"[burn_fw_finish]burn ss51 firmware section 1 fail.");
+		goto exit_burn_fw_finish;
+	}
+
+	/* step11:enable download DSP code */
+	dev_dbg(&client->dev,
+		"[burn_fw_finish]step5:enable download DSP code ");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_finish]enable download DSP code fail.");
+		goto exit_burn_fw_finish;
+	}
+
+	/* step12:release ss51 & hold dsp */
+	dev_dbg(&client->dev, "[burn_fw_finish]step6:release ss51 & hold dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x08);
+	if (ret <= 0) {
+		dev_err(&client->dev,
+			"[burn_fw_finish]release ss51 & hold dsp fail.");
+		goto exit_burn_fw_finish;
+	}
+
+	if (fw_ss51 != NULL)
+		kfree(fw_ss51);
+	return SUCCESS;
+
+exit_burn_fw_finish:
+	if (fw_ss51 != NULL)
+		kfree(fw_ss51);
+
+	return FAIL;
+}
+
+/* return 0 can update, else no update condition */
+static int gup_update_condition_check(struct goodix_ts_data *ts)
+{
+	if (test_bit(SLEEP_MODE, &ts->flags)) {
+		dev_info(&ts->client->dev, "Update abort, tp in sleep mode\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+s32 gup_update_proc(void *dir)
+{
+	s32 ret = 0;
+	s32 update_ret = FAIL;
+	u8	retry = 0;
+	struct st_fw_head fw_head;
+	struct goodix_ts_data *ts = NULL;
+
+	ts = i2c_get_clientdata(i2c_connect_client);
+
+	dev_dbg(&ts->client->dev, "[update_proc]Begin update ......\n");
+
+	show_len = 1;
+	total_len = 100;
+
+	ret = gup_update_condition_check(ts);
+	if (ret) {
+		dev_warn(&ts->client->dev, "Update start failed\n");
+		return FAIL;
+	}
+
+	if (test_and_set_bit(FW_UPDATE_RUNNING, &ts->flags)) {
+		dev_warn(&ts->client->dev, "FW update may already running\n");
+		return FAIL;
+	}
+
+	ret = gup_get_update_file(i2c_connect_client, &fw_head, (u8 *)dir);
+	if (FAIL == ret) {
+		dev_err(&ts->client->dev,
+			"Failed get valied firmware data\n");
+		clear_bit(FW_UPDATE_RUNNING, &ts->flags);
+		return FAIL;
+	}
+
+	gtp_work_control_enable(ts, false);
+	gtp_esd_off(ts);
+
+	ret = gup_get_ic_fw_msg(i2c_connect_client);
+	if (FAIL == ret) {
+		dev_err(&ts->client->dev, "[update_proc]get ic message fail.");
+		goto file_fail;
+	}
+
+	if (ts->force_update || dir) {
+		dev_dbg(&ts->client->dev, "Enter force update.");
+	} else {
+		ret = gup_enter_update_judge(i2c_connect_client, &fw_head);
+		if (FAIL == ret) {
+			dev_err(&ts->client->dev,
+				"[update_proc]Doesn't meet update condition\n");
+			goto file_fail;
+		}
+	}
+
+	ret = gup_enter_update_mode(ts->client);
+	if (FAIL == ret) {
+		dev_err(&ts->client->dev,
+			"[update_proc]enter update mode fail.");
+		goto update_fail;
+	}
+
+	while (retry++ < 5) {
+		show_len = 10;
+		total_len = 100;
+		update_msg.fw_burned_len = 0;
+		ret = gup_burn_dsp_isp(i2c_connect_client);
+		if (FAIL == ret) {
+			dev_err(&ts->client->dev,
+				"[update_proc]burn dsp isp fail.");
+			continue;
+		}
+
+		show_len = 20;
+		ret = gup_burn_fw_gwake(i2c_connect_client);
+		if (FAIL == ret) {
+			dev_err(&ts->client->dev,
+				"[update_proc]burn app_code firmware fail.");
+			continue;
+		}
+
+		show_len = 30;
+		ret = gup_burn_fw_ss51(i2c_connect_client);
+		if (FAIL == ret) {
+			dev_err(&ts->client->dev,
+				"[update_proc]burn ss51 firmware fail.");
+			continue;
+		}
+
+		show_len = 40;
+		ret = gup_burn_fw_dsp(i2c_connect_client);
+		if (FAIL == ret) {
+			dev_err(&ts->client->dev,
+				"[update_proc]burn dsp firmware fail.");
+			continue;
+		}
+
+		show_len = 50;
+		ret = gup_burn_fw_boot(i2c_connect_client);
+		if (FAIL == ret) {
+			dev_err(&ts->client->dev,
+				"[update_proc]burn bootloader firmware fail.");
+			continue;
+		}
+		show_len = 60;
+
+		ret = gup_burn_fw_boot_isp(i2c_connect_client);
+		if (FAIL == ret) {
+			dev_err(&ts->client->dev,
+				"[update_proc]burn boot_isp firmware fail.");
+			continue;
+		}
+
+		show_len = 70;
+		ret = gup_burn_fw_link(i2c_connect_client);
+		if (FAIL == ret) {
+			dev_err(&ts->client->dev,
+				"[update_proc]burn link firmware fail.");
+			continue;
+		}
+
+		show_len = 80;
+		ret = gup_burn_fw_finish(i2c_connect_client);
+		if (FAIL == ret) {
+			dev_err(&ts->client->dev,
+				"[update_proc]burn finish fail.");
+			continue;
+		}
+		show_len = 90;
+		dev_info(&ts->client->dev, "[update_proc]UPDATE SUCCESS.");
+		retry = 0;
+		break;
+	}
+
+	if (retry >= 5) {
+		dev_err(&ts->client->dev,
+			"[update_proc]retry timeout,UPDATE FAIL.");
+		update_ret = FAIL;
+	} else {
+		update_ret = SUCCESS;
+	}
+
+update_fail:
+	dev_dbg(&ts->client->dev, "[update_proc]leave update mode.");
+	gup_leave_update_mode(i2c_connect_client);
+
+	msleep(GTP_100_DLY_MS);
+
+	if (SUCCESS == update_ret) {
+		dev_info(&ts->client->dev,
+			"firmware error auto update, resent config!\n");
+		gup_init_panel(ts);
+	}
+	gtp_get_fw_info(ts->client, &ts->fw_info);
+
+file_fail:
+
+	update_msg.fw_data = NULL;
+	update_msg.fw_total_len = 0;
+	release_firmware(update_msg.fw);
+
+	clear_bit(FW_UPDATE_RUNNING, &ts->flags);
+	gtp_work_control_enable(ts, true);
+	gtp_esd_on(ts);
+	total_len = 100;
+	ts->force_update = false;
+	if (SUCCESS == update_ret) {
+		show_len = 100;
+		clear_bit(FW_ERROR, &ts->flags);
+		return SUCCESS;
+	} else {
+		show_len = 200;
+		return FAIL;
+	}
+}
+
+u8 gup_init_update_proc(struct goodix_ts_data *ts)
+{
+	struct task_struct *thread = NULL;
+
+	dev_info(&ts->client->dev, "Ready to run update thread.");
+
+	thread = kthread_run(gup_update_proc,
+			(void *)NULL, "guitar_update");
+
+	if (IS_ERR(thread)) {
+		dev_err(&ts->client->dev,
+				"Failed to create update thread.\n");
+		return -EPERM;
+	}
+
+	return 0;
+}
diff --git a/drivers/rtc/rtc-pcf85063.c b/drivers/rtc/rtc-pcf85063.c
index 14da4ab30..486f224a1 100644
--- a/drivers/rtc/rtc-pcf85063.c
+++ b/drivers/rtc/rtc-pcf85063.c
@@ -8,6 +8,8 @@
  *
  * Copyright (C) 2019 Micro Crystal AG
  * Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
+ *
+ * Copyright 2022-2023 Panasonic Corporation
  */
 #include <linux/clk-provider.h>
 #include <linux/i2c.h>
@@ -34,6 +36,7 @@
 #define PCF85063_REG_CTRL1		0x00 /* status */
 #define PCF85063_REG_CTRL1_CAP_SEL	BIT(0)
 #define PCF85063_REG_CTRL1_STOP		BIT(5)
+#define PCF85063_REG_CTRL1_EXT_TEST	BIT(7)
 
 #define PCF85063_REG_CTRL2		0x01
 #define PCF85063_CTRL2_AF		BIT(6)
@@ -117,6 +120,7 @@ static int pcf85063_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	 * reset state until all time/date registers are written
 	 */
 	rc = regmap_update_bits(pcf85063->regmap, PCF85063_REG_CTRL1,
+				PCF85063_REG_CTRL1_EXT_TEST |
 				PCF85063_REG_CTRL1_STOP,
 				PCF85063_REG_CTRL1_STOP);
 	if (rc)
diff --git a/drivers/soc/fsl/Kconfig b/drivers/soc/fsl/Kconfig
index f760e03a2..a2a5c9d80 100644
--- a/drivers/soc/fsl/Kconfig
+++ b/drivers/soc/fsl/Kconfig
@@ -65,6 +65,7 @@ config FSL_QIXIS
 	depends on OF
 	select REGMAP_I2C
 	select REGMAP_MMIO
+	select MFD_CORE
 	default n
 	help
 	  Say y here to enable QIXIS system controller api. The qixis driver
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index e80e69dd2..856a9ec6c 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1561,6 +1561,14 @@ config SERIAL_LITEUART_CONSOLE
 	  and warnings and which allows logins in single user mode).
 	  Otherwise, say 'N'.
 
+config SERIAL_RL78_I2C_UART
+	tristate "RL78 I2C UART serial port support"
+	depends on I2C
+	select SERIAL_CORE
+	select REGMAP_I2C
+	help
+	  Enable RL78 I2C-UART serial port driver.
+
 endmenu
 
 config SERIAL_MCTRL_GPIO
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 7da0856cd..34f208b0b 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -93,3 +93,5 @@ obj-$(CONFIG_SERIAL_MCTRL_GPIO)	+= serial_mctrl_gpio.o
 
 obj-$(CONFIG_SERIAL_KGDB_NMI) += kgdb_nmi.o
 obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgdboc.o
+
+obj-$(CONFIG_SERIAL_RL78_I2C_UART)	+= rl78-i2c-uart.o
diff --git a/drivers/tty/serial/rl78-i2c-uart.c b/drivers/tty/serial/rl78-i2c-uart.c
new file mode 100644
index 000000000..6002ffd65
--- /dev/null
+++ b/drivers/tty/serial/rl78-i2c-uart.c
@@ -0,0 +1,958 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * RL78 I2C-UART tty serial driver
+ *
+ * Copyright 2022-2023 Panasonic Corporation
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/driver.h>
+#include <linux/i2c.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/kthread.h>
+#include <linux/uaccess.h>
+#include <linux/of_gpio.h>
+#include <uapi/linux/sched/types.h>
+
+#define DRIVER_NAME	"rl78uart"
+#define DEV_NAME	"ttyRL"
+#define UART_NR		2
+
+/* RL78UART register definitions */
+#define RL78UART_RHR_REG			(0x00) /* RX FIFO */
+#define RL78UART_THR_REG			(0x00) /* TX FIFO */
+#define RL78UART_IER_REG			(0x01) /* Interrupt enable */
+#define RL78UART_IIR_REG			(0x02) /* Interrupt Identification */
+#define RL78UART_FCR_REG			(0x02) /* FIFO control */
+#define RL78UART_LCR_REG			(0x03) /* Line Control */
+#define RL78UART_LSR_REG			(0x05) /* Line Status */
+#define RL78UART_TXLVL_REG			(0x08) /* TX FIFO level */
+#define RL78UART_RXLVL_REG			(0x09) /* RX FIFO level */
+#define RL78UART_IOCTL_REG			(0x0e) /* I/O Control */
+#define RL78UART_EFCR_REG			(0x0f) /* Extra Features Control */
+#define RL78UART_DLL_REG			(0x10) /* Divisor Latch Low */
+#define RL78UART_DLH_REG			(0x11) /* Divisor Latch High */
+#define RL78UART_ID_REG				(0x12) /* Device Check ID */
+#define RL78UART_MAJOR_REG			(0x13) /* FW version (major) */
+#define RL78UART_MINOR_REG			(0x14) /* FW version (minor) */
+#define RL78UART_REVISION_REG		(0x15) /* FW version (minor) */
+#define RL78UART_REG_MAX			RL78UART_REVISION_REG
+
+/* IER register bits */
+#define RL78UART_IER_RDI_BIT		(1 << 0) /* Enable RX data interrupt */
+#define RL78UART_IER_THRI_BIT		(1 << 1) /* Enable TX holding register interrupt */
+#define RL78UART_IER_RLSI_BIT		(1 << 2) /* Enable RX line status interrupt */
+
+/* FCR register bits */
+#define RL78UART_FCR_FIFO_BIT		(1 << 0) /* Enable FIFO */
+#define RL78UART_FCR_RXRESET_BIT	(1 << 1) /* Reset RX FIFO */
+#define RL78UART_FCR_TXRESET_BIT	(1 << 2) /* Reset TX FIFO */
+
+/* IIR register bits */
+#define RL78UART_IIR_NO_INT_BIT		(1 << 0) /* No interrupts pending */
+#define RL78UART_IIR_ID_MASK		(0x3e)   /* Mask for the interrupt ID */
+#define RL78UART_IIR_THRI_SRC		(0x02)   /* TX holding register empty */
+#define RL78UART_IIR_RDI_SRC		(0x04)   /* RX data interrupt */
+#define RL78UART_IIR_RLSE_SRC		(0x06)   /* RX line status error */
+#define RL78UART_IIR_RTOI_SRC		(0x0c)   /* RX time-out interrupt */
+
+/* LCR register bits */
+#define RL78UART_LCR_LENGTH0_BIT	(1 << 0) /* Word length bit 0 */
+#define RL78UART_LCR_LENGTH1_BIT	(1 << 1) /* Word length bit 1
+											  *
+											  * Word length bits table:
+											  * 10 -> 7 bit words
+											  * 11 -> 8 bit words
+											  * (5 bit and 6 bit not supported)
+											  */
+#define RL78UART_LCR_STOPLEN_BIT	(1 << 2) /* STOP length bit
+											  *
+											  * STOP length bit table:
+											  * 0 -> 1 stop bit
+											  * 1 -> 2 stop bits
+											  */
+#define RL78UART_LCR_PARITY_BIT		(1 << 3) /* Parity bit enable */
+#define RL78UART_LCR_EVENPARITY_BIT	(1 << 4) /* Even parity bit enable */
+#define RL78UART_LCR_WORD_LEN_7		(0x02)
+#define RL78UART_LCR_WORD_LEN_8		(0x03)
+
+/* LSR register bits */
+#define RL78UART_LSR_DR_BIT			(1 << 0) /* Receiver data ready */
+#define RL78UART_LSR_OE_BIT			(1 << 1) /* Overrun Error */
+#define RL78UART_LSR_PE_BIT			(1 << 2) /* Parity Error */
+#define RL78UART_LSR_FE_BIT			(1 << 3) /* Frame Error */
+#define RL78UART_LSR_ERROR_MASK		(0x0E)   /* FE, PE, OE bits */
+#define RL78UART_LSR_THRE_BIT		(1 << 5) /* TX holding register empty */
+#define RL78UART_LSR_TEMT_BIT		(1 << 6) /* Transmitter empty */
+#define RL78UART_LSR_FIFOE_BIT		(1 << 7) /* Fifo Error */
+
+/* IOControl register bits */
+#define RL78UART_IOCTL_UART_RESET_BIT	(1 << 0) /* Uart Reset */
+#define RL78UART_IOCTL_CPU_RESET_BIT	(1 << 1) /* RL78 CPU Reset */
+
+/* EFCR register bits */
+#define RL78UART_EFCR_DISABLE_BIT	(1 << 0) /* Disable Uart */
+
+/* Misc definitions */
+#define RL78UART_FIFO_SIZE			(64)
+
+#define RL78UART_ID_VALUE			(0x78)
+#define RL78UART_UARTCLK			(24000000)
+
+#define RL78UART_BAUDRATE_MIN		(300)
+#define RL78UART_BAUDRATE_MAX		(115200)
+
+#define RL78UART_RECONF_IER			(1 << 0)
+
+struct rl78uart_port {
+	struct uart_port		port;
+	struct regmap			*regmap;
+	unsigned char			rbuf[RL78UART_FIFO_SIZE];
+	unsigned char			wbuf[RL78UART_FIFO_SIZE];
+	struct kthread_worker	kworker;
+	struct task_struct		*kworker_task;
+	struct kthread_work		tx_work;
+	struct kthread_work		reg_work;
+	struct mutex			irq_lock;
+	unsigned int			flags;
+	int						led_gpio;
+	u8						ier_mask;
+	u8						ier_val;
+};
+
+static struct uart_driver rl78uart_driver = {
+	.owner			= THIS_MODULE,
+	.driver_name	= DRIVER_NAME,
+	.dev_name		= DEV_NAME,
+	.nr				= UART_NR,
+};
+
+static void rl78uart_ier_set(struct uart_port *port, u8 bit);
+static void rl78uart_stop_tx(struct uart_port *port);
+
+#define to_rl78uart_port(p,e)	((container_of((p), struct rl78uart_port, e)))
+
+static u8 rl78uart_port_read(struct uart_port *port, u8 reg)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+	unsigned int val = 0;
+
+	regmap_read(s->regmap, reg, &val);
+
+	return val;
+}
+
+static void rl78uart_port_write(struct uart_port *port, u8 reg, u8 val)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+
+	regmap_write(s->regmap, reg, val);
+}
+
+static void rl78uart_fifo_read(struct uart_port *port, unsigned int rxlen)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+
+	regcache_cache_bypass(s->regmap, true);
+	gpio_set_value(s->led_gpio, 1);
+
+	regmap_raw_read(s->regmap, RL78UART_RHR_REG, s->rbuf, rxlen);
+
+	gpio_set_value(s->led_gpio, 0);
+	regcache_cache_bypass(s->regmap, false);
+}
+
+static void rl78uart_fifo_write(struct uart_port *port, u8 to_send)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+
+	if (unlikely(!to_send))
+		return;
+
+	regcache_cache_bypass(s->regmap, true);
+	gpio_set_value(s->led_gpio, 1);
+
+	regmap_raw_write(s->regmap, RL78UART_THR_REG, s->wbuf, to_send);
+
+	gpio_set_value(s->led_gpio, 0);
+	regcache_cache_bypass(s->regmap, false);
+}
+
+static void rl78uart_port_update(struct uart_port *port, u8 reg,
+				  u8 mask, u8 val)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+
+	regmap_update_bits(s->regmap, reg, mask, val);
+}
+
+static bool rl78uart_regmap_volatile(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case RL78UART_RHR_REG:
+	case RL78UART_IIR_REG:
+	case RL78UART_LSR_REG:
+	case RL78UART_TXLVL_REG:
+	case RL78UART_RXLVL_REG:
+	case RL78UART_IOCTL_REG:
+	case RL78UART_EFCR_REG:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static bool rl78uart_regmap_precious(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case RL78UART_RHR_REG:
+	case RL78UART_IIR_REG:
+	case RL78UART_LSR_REG:
+		return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static int rl78uart_set_baud(struct uart_port *port, int baud)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+	unsigned long dlh, dll;
+	unsigned long long result, top, bottom;
+	int found = 0;
+
+	top = ((unsigned long long)baud * 1000) + ((unsigned long long)baud * 2);
+	bottom = ((unsigned long long)baud * 1000) - ((unsigned long long)baud * 2);
+
+	for (dlh = 0, dll = 0; dlh < 16; dlh++) {
+		for (dll = 2; dll < 128; dll++) {
+			result = ((unsigned long long)RL78UART_UARTCLK * 1000) /
+					((1 << dlh) * (dll + 1) * 2);
+			if ((bottom <= result) && (result <= top)) {
+				/* Found a value with an error of 0.2% */
+				found = 1;
+				break;
+			}
+		}
+		if (found) {
+			break;
+		}
+	}
+
+	if (!found) {
+		/* error, set to 57600bps */
+		dev_err(port->dev, "Failed to set baud rate (%d), set to 57600.\n", baud);
+		dlh = 1;
+		dll = 103;
+	}
+
+	/* Write the new divisor */
+	regcache_cache_bypass(s->regmap, true);
+	rl78uart_port_write(port, RL78UART_DLH_REG, dlh);
+	rl78uart_port_write(port, RL78UART_DLL_REG, dll);
+	regcache_cache_bypass(s->regmap, false);
+
+	return (int)result;
+}
+
+static void rl78uart_handle_rx(struct uart_port *port, unsigned int rxlen,
+				unsigned int iir)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+	unsigned int lsr = 0, ch, flag, bytes_read, i;
+	bool read_lsr = (iir == RL78UART_IIR_RLSE_SRC) ? true : false;
+
+	if (unlikely(rxlen >= sizeof(s->rbuf))) {
+		dev_warn_ratelimited(port->dev,
+				     "ttyRL%i: Possible RX FIFO overrun: %d\n",
+				     port->line, rxlen);
+		port->icount.buf_overrun++;
+		rxlen = sizeof(s->rbuf);
+	}
+
+	while (rxlen) {
+		if (read_lsr) {
+			lsr = rl78uart_port_read(port, RL78UART_LSR_REG);
+			if (!(lsr & RL78UART_LSR_FIFOE_BIT))
+				read_lsr = false; /* No errors left in FIFO */
+		} else
+			lsr = 0;
+
+		if (read_lsr) {
+			s->rbuf[0] = rl78uart_port_read(port, RL78UART_RHR_REG);
+			bytes_read = 1;
+		} else {
+			rl78uart_fifo_read(port, rxlen);
+			bytes_read = rxlen;
+		}
+
+		lsr &= RL78UART_LSR_ERROR_MASK;
+
+		port->icount.rx += bytes_read;
+		flag = TTY_NORMAL;
+
+		if (unlikely(lsr)) {
+			if (lsr & RL78UART_LSR_PE_BIT)
+				port->icount.parity++;
+			else if (lsr & RL78UART_LSR_FE_BIT)
+				port->icount.frame++;
+			else if (lsr & RL78UART_LSR_OE_BIT)
+				port->icount.overrun++;
+
+			lsr &= port->read_status_mask;
+			if (lsr & RL78UART_LSR_PE_BIT)
+				flag = TTY_PARITY;
+			else if (lsr & RL78UART_LSR_FE_BIT)
+				flag = TTY_FRAME;
+			else if (lsr & RL78UART_LSR_OE_BIT)
+				flag = TTY_OVERRUN;
+		}
+
+		for (i = 0; i < bytes_read; ++i) {
+			ch = s->rbuf[i];
+			if (uart_handle_sysrq_char(port, ch))
+				continue;
+
+			if (lsr & port->ignore_status_mask)
+				continue;
+
+			uart_insert_char(port, lsr, RL78UART_LSR_OE_BIT, ch, flag);
+		}
+		rxlen -= bytes_read;
+	}
+
+	tty_flip_buffer_push(&port->state->port);
+}
+
+static void rl78uart_handle_tx(struct uart_port *port)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+	struct circ_buf *xmit = &port->state->xmit;
+	unsigned int txlen, to_send, i;
+	unsigned long flags;
+
+	if (unlikely(port->x_char)) {
+		rl78uart_port_write(port, RL78UART_THR_REG, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		spin_lock_irqsave(&port->lock, flags);
+		rl78uart_stop_tx(port);
+		spin_unlock_irqrestore(&port->lock, flags);
+		return;
+	}
+
+	/* Get length of data pending in circular buffer */
+	to_send = uart_circ_chars_pending(xmit);
+	if (likely(to_send)) {
+		/* Limit to size of TX FIFO */
+		txlen = rl78uart_port_read(port, RL78UART_TXLVL_REG);
+		if (txlen > RL78UART_FIFO_SIZE) {
+			dev_err_ratelimited(port->dev,
+				"chip reports %d free bytes in TX fifo, but it only has %d",
+				txlen, RL78UART_FIFO_SIZE);
+			txlen = 0;
+		}
+		to_send = (to_send > txlen) ? txlen : to_send;
+
+		/* Add data to send */
+		port->icount.tx += to_send;
+
+		/* Convert to linear buffer */
+		for (i = 0; i < to_send; ++i) {
+			s->wbuf[i] = xmit->buf[xmit->tail];
+			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		}
+
+		rl78uart_fifo_write(port, to_send);
+	}
+
+	spin_lock_irqsave(&port->lock, flags);
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		rl78uart_stop_tx(port);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static irqreturn_t rl78uart_irq(int irq, void *dev_id)
+{
+	struct rl78uart_port *s = (struct rl78uart_port *)dev_id;
+	struct uart_port *port = &s->port;
+
+	mutex_lock(&s->irq_lock);
+
+	do {
+		unsigned int iir, rxlen;
+
+		iir = rl78uart_port_read(port, RL78UART_IIR_REG);
+		if (iir & RL78UART_IIR_NO_INT_BIT) {
+			/* Loop until interrupt pending is gone */
+			break;
+		}
+
+		iir &= RL78UART_IIR_ID_MASK;
+
+		switch (iir) {
+		case RL78UART_IIR_RDI_SRC:
+		case RL78UART_IIR_RLSE_SRC:
+		case RL78UART_IIR_RTOI_SRC:
+			rxlen = rl78uart_port_read(port, RL78UART_RXLVL_REG);
+			if (rxlen)
+				rl78uart_handle_rx(port, rxlen, iir);
+			break;
+		case RL78UART_IIR_THRI_SRC:
+			rl78uart_handle_tx(port);
+			break;
+		default:
+			dev_err_ratelimited(port->dev,
+					    "ttyRL%i: Unexpected interrupt: %x",
+					    port->line, iir);
+			break;
+		}
+
+	} while (1);
+
+	mutex_unlock(&s->irq_lock);
+
+	return IRQ_HANDLED;
+}
+
+static void rl78uart_tx_proc(struct kthread_work *ws)
+{
+	struct rl78uart_port *s = to_rl78uart_port(ws, tx_work);
+	struct uart_port *port = &s->port;
+	unsigned long flags;
+
+	mutex_lock(&s->irq_lock);
+	rl78uart_handle_tx(port);
+	mutex_unlock(&s->irq_lock);
+
+	spin_lock_irqsave(&port->lock, flags);
+	rl78uart_ier_set(port, RL78UART_IER_THRI_BIT);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void rl78uart_reg_proc(struct kthread_work *ws)
+{
+	struct rl78uart_port *s = to_rl78uart_port(ws, reg_work);
+	unsigned long irqflags;
+	unsigned int flags;
+	u8 ier_mask, ier_val;
+
+	spin_lock_irqsave(&s->port.lock, irqflags);
+	flags = s->flags;
+	ier_mask = s->ier_mask;
+	ier_val = s->ier_val;
+	s->flags = 0;
+	s->ier_mask = 0;
+	s->ier_val = 0;
+	spin_unlock_irqrestore(&s->port.lock, irqflags);
+
+	mutex_lock(&s->irq_lock);
+	if (flags & RL78UART_RECONF_IER)
+		rl78uart_port_update(&s->port, RL78UART_IER_REG, ier_mask, ier_val);
+	mutex_unlock(&s->irq_lock);
+}
+
+static void rl78uart_ier_clear(struct uart_port *port, u8 bit)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+
+	s->flags |= RL78UART_RECONF_IER;
+	s->ier_mask |= bit;
+	s->ier_val &= ~bit;
+	kthread_queue_work(&s->kworker, &s->reg_work);
+}
+
+static void rl78uart_ier_set(struct uart_port *port, u8 bit)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+
+	s->flags |= RL78UART_RECONF_IER;
+	s->ier_mask |= bit;
+	s->ier_val |= bit;
+	kthread_queue_work(&s->kworker, &s->reg_work);
+}
+
+static void rl78uart_stop_tx(struct uart_port *port)
+{
+	rl78uart_ier_clear(port, RL78UART_IER_THRI_BIT);
+}
+
+static void rl78uart_stop_rx(struct uart_port *port)
+{
+	rl78uart_ier_clear(port, RL78UART_IER_RDI_BIT | RL78UART_IER_RLSI_BIT);
+}
+
+static void rl78uart_start_tx(struct uart_port *port)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+
+	kthread_queue_work(&s->kworker, &s->tx_work);
+}
+
+static unsigned int rl78uart_tx_empty(struct uart_port *port)
+{
+	unsigned int lsr;
+
+	lsr = rl78uart_port_read(port, RL78UART_LSR_REG);
+
+	return (lsr & RL78UART_LSR_TEMT_BIT) ? TIOCSER_TEMT : 0;
+}
+
+static unsigned int rl78uart_get_mctrl(struct uart_port *port)
+{
+	/* not support */
+	return 0;
+}
+
+static void rl78uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* not support */
+}
+
+static void rl78uart_break_ctl(struct uart_port *port, int break_state)
+{
+	/* not support */
+}
+
+static void rl78uart_set_termios(struct uart_port *port,
+				  struct ktermios *termios,
+				  struct ktermios *old)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+	unsigned int lcr, val;
+	int baud, loop;
+	unsigned long flags;
+
+	/* Mask termios capabilities we don't support */
+	termios->c_cflag &= ~CMSPAR;
+
+	/* Word size */
+	switch (termios->c_cflag & CSIZE) {
+	case CS7:
+		lcr = RL78UART_LCR_WORD_LEN_7;
+		break;
+	case CS8:
+		lcr = RL78UART_LCR_WORD_LEN_8;
+		break;
+	default:
+		lcr = RL78UART_LCR_WORD_LEN_8;
+		termios->c_cflag &= ~CSIZE;
+		termios->c_cflag |= CS8;
+		break;
+	}
+
+	/* Parity */
+	if (termios->c_cflag & PARENB) {
+		lcr |= RL78UART_LCR_PARITY_BIT;
+		if (!(termios->c_cflag & PARODD))
+			lcr |= RL78UART_LCR_EVENPARITY_BIT;
+	}
+
+	/* Stop bits */
+	if (termios->c_cflag & CSTOPB)
+		lcr |= RL78UART_LCR_STOPLEN_BIT; /* 2 stops */
+
+	/* Set read status mask */
+	port->read_status_mask = RL78UART_LSR_OE_BIT;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= RL78UART_LSR_PE_BIT |
+					  RL78UART_LSR_FE_BIT;
+
+	/* Set status ignore mask */
+	port->ignore_status_mask = 0;
+	if (!(termios->c_cflag & CREAD))
+		port->ignore_status_mask |= RL78UART_LSR_ERROR_MASK;
+
+	/* Update LCR register */
+	mutex_lock(&s->irq_lock);
+
+	rl78uart_port_write(port, RL78UART_LCR_REG, lcr);
+
+	/* Get baud rate generator configuration */
+	baud = uart_get_baud_rate(port, termios, old,
+				RL78UART_BAUDRATE_MIN, RL78UART_BAUDRATE_MAX);
+
+	/* Setup baudrate generator */
+	baud = rl78uart_set_baud(port, baud);
+
+	/* Update UART */
+	regcache_cache_bypass(s->regmap, true);
+	rl78uart_port_write(port, RL78UART_IOCTL_REG, 
+						RL78UART_IOCTL_UART_RESET_BIT);
+
+	loop = 100;
+	do {
+		val = rl78uart_port_read(port, RL78UART_IOCTL_REG);
+		if ((val & RL78UART_IOCTL_UART_RESET_BIT) == 0) {
+			break;
+		}
+		udelay(100);
+	} while (--loop);
+
+	regcache_cache_bypass(s->regmap, false);
+
+	mutex_unlock(&s->irq_lock);
+
+	spin_lock_irqsave(&port->lock, flags);
+	/* Update timeout according to new baud rate */
+	uart_update_timeout(port, termios->c_cflag, baud);
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int rl78uart_config_rs485(struct uart_port *port,
+				  struct serial_rs485 *rs485)
+{
+	port->rs485 = *rs485;
+
+	return 0;
+}
+
+static int rl78uart_startup(struct uart_port *port)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+
+	unsigned int val;
+
+	mutex_lock(&s->irq_lock);
+
+	gpio_set_value(s->led_gpio, 0);
+
+	/* Now, initialize the UART */
+	rl78uart_port_write(port, RL78UART_LCR_REG, RL78UART_LCR_WORD_LEN_8);
+
+	/* Enable RX interrupts */
+	val = RL78UART_IER_RDI_BIT | RL78UART_IER_RLSI_BIT;
+	rl78uart_port_write(port, RL78UART_IER_REG, val);
+
+	/* Enable TX/RX */
+	rl78uart_port_write(port, RL78UART_EFCR_REG, 0);
+
+	mutex_unlock(&s->irq_lock);
+
+	return 0;
+}
+
+static void rl78uart_shutdown(struct uart_port *port)
+{
+	struct rl78uart_port *s = dev_get_drvdata(port->dev);
+
+	mutex_lock(&s->irq_lock);
+
+	/* Disable all interrupts */
+	rl78uart_port_write(port, RL78UART_IER_REG, 0);
+
+	/* Disable TX/RX */
+	rl78uart_port_write(port, RL78UART_EFCR_REG, RL78UART_EFCR_DISABLE_BIT);
+
+	gpio_set_value(s->led_gpio, 0);
+
+	mutex_unlock(&s->irq_lock);
+
+	kthread_flush_worker(&s->kworker);
+}
+
+static const char *rl78uart_type(struct uart_port *port)
+{
+	return (port->type == PORT_RL78UART) ? DRIVER_NAME : NULL;
+}
+
+static int rl78uart_request_port(struct uart_port *port)
+{
+	/* Do nothing */
+	return 0;
+}
+
+static void rl78uart_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE)
+		port->type = PORT_RL78UART;
+}
+
+static int rl78uart_verify_port(struct uart_port *port,
+				 struct serial_struct *s)
+{
+	if ((s->type != PORT_UNKNOWN) && (s->type != PORT_RL78UART))
+		return -EINVAL;
+	if (s->irq != port->irq)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void rl78uart_pm(struct uart_port *port, unsigned int state,
+			 unsigned int oldstate)
+{
+	/* Do nothing */
+}
+
+static void rl78uart_null_void(struct uart_port *port)
+{
+	/* Do nothing */
+}
+
+static const struct uart_ops rl78uart_ops = {
+	.tx_empty		= rl78uart_tx_empty,
+	.set_mctrl		= rl78uart_set_mctrl,
+	.get_mctrl		= rl78uart_get_mctrl,
+	.stop_tx		= rl78uart_stop_tx,
+	.start_tx		= rl78uart_start_tx,
+	.stop_rx		= rl78uart_stop_rx,
+	.break_ctl		= rl78uart_break_ctl,
+	.startup		= rl78uart_startup,
+	.shutdown		= rl78uart_shutdown,
+	.set_termios	= rl78uart_set_termios,
+	.type			= rl78uart_type,
+	.request_port	= rl78uart_request_port,
+	.release_port	= rl78uart_null_void,
+	.config_port	= rl78uart_config_port,
+	.verify_port	= rl78uart_verify_port,
+	.pm				= rl78uart_pm,
+};
+
+static int rl78uart_probe(struct device *dev,
+			   struct regmap *regmap, int irq)
+{
+	unsigned int dev_id;
+	unsigned int major;
+	unsigned int minor;
+	unsigned int rev;
+	u32 line = (u32)(-1);
+	int ret;
+	struct rl78uart_port *s;
+	int led_gpio;
+
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	ret = regmap_read(regmap, RL78UART_ID_REG, &dev_id);
+	if (ret < 0)
+		return ret;
+
+	if (dev_id != RL78UART_ID_VALUE) {
+		dev_err(dev, "Invalid device id (id=0x%02x)\n", dev_id);
+		return -ENODEV;
+	}
+
+	ret = regmap_read(regmap, RL78UART_MAJOR_REG, &major);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_read(regmap, RL78UART_MINOR_REG, &minor);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_read(regmap, RL78UART_REVISION_REG, &rev);
+	if (ret < 0)
+		return ret;
+
+	s = devm_kzalloc(dev, sizeof(*s), GFP_KERNEL);
+	if (!s) {
+		dev_err(dev, "Error allocating port structure\n");
+		return -ENOMEM;
+	}
+
+	device_property_read_u32(dev, "serial-line", &line);
+	if (line >= UART_NR) {
+		dev_err(dev, "serial-line is not specified\n");
+		return -EINVAL;
+	}
+
+	led_gpio = of_get_named_gpio(dev->of_node, "led-gpio", 0);
+	if ((led_gpio <= 0) || !gpio_is_valid(led_gpio)) {
+		dev_err(dev, "Invalid led-gpio: %d\n", led_gpio);
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request_one(dev, led_gpio, GPIOF_OUT_INIT_LOW, "rs485-led");
+	if (ret) {
+		dev_err(dev, "Failed to get rs485-led: %d\n", ret);
+		return ret;
+	}
+
+	s->regmap = regmap;
+	dev_set_drvdata(dev, s);
+	mutex_init(&s->irq_lock);
+
+	kthread_init_worker(&s->kworker);
+	s->kworker_task = kthread_run(kthread_worker_fn, &s->kworker, "rl78uart");
+	if (IS_ERR(s->kworker_task)) {
+		ret = PTR_ERR(s->kworker_task);
+		return ret;
+	}
+	sched_set_fifo(s->kworker_task);
+
+	/* Initialize port data */
+	s->port.dev = dev;
+	s->port.irq = irq;
+	s->port.type = PORT_RL78UART;
+	s->port.fifosize = RL78UART_FIFO_SIZE;
+	s->port.flags = UPF_FIXED_TYPE | UPF_LOW_LATENCY;
+	s->port.iobase = 0;
+	s->port.iotype = UPIO_PORT;
+	s->port.uartclk = RL78UART_UARTCLK;
+	s->port.rs485_config = rl78uart_config_rs485;
+	s->port.ops = &rl78uart_ops;
+	s->port.line = line;
+	s->led_gpio = led_gpio;
+
+	dev_info(dev, "version=%u.%u.%u, irq=%u, line=%u\n", major, minor, rev, irq, line);
+
+	/* Disable all interrupts */
+	rl78uart_port_write(&s->port, RL78UART_IER_REG, 0);
+
+	/* Disable TX/RX */
+	rl78uart_port_write(&s->port, RL78UART_EFCR_REG, RL78UART_EFCR_DISABLE_BIT);
+
+	/* Initialize kthread work structs */
+	kthread_init_work(&s->tx_work, rl78uart_tx_proc);
+	kthread_init_work(&s->reg_work, rl78uart_reg_proc);
+
+	/* Register port */
+	uart_add_one_port(&rl78uart_driver, &s->port);
+
+	/*
+	 * Setup interrupt. We first try to acquire the IRQ line as level IRQ.
+	 * If that succeeds, we can allow sharing the interrupt as well.
+	 * In case the interrupt controller doesn't support that, we fall
+	 * back to a non-shared falling-edge trigger.
+	 */
+	ret = devm_request_threaded_irq(dev, irq, NULL, rl78uart_irq,
+					IRQF_TRIGGER_LOW | IRQF_SHARED |
+					IRQF_ONESHOT,
+					dev_name(dev), s);
+	if (!ret) {
+		dev_info(dev, "probe complete (IRQ trigger is level)\n");
+		return 0;
+	}
+
+	ret = devm_request_threaded_irq(dev, irq, NULL, rl78uart_irq,
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					dev_name(dev), s);
+	if (!ret) {
+		dev_info(dev, "probe complete (IRQ trigger is edge)\n");
+		return 0;
+	}
+
+	/* error */
+	uart_remove_one_port(&rl78uart_driver, &s->port);
+	kthread_stop(s->kworker_task);
+
+	return ret;
+}
+
+static int rl78uart_remove(struct device *dev)
+{
+	struct rl78uart_port *s = dev_get_drvdata(dev);
+
+	uart_remove_one_port(&rl78uart_driver, &s->port);
+
+	kthread_flush_worker(&s->kworker);
+	kthread_stop(s->kworker_task);
+
+	return 0;
+}
+
+static const struct of_device_id __maybe_unused rl78uart_dt_ids[] = {
+	{ .compatible = "panasonic,rl78uart" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, rl78uart_dt_ids);
+
+static struct regmap_config regcfg = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = RL78UART_REG_MAX,
+	.cache_type = REGCACHE_RBTREE,
+	.volatile_reg = rl78uart_regmap_volatile,
+	.precious_reg = rl78uart_regmap_precious,
+};
+
+static int rl78uart_i2c_probe(struct i2c_client *i2c,
+			       const struct i2c_device_id *id)
+{
+	struct regmap *regmap;
+
+	regmap = devm_regmap_init_i2c(i2c, &regcfg);
+
+	return rl78uart_probe(&i2c->dev, regmap, i2c->irq);
+}
+
+static int rl78uart_i2c_remove(struct i2c_client *client)
+{
+	return rl78uart_remove(&client->dev);
+}
+
+static const struct i2c_device_id rl78uart_i2c_id_table[] = {
+	{ "rl78uart", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, rl78uart_i2c_id_table);
+
+static struct i2c_driver rl78uart_i2c_driver = {
+	.driver = {
+		.name			= DRIVER_NAME,
+		.of_match_table	= rl78uart_dt_ids,
+	},
+	.probe		= rl78uart_i2c_probe,
+	.remove		= rl78uart_i2c_remove,
+	.id_table	= rl78uart_i2c_id_table,
+};
+
+static int __init rl78uart_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&rl78uart_driver);
+	if (ret) {
+		pr_err("Registering UART driver failed\n");
+		return ret;
+	}
+
+	ret = i2c_add_driver(&rl78uart_i2c_driver);
+	if (ret < 0) {
+		pr_err("failed to init rl78uart --> %d\n", ret);
+		goto err_i2c;
+	}
+
+	return ret;
+
+err_i2c:
+	uart_unregister_driver(&rl78uart_driver);
+	return ret;
+}
+module_init(rl78uart_init);
+
+static void __exit rl78uart_exit(void)
+{
+	i2c_del_driver(&rl78uart_i2c_driver);
+	uart_unregister_driver(&rl78uart_driver);
+}
+module_exit(rl78uart_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Panasonic Corporation");
+MODULE_DESCRIPTION("RL78UART serial driver");
diff --git a/include/uapi/linux/serial_core.h b/include/uapi/linux/serial_core.h
index 8885e6917..f79adfc14 100644
--- a/include/uapi/linux/serial_core.h
+++ b/include/uapi/linux/serial_core.h
@@ -3,6 +3,7 @@
  *  linux/drivers/char/serial_core.h
  *
  *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *  Copyright 2022-2023 Panasonic Corporation
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -277,4 +278,7 @@
 /* Freescale LINFlexD UART */
 #define PORT_LINFLEXUART	122
 
+/* Panasonic RL78 I2C-UART */
+#define PORT_RL78UART  123
+
 #endif /* _UAPILINUX_SERIAL_CORE_H */
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index a78f28ea2..78e7fc1bc 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -203,6 +203,7 @@ config SND_SOC_ALL_CODECS
 	imply SND_SOC_STA529
 	imply SND_SOC_STAC9766
 	imply SND_SOC_STI_SAS
+	imply SND_SOC_TAS2505
 	imply SND_SOC_TAS2552
 	imply SND_SOC_TAS2562
 	imply SND_SOC_TAS2764
@@ -1390,6 +1391,10 @@ config SND_SOC_STAC9766
 config SND_SOC_STI_SAS
 	tristate "codec Audio support for STI SAS codec"
 
+config SND_SOC_TAS2505
+	tristate "Texas Instruments TAS2505 Mono Audio amplifier"
+	depends on I2C
+
 config SND_SOC_TAS2552
 	tristate "Texas Instruments TAS2552 Mono Audio amplifier"
 	depends on I2C
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index a6adb49e2..0b4b654b6 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -326,6 +326,7 @@ snd-soc-max9877-objs := max9877.o
 snd-soc-max98504-objs := max98504.o
 snd-soc-simple-amplifier-objs := simple-amplifier.o
 snd-soc-tpa6130a2-objs := tpa6130a2.o
+snd-soc-tas2505-objs := tas2505.o
 snd-soc-tas2552-objs := tas2552.o
 snd-soc-tas2562-objs := tas2562.o
 snd-soc-tas2764-objs := tas2764.o
@@ -553,6 +554,7 @@ obj-$(CONFIG_SND_SOC_STA350)   += snd-soc-sta350.o
 obj-$(CONFIG_SND_SOC_STA529)   += snd-soc-sta529.o
 obj-$(CONFIG_SND_SOC_STAC9766)	+= snd-soc-stac9766.o
 obj-$(CONFIG_SND_SOC_STI_SAS)	+= snd-soc-sti-sas.o
+obj-$(CONFIG_SND_SOC_TAS2505)	+= snd-soc-tas2505.o
 obj-$(CONFIG_SND_SOC_TAS2552)	+= snd-soc-tas2552.o
 obj-$(CONFIG_SND_SOC_TAS2562)	+= snd-soc-tas2562.o
 obj-$(CONFIG_SND_SOC_TAS2764)	+= snd-soc-tas2764.o
diff --git a/sound/soc/codecs/tas2505.c b/sound/soc/codecs/tas2505.c
new file mode 100644
index 000000000..85b2801ba
--- /dev/null
+++ b/sound/soc/codecs/tas2505.c
@@ -0,0 +1,886 @@
+/*
+ * ALSA SoC TAS2505 codec driver
+ *
+ * Author: Hieu Tran Dang <dangtranhieu2012@gmail.com>
+ *
+ * Copyright 2022 Panasonic Corporation
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED AS IS AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/pcm_params.h>
+#include "tas2505.h"
+
+static int tas2505_spkdrv_getvol(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int val;
+#if KERNEL_VERSION(4, 19, 0) <= LINUX_VERSION_CODE
+	val = snd_soc_component_read(component, TAS2505_SPKVOL1);
+#else
+	snd_soc_component_read(component, TAS2505_SPKVOL1, &val);
+#endif
+	val = (val > mc->max) ? mc->max : val;
+	val = mc->invert ? mc->max - val : val;
+	ucontrol->value.integer.value[0] = val;
+
+	return 0;
+}
+
+static int tas2505_spkdrv_putvol(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	u8 val;
+
+	val = (ucontrol->value.integer.value[0] & 0x7f);
+	val = mc->invert ? mc->max - val : val;
+	val = (val < 0) ? 0 : val;
+	snd_soc_component_write(component, TAS2505_SPKVOL1, val);
+
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -6350, 50, 0);
+static const DECLARE_TLV_DB_LINEAR(spk_drv_vol_tlv, TLV_DB_GAIN_MUTE, 0);
+static const DECLARE_TLV_DB_SCALE(spk_amp_vol_tlv, 0, 600, 1);
+
+static const struct snd_kcontrol_new tas2505_snd_controls[] = {
+	SOC_SINGLE_S8_TLV("DAC Playback Volume", TAS2505_DACVOL,
+		-127, 48, dac_vol_tlv),
+	SOC_SINGLE_RANGE_EXT_TLV("Speaker Driver Volume", TAS2505_SPKVOL1,
+		0, 0, 117, 1,
+		tas2505_spkdrv_getvol, tas2505_spkdrv_putvol, spk_drv_vol_tlv),
+	SOC_SINGLE_TLV("Speaker Amplifer Volume", TAS2505_SPKVOL2,
+		4, 5, 0, spk_amp_vol_tlv),
+};
+
+static const struct snd_soc_dapm_widget tas2505_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("DAC Channel", "Playback",
+		TAS2505_DACSETUP1, 7, 0),
+	SND_SOC_DAPM_OUT_DRV("Speaker Driver", TAS2505_SPKAMPCTRL1,
+		1, 0, NULL, 0),
+	SND_SOC_DAPM_OUTPUT("Speaker"),
+};
+
+static const struct snd_soc_dapm_route tas2505_audio_map[] = {
+	{ "Speaker Driver", NULL, "DAC Channel" },
+	{ "Speaker", NULL, "Speaker Driver" },
+};
+
+static const struct reg_default tas2505_reg_defaults[] = {
+	{ TAS2505_CLKMUX, 0x00 },
+	{ TAS2505_PLLPR, 0x11 },
+	{ TAS2505_PLLJ, 0x04 },
+	{ TAS2505_PLLDMSB, 0x00 },
+	{ TAS2505_PLLDLSB, 0x00 },
+	{ TAS2505_NDAC, 0x01 },
+	{ TAS2505_MDAC, 0x01 },
+	{ TAS2505_DOSRMSB, 0x00 },
+	{ TAS2505_DOSRLSB, 0x80 },
+	{ TAS2505_IFACE1, 0x00 },
+	{ TAS2505_IFACE3, 0x00 },
+	{ TAS2505_DACSETUP1, 0x14 },
+	{ TAS2505_DACSETUP2, 0x0c },
+	{ TAS2505_DACVOL, 0x00 },
+	{ TAS2505_REF_POR_LDO_BGAP_CTRL, 0x00 },
+	{ TAS2505_LDO_CTRL, 0x0c },
+	{ TAS2505_SPKAMPCTRL1, 0x00 },
+	{ TAS2505_SPKVOL1, 0x00 },
+	{ TAS2505_SPKVOL2, 0x00 },
+	{ TAS2505_DACFLAG1, 0x00 },
+	{ TAS2505_DACFLAG2, 0x00 },
+	{ TAS2505_STICKYFLAG1, 0x00 },
+	{ TAS2505_STICKYFLAG2, 0x00 },
+	{ TAS2505_INTFLAG1, 0x00 },
+	{ TAS2505_INTFLAG2, 0x00 },
+	{ TAS2505_DACANLGAINFLAG, 0x00 },
+};
+
+static bool tas2505_volatile(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+		case TAS2505_PAGECTL:
+		case TAS2505_RESET:
+		case TAS2505_DACFLAG1:
+		case TAS2505_DACFLAG2:
+		case TAS2505_STICKYFLAG1:
+		case TAS2505_STICKYFLAG2:
+		case TAS2505_INTFLAG1:
+		case TAS2505_INTFLAG2:
+		case TAS2505_DACANLGAINFLAG:
+			return true;
+	}
+	return false;
+}
+
+static bool tas2505_writeable(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+		case TAS2505_DACFLAG1:
+		case TAS2505_DACFLAG2:
+		case TAS2505_STICKYFLAG1:
+		case TAS2505_STICKYFLAG2:
+		case TAS2505_INTFLAG1:
+		case TAS2505_INTFLAG2:
+		case TAS2505_DACANLGAINFLAG:
+			return false;
+	}
+	return true;
+}
+
+static const struct regmap_range_cfg tas2505_ranges[] = {
+	{
+		.range_min = 0,
+		.range_max = 69 * 128,
+		.selector_reg = TAS2505_PAGECTL,
+		.selector_mask = 0xff,
+		.selector_shift = 0,
+		.window_start = 0,
+		.window_len = 128,
+	},
+};
+
+static const struct regmap_config tas2505_i2c_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.writeable_reg = tas2505_writeable,
+	.volatile_reg = tas2505_volatile,
+	.reg_defaults = tas2505_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(tas2505_reg_defaults),
+	.cache_type = REGCACHE_RBTREE,
+	.ranges = tas2505_ranges,
+	.num_ranges = ARRAY_SIZE(tas2505_ranges),
+	.max_register = 69 * 128,
+};
+
+struct tas2505_rate_divs {
+	u32 mclk_p;
+	u32 rate;
+	u8 pll_r;
+	u8 pll_j;
+	u16 pll_d;
+	u8 mdac;
+	u8 ndac;
+	u16 dosr;
+};
+
+/* rate = (mclk_p * pll_r * pll_j.pll_d) / (mdac * ndac * dosr) */
+/*   range:                                                     */
+/*     1 <= pll_r <= 16                                         */
+/*     1 <= pll_j <= 63                                         */
+/*     0 <= pll_d <= 9999                                       */
+/*     1 <= mdac <= 128                                         */
+/*     1 <= ndac <= 128                                         */
+/*     1 <= dosr <= 1024                                        */
+/*     2.8 MHz < (dosr * rate) < 6.2 MHz                        */
+/*     80 MHz <= (mclk_p * pll_r * pll_j.pll_d) <= 110 MHz      */
+/*     if pll_d == 0 then 4 <= (pll_r * pll_j) <= 259           */
+/*     if pll_d != 0 then pll_r = 1                             */
+/*     mdac * dosr / 32 >= 6                                    */
+static const struct tas2505_rate_divs tas2505_divs[] = {
+	{  2048000,  8000, 2,21,  0, 7, 12, 128 },
+	{  4096000, 16000, 1,21,  0, 7,  6, 128 },
+	{ 11289600, 44100, 1, 7,  0, 7,  2, 128 },
+	{ 12288000,  8000, 1, 7,  0, 7, 12, 128 },
+	{ 12288000, 16000, 1, 7,  0, 7,  6, 128 },
+	{ 12288000, 44100, 1, 7, 35, 4,  4, 128 },
+	{ 12288000, 48000, 1, 7,  0, 7,  2, 128 },
+};
+
+struct tas2505_priv {
+	void *codec;
+	struct device *dev;
+	struct regmap *regmap;
+	u32 sysclk;
+	u8 p_div;
+	int rate_div_line;
+};
+
+#if KERNEL_VERSION(4, 19, 0) <= LINUX_VERSION_CODE
+static int tas2505_setup_pll(struct snd_soc_component *codec,
+	struct snd_pcm_hw_params *params)
+{
+	struct tas2505_priv *tas2505 = snd_soc_component_get_drvdata(codec);
+	int mclk_p = tas2505->sysclk / tas2505->p_div;
+	int match = -1;
+	u8 p_div;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(tas2505_divs); i++) {
+		if (
+			tas2505_divs[i].rate == params_rate(params) &&
+			tas2505_divs[i].mclk_p == mclk_p
+		) {
+			match = i;
+			break;
+		}
+	}
+
+	if (match == -1) {
+		dev_err(codec->dev,
+			"Sample rate (%u) and format not supported\n",
+			params_rate(params));
+		return -EINVAL;
+	}
+
+	tas2505->rate_div_line = match;
+
+	p_div = (tas2505->p_div == 8) ? 0 : tas2505->p_div;
+	p_div <<= TAS2505_PLLPR_P_SHIFT;
+
+	snd_soc_component_update_bits(codec, TAS2505_PLLPR, TAS2505_PLLPR_P_MASK,
+		p_div);
+	snd_soc_component_update_bits(codec, TAS2505_PLLPR, TAS2505_PLLPR_R_MASK,
+		tas2505_divs[match].pll_r);
+	snd_soc_component_write(codec, TAS2505_PLLJ, tas2505_divs[match].pll_j);
+	snd_soc_component_write(codec, TAS2505_PLLDMSB, tas2505_divs[match].pll_d >> 8);
+	snd_soc_component_write(codec, TAS2505_PLLDLSB, tas2505_divs[match].pll_d & 0xff);
+	snd_soc_component_update_bits(codec, TAS2505_NDAC, TAS2505_PLL_DAC_MASK,
+		tas2505_divs[match].ndac);
+	snd_soc_component_update_bits(codec, TAS2505_MDAC, TAS2505_PLL_DAC_MASK,
+		tas2505_divs[match].mdac);
+	snd_soc_component_write(codec, TAS2505_DOSRMSB, tas2505_divs[match].dosr >> 8);
+	snd_soc_component_write(codec, TAS2505_DOSRLSB, tas2505_divs[match].dosr & 0xff);
+	snd_soc_component_update_bits(codec, TAS2505_BCLKNDIV, TAS2505_BCLKNDIV_MASK,
+		(tas2505_divs[match].dosr * tas2505_divs[match].mdac) / snd_soc_params_to_frame_size(params));
+
+	return 0;
+}
+
+static int tas2505_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *codec = dai->component;
+	u8 data = 0;
+
+	switch (params_width(params)) {
+		case 16:
+			break;
+
+		case 20:
+			data = TAS2505_WORD_LEN_20BITS;
+			break;
+
+		case 24:
+			data = TAS2505_WORD_LEN_24BITS;
+			break;
+
+		case 32:
+			data = TAS2505_WORD_LEN_32BITS;
+			break;
+
+		default:
+			dev_err(codec->dev, "Unsupported width %d\n",
+				params_width(params));
+			return -EINVAL;
+	}
+
+	data <<= TAS2505_IFACE1_DATALEN_SHIFT;
+
+	snd_soc_component_update_bits(codec, TAS2505_IFACE1,
+		TAS2505_IFACE1_DATALEN_MASK, data);
+
+	return tas2505_setup_pll(codec, params);
+}
+
+static int tas2505_dac_mute(struct snd_soc_dai *dai, int mute, int stream)
+{
+	struct snd_soc_component *codec = dai->component;
+
+	if (mute) {
+		snd_soc_component_update_bits(codec, TAS2505_DACSETUP2,
+			TAS2505_DACSETUP2_MUTE_MASK,
+			TAS2505_DACSETUP2_MUTE_MASK);
+	} else {
+		snd_soc_component_update_bits(codec, TAS2505_DACSETUP2,
+			TAS2505_DACSETUP2_MUTE_MASK, 0x0);
+	}
+
+	return 0;
+}
+
+static int tas2505_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_component *codec = codec_dai->component;
+	u8 iface_reg1 = 0;
+	u8 iface_reg3 = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+		case SND_SOC_DAIFMT_CBS_CFS:
+			break;
+
+		case SND_SOC_DAIFMT_CBM_CFM:
+			iface_reg1 |= TAS2505_IFACE1_BCLKDIR_MASK;
+			iface_reg1 |= TAS2505_IFACE1_WCLKDIR_MASK;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+			break;
+
+		case SND_SOC_DAIFMT_IB_NF:
+			iface_reg3 |= TAS2505_IFACE3_BCLKINV_MASK;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_I2S:
+			break;
+
+		case SND_SOC_DAIFMT_DSP_A:
+		case SND_SOC_DAIFMT_DSP_B:
+			iface_reg1 |= (TAS2505_DSP_MODE <<
+				TAS2505_IFACE1_INTERFACE_SHIFT);
+			break;
+
+		case SND_SOC_DAIFMT_RIGHT_J:
+			iface_reg1 |= (TAS2505_RJF_MODE <<
+				TAS2505_IFACE1_INTERFACE_SHIFT);
+			break;
+
+		case SND_SOC_DAIFMT_LEFT_J:
+			iface_reg1 |= (TAS2505_LJF_MODE <<
+				TAS2505_IFACE1_INTERFACE_SHIFT);
+			break;
+
+		default:
+			dev_err(codec->dev, "Invalid DAI interface format\n");
+			return -EINVAL;
+	}
+
+	snd_soc_component_write(codec, TAS2505_IFACE1, iface_reg1);
+	snd_soc_component_update_bits(codec, TAS2505_IFACE3,
+		TAS2505_IFACE3_BCLKINV_MASK | TAS2505_IFACE3_BDIVCLKIN_MASK,
+		iface_reg3);
+
+	return 0;
+}
+
+static int tas2505_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,
+	unsigned int freq, int dir)
+{
+	struct snd_soc_component *codec = codec_dai->component;
+	struct tas2505_priv *tas2505 = snd_soc_component_get_drvdata(codec);
+	int i, x;
+
+	dev_dbg(tas2505->dev, "clk_id: %d, freq: %d\n", clk_id, freq);
+
+	if (freq == 0) {
+		tas2505->p_div = 1;
+		tas2505->sysclk = 0;
+		return 0;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(tas2505_divs); i++) {
+		if (freq == tas2505_divs[i].mclk_p) {
+			tas2505->p_div = 1;
+			goto found_p_div;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(tas2505_divs); i++) {
+		for (x = 1; x < 9; x++) {
+			if ((freq / x) == tas2505_divs[i].mclk_p) {
+				tas2505->p_div = x;
+				goto found_p_div;
+			}
+		}
+	}
+
+	dev_err(tas2505->dev, "Can't produce required PLL_CLKIN frequency\n");
+	return -EINVAL;
+
+found_p_div:
+	snd_soc_component_write(codec, TAS2505_CLKMUX,
+		(clk_id << TAS2505_PLL_CLKIN_SHIFT) | TAS2505_CODEC_CLKIN_PLL);
+
+	tas2505->sysclk = freq;
+
+	return 0;
+}
+
+static void tas2505_clk_on(struct snd_soc_component *codec)
+{
+	u8 mask = TAS2505_PM_MASK;
+	u8 on = TAS2505_PM_MASK;
+
+	snd_soc_component_update_bits(codec, TAS2505_PLLPR, mask, on);
+	mdelay(15);
+	snd_soc_component_update_bits(codec, TAS2505_NDAC, mask, on);
+	snd_soc_component_update_bits(codec, TAS2505_MDAC, mask, on);
+	snd_soc_component_update_bits(codec, TAS2505_BCLKNDIV, mask, on);
+}
+
+static void tas2505_clk_off(struct snd_soc_component *codec)
+{
+	u8 mask = TAS2505_PM_MASK;
+
+	snd_soc_component_update_bits(codec, TAS2505_BCLKNDIV, mask, 0);
+	snd_soc_component_update_bits(codec, TAS2505_MDAC, mask, 0);
+	snd_soc_component_update_bits(codec, TAS2505_NDAC, mask, 0);
+	snd_soc_component_update_bits(codec, TAS2505_PLLPR, mask, 0);
+}
+
+static void tas2505_power_on(struct snd_soc_component *codec)
+{
+//	snd_soc_component_write(codec, TAS2505_RESET, 1);
+//	usleep_range(500, 1000);
+	snd_soc_component_update_bits(codec, TAS2505_LDO_CTRL,
+		TAS2505_LDO_PLL_HP_LVL_MASK, 0);
+	snd_soc_component_update_bits(codec, TAS2505_REF_POR_LDO_BGAP_CTRL,
+		TAS2505_REF_POR_LDO_BGAP_MASTER_REF_MASK,
+		TAS2505_REF_POR_LDO_BGAP_MASTER_REF_MASK);
+}
+
+static void tas2505_power_off(struct snd_soc_component *codec)
+{
+	snd_soc_component_update_bits(codec, TAS2505_REF_POR_LDO_BGAP_CTRL,
+		TAS2505_REF_POR_LDO_BGAP_MASTER_REF_MASK, 0);
+	snd_soc_component_update_bits(codec, TAS2505_LDO_CTRL,
+		TAS2505_LDO_PLL_HP_LVL_MASK,
+		TAS2505_LDO_PLL_HP_LVL_MASK);
+}
+#else
+static int tas2505_setup_pll(struct snd_soc_codec *codec,
+	struct snd_pcm_hw_params *params)
+{
+	struct tas2505_priv *tas2505 = snd_soc_codec_get_drvdata(codec);
+	int mclk_p = tas2505->sysclk / tas2505->p_div;
+	int match = -1;
+	u8 p_div;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(tas2505_divs); i++) {
+		if (
+			tas2505_divs[i].rate == params_rate(params) &&
+			tas2505_divs[i].mclk_p == mclk_p
+		) {
+			match = i;
+			break;
+		}
+	}
+
+	if (match == -1) {
+		dev_err(codec->dev,
+			"Sample rate (%u) and format not supported\n",
+			params_rate(params));
+		return -EINVAL;
+	}
+
+	tas2505->rate_div_line = match;
+
+	p_div = (tas2505->p_div == 8) ? 0 : tas2505->p_div;
+	p_div <<= TAS2505_PLLPR_P_SHIFT;
+
+	snd_soc_update_bits(codec, TAS2505_PLLPR, TAS2505_PLLPR_P_MASK,
+		p_div);
+	snd_soc_update_bits(codec, TAS2505_PLLPR, TAS2505_PLLPR_R_MASK,
+		tas2505_divs[match].pll_r);
+	snd_soc_write(codec, TAS2505_PLLJ, tas2505_divs[match].pll_j);
+	snd_soc_write(codec, TAS2505_PLLDMSB, tas2505_divs[match].pll_d >> 8);
+	snd_soc_write(codec, TAS2505_PLLDLSB, tas2505_divs[match].pll_d & 0xff);
+	snd_soc_update_bits(codec, TAS2505_NDAC, TAS2505_PLL_DAC_MASK,
+		tas2505_divs[match].ndac);
+	snd_soc_update_bits(codec, TAS2505_MDAC, TAS2505_PLL_DAC_MASK,
+		tas2505_divs[match].mdac);
+	snd_soc_write(codec, TAS2505_DOSRMSB, tas2505_divs[match].dosr >> 8);
+	snd_soc_write(codec, TAS2505_DOSRLSB, tas2505_divs[match].dosr & 0xff);
+	snd_soc_update_bits(codec, TAS2505_BCLKNDIV, TAS2505_BCLKNDIV_MASK,
+		(tas2505_divs[match].dosr * tas2505_divs[match].mdac) / snd_soc_params_to_frame_size(params));
+
+	return 0;
+}
+
+static int tas2505_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	u8 data = 0;
+
+	switch (params_width(params)) {
+		case 16:
+			break;
+
+		case 20:
+			data = TAS2505_WORD_LEN_20BITS;
+			break;
+
+		case 24:
+			data = TAS2505_WORD_LEN_24BITS;
+			break;
+
+		case 32:
+			data = TAS2505_WORD_LEN_32BITS;
+			break;
+
+		default:
+			dev_err(codec->dev, "Unsupported width %d\n",
+				params_width(params));
+			return -EINVAL;
+	}
+
+	data <<= TAS2505_IFACE1_DATALEN_SHIFT;
+
+	snd_soc_update_bits(codec, TAS2505_IFACE1,
+		TAS2505_IFACE1_DATALEN_MASK, data);
+
+	return tas2505_setup_pll(codec, params);
+}
+
+static int tas2505_dac_mute(struct snd_soc_dai *codec_dai, int mute, int stream)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+
+	if (mute) {
+		snd_soc_update_bits(codec, TAS2505_DACSETUP2,
+			TAS2505_DACSETUP2_MUTE_MASK,
+			TAS2505_DACSETUP2_MUTE_MASK);
+	} else {
+		snd_soc_update_bits(codec, TAS2505_DACSETUP2,
+			TAS2505_DACSETUP2_MUTE_MASK, 0x0);
+	}
+
+	return 0;
+}
+
+static int tas2505_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u8 iface_reg1 = 0;
+	u8 iface_reg3 = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+		case SND_SOC_DAIFMT_CBS_CFS:
+			break;
+
+		case SND_SOC_DAIFMT_CBM_CFM:
+			iface_reg1 |= TAS2505_IFACE1_BCLKDIR_MASK;
+			iface_reg1 |= TAS2505_IFACE1_WCLKDIR_MASK;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+			break;
+
+		case SND_SOC_DAIFMT_IB_NF:
+			iface_reg3 |= TAS2505_IFACE3_BCLKINV_MASK;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_I2S:
+			break;
+
+		case SND_SOC_DAIFMT_DSP_A:
+		case SND_SOC_DAIFMT_DSP_B:
+			iface_reg1 |= (TAS2505_DSP_MODE <<
+				TAS2505_IFACE1_INTERFACE_SHIFT);
+			break;
+
+		case SND_SOC_DAIFMT_RIGHT_J:
+			iface_reg1 |= (TAS2505_RJF_MODE <<
+				TAS2505_IFACE1_INTERFACE_SHIFT);
+			break;
+
+		case SND_SOC_DAIFMT_LEFT_J:
+			iface_reg1 |= (TAS2505_LJF_MODE <<
+				TAS2505_IFACE1_INTERFACE_SHIFT);
+			break;
+
+		default:
+			dev_err(codec->dev, "Invalid DAI interface format\n");
+			return -EINVAL;
+	}
+
+	snd_soc_write(codec, TAS2505_IFACE1, iface_reg1);
+	snd_soc_update_bits(codec, TAS2505_IFACE3,
+		TAS2505_IFACE3_BCLKINV_MASK | TAS2505_IFACE3_BDIVCLKIN_MASK,
+		iface_reg3);
+
+	return 0;
+}
+
+static int tas2505_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,
+	unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct tas2505_priv *tas2505 = snd_soc_codec_get_drvdata(codec);
+	int i, x;
+
+	dev_dbg(tas2505->dev, "clk_id: %d, freq: %d\n", clk_id, freq);
+
+	for (i = 0; i < ARRAY_SIZE(tas2505_divs); i++) {
+		for (x = 1; x < 9; x++) {
+			if ((freq / x) == tas2505_divs[i].mclk_p) {
+				tas2505->p_div = x;
+				goto found_p_div;
+			}
+		}
+	}
+
+	dev_err(tas2505->dev, "Can't produce required PLL_CLKIN frequency\n");
+	return -EINVAL;
+
+found_p_div:
+	snd_soc_write(codec, TAS2505_CLKMUX,
+		(clk_id << TAS2505_PLL_CLKIN_SHIFT) | TAS2505_CODEC_CLKIN_PLL);
+
+	tas2505->sysclk = freq;
+
+	return 0;
+}
+
+static void tas2505_clk_on(struct snd_soc_codec *codec)
+{
+	u8 mask = TAS2505_PM_MASK;
+	u8 on = TAS2505_PM_MASK;
+
+	snd_soc_update_bits(codec, TAS2505_PLLPR, mask, on);
+	mdelay(15);
+	snd_soc_update_bits(codec, TAS2505_NDAC, mask, on);
+	snd_soc_update_bits(codec, TAS2505_MDAC, mask, on);
+	snd_soc_update_bits(codec, TAS2505_BCLKNDIV, mask, on);
+}
+
+static void tas2505_clk_off(struct snd_soc_codec *codec)
+{
+	u8 mask = TAS2505_PM_MASK;
+
+	snd_soc_update_bits(codec, TAS2505_BCLKNDIV, mask, 0);
+	snd_soc_update_bits(codec, TAS2505_MDAC, mask, 0);
+	snd_soc_update_bits(codec, TAS2505_NDAC, mask, 0);
+	snd_soc_update_bits(codec, TAS2505_PLLPR, mask, 0);
+}
+
+static void tas2505_power_on(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, TAS2505_RESET, 1);
+	usleep_range(500, 1000);
+	snd_soc_update_bits(codec, TAS2505_LDO_CTRL,
+		TAS2505_LDO_PLL_HP_LVL_MASK, 0);
+	snd_soc_update_bits(codec, TAS2505_REF_POR_LDO_BGAP_CTRL,
+		TAS2505_REF_POR_LDO_BGAP_MASTER_REF_MASK,
+		TAS2505_REF_POR_LDO_BGAP_MASTER_REF_MASK);
+}
+
+static void tas2505_power_off(struct snd_soc_codec *codec)
+{
+	snd_soc_update_bits(codec, TAS2505_REF_POR_LDO_BGAP_CTRL,
+		TAS2505_REF_POR_LDO_BGAP_MASTER_REF_MASK, 0);
+	snd_soc_update_bits(codec, TAS2505_LDO_CTRL,
+		TAS2505_LDO_PLL_HP_LVL_MASK,
+		TAS2505_LDO_PLL_HP_LVL_MASK);
+}
+#endif
+
+#if KERNEL_VERSION(4, 19, 0) <= LINUX_VERSION_CODE
+static int tas2505_set_bias_level(struct snd_soc_component *codec,
+	enum snd_soc_bias_level level)
+{
+	int current_lvl = snd_soc_component_get_bias_level(codec);
+#else
+static int tas2505_set_bias_level(struct snd_soc_codec *codec,
+	enum snd_soc_bias_level level)
+{
+	int current_lvl = snd_soc_codec_get_bias_level(codec);
+#endif
+	switch (level) {
+		case SND_SOC_BIAS_ON:
+			break;
+		case SND_SOC_BIAS_PREPARE:
+			if (current_lvl == SND_SOC_BIAS_STANDBY)
+				tas2505_clk_on(codec);
+			break;
+		case SND_SOC_BIAS_STANDBY:
+			if (current_lvl == SND_SOC_BIAS_OFF)
+				tas2505_power_on(codec);
+			else if (current_lvl == SND_SOC_BIAS_PREPARE)
+				tas2505_clk_off(codec);
+			else
+				BUG();
+			break;
+		case SND_SOC_BIAS_OFF:
+			if (current_lvl == SND_SOC_BIAS_STANDBY)
+				tas2505_power_off(codec);
+			break;
+		default:
+			dev_err(codec->dev, "Invalid bias level\n");
+			return -EINVAL;
+	}
+
+	return 0;
+}
+#if KERNEL_VERSION(4, 19, 0) <= LINUX_VERSION_CODE
+static int tas2505_codec_probe(struct snd_soc_component *codec)
+{
+	struct tas2505_priv *tas2505 = snd_soc_component_get_drvdata(codec);
+#else
+static int tas2505_codec_probe(struct snd_soc_codec *codec)
+{
+	struct tas2505_priv *tas2505 = snd_soc_codec_get_drvdata(codec);
+#endif
+	tas2505->codec = codec;
+	return 0;
+}
+
+#if KERNEL_VERSION(4, 19, 0) <= LINUX_VERSION_CODE
+static struct snd_soc_component_driver soc_codec_driver_tas2505 = {
+	.probe			= tas2505_codec_probe,
+	.set_bias_level		= tas2505_set_bias_level,
+	.suspend_bias_off	= true,
+
+	.controls		= tas2505_snd_controls,
+	.num_controls		= ARRAY_SIZE(tas2505_snd_controls),
+	.dapm_widgets		= tas2505_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(tas2505_dapm_widgets),
+	.dapm_routes		= tas2505_audio_map,
+	.num_dapm_routes	= ARRAY_SIZE(tas2505_audio_map),
+};
+#else
+static struct snd_soc_codec_driver soc_codec_driver_tas2505 = {
+	.probe			= tas2505_codec_probe,
+	.set_bias_level		= tas2505_set_bias_level,
+	.suspend_bias_off	= true,
+
+	.component_driver = {
+		.controls		= tas2505_snd_controls,
+		.num_controls		= ARRAY_SIZE(tas2505_snd_controls),
+		.dapm_widgets		= tas2505_dapm_widgets,
+		.num_dapm_widgets	= ARRAY_SIZE(tas2505_dapm_widgets),
+		.dapm_routes		= tas2505_audio_map,
+		.num_dapm_routes	= ARRAY_SIZE(tas2505_audio_map),
+	},
+};
+#endif
+
+static const struct snd_soc_dai_ops tas2505_dai_ops = {
+	.hw_params	= tas2505_hw_params,
+	.set_sysclk	= tas2505_set_dai_sysclk,
+	.set_fmt	= tas2505_set_dai_fmt,
+	.mute_stream	= tas2505_dac_mute,
+};
+
+static struct snd_soc_dai_driver tas2505_dai_driver[] = {
+	{
+		.name = "tas2505-hifi",
+		.playback = {
+			.stream_name	= "Playback",
+			.channels_min	= 1,
+			.channels_max	= 2,
+			.rates		= TAS2505_RATES,
+			.formats	= TAS2505_FORMATS,
+		},
+		.ops = &tas2505_dai_ops,
+		.symmetric_rate = 1,
+	},
+};
+
+static int tas2505_i2c_probe(struct i2c_client *i2c,
+	const struct i2c_device_id *id)
+{
+	struct tas2505_priv *tas2505;
+	struct device_node *np = i2c->dev.of_node;
+	const struct regmap_config *regmap_config = &tas2505_i2c_regmap;
+	int ret;
+
+	tas2505 = devm_kzalloc(&i2c->dev, sizeof(*tas2505), GFP_KERNEL);
+	if (tas2505 == NULL)
+		return -ENOMEM;
+
+	tas2505->regmap = devm_regmap_init_i2c(i2c, regmap_config);
+	if (IS_ERR(tas2505->regmap)) {
+		ret = PTR_ERR(tas2505->regmap);
+		dev_err(&i2c->dev, "Failed to allocate register map: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = of_get_named_gpio(np, "gpio-reset", 0);
+	if ((ret > 0) && gpio_is_valid(ret)) {
+		devm_gpio_request_one(&i2c->dev, ret, GPIOF_OUT_INIT_HIGH, "reset");
+	}
+
+	tas2505->dev = &i2c->dev;
+
+	dev_set_drvdata(tas2505->dev, tas2505);
+#if KERNEL_VERSION(4, 19, 0) <= LINUX_VERSION_CODE
+	return snd_soc_register_component( &i2c->dev, &soc_codec_driver_tas2505,
+		tas2505_dai_driver, ARRAY_SIZE(tas2505_dai_driver));
+#else
+	return snd_soc_register_codec( &i2c->dev, &soc_codec_driver_tas2505,
+		tas2505_dai_driver, ARRAY_SIZE(tas2505_dai_driver));
+#endif
+}
+
+static int tas2505_i2c_remove(struct i2c_client *i2c)
+{
+#if KERNEL_VERSION(4, 19, 0) <= LINUX_VERSION_CODE
+	snd_soc_unregister_component(&i2c->dev);
+#else
+	snd_soc_unregister_codec(&i2c->dev);
+#endif
+	return 0;
+}
+
+static const struct of_device_id tas2505_of_match[] = {
+	{ .compatible = "ti,tas2505" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, tas2505_of_match);
+
+static const struct i2c_device_id tas2505_i2c_id[] = {
+	{ "tas2505", 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2ic, tas2505_i2c_id);
+
+static struct i2c_driver tas2505_i2c_driver = {
+	.driver = {
+		.name		= "tas2505-codec",
+		.of_match_table	= of_match_ptr(tas2505_of_match),
+	},
+	.probe		= tas2505_i2c_probe,
+	.remove		= tas2505_i2c_remove,
+	.id_table	= tas2505_i2c_id,
+};
+
+module_i2c_driver(tas2505_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC TAS2505 codec driver");
+MODULE_AUTHOR("Hieu Tran Dang <dangtranhieu2012@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/tas2505.h b/sound/soc/codecs/tas2505.h
new file mode 100644
index 000000000..8f98412d4
--- /dev/null
+++ b/sound/soc/codecs/tas2505.h
@@ -0,0 +1,94 @@
+/*
+ * ALSA SoC TAS2505 codec driver
+ *
+ * Author: Hieu Tran Dang <dangtranhieu2012@gmail.com>
+ *
+ * Copyright 2022 Panasonic Corporation
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED AS IS AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _TAS2505_H
+#define _TAS2505_H
+
+//#define TAS2505_RATES	SNDRV_PCM_RATE_8000_96000
+#define TAS2505_RATES	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+//#define TAS2505_FORMATS SNDRV_PCM_FMTBIT_S24_LE
+#define TAS2505_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+#define TAS2505_REG(page, reg)	((page * 128) + reg)
+
+#define TAS2505_PAGECTL			TAS2505_REG(0, 0)
+#define TAS2505_RESET			TAS2505_REG(0, 1)
+#define TAS2505_CLKMUX			TAS2505_REG(0, 4)
+#define TAS2505_PLLPR			TAS2505_REG(0, 5)
+#define TAS2505_PLLJ			TAS2505_REG(0, 6)
+#define TAS2505_PLLDMSB			TAS2505_REG(0, 7)
+#define TAS2505_PLLDLSB			TAS2505_REG(0, 8)
+#define TAS2505_NDAC			TAS2505_REG(0, 11)
+#define TAS2505_MDAC			TAS2505_REG(0, 12)
+#define TAS2505_DOSRMSB			TAS2505_REG(0, 13)
+#define TAS2505_DOSRLSB			TAS2505_REG(0, 14)
+#define TAS2505_IFACE1			TAS2505_REG(0, 27)
+#define TAS2505_IFACE3			TAS2505_REG(0, 29)
+#define TAS2505_BCLKNDIV		TAS2505_REG(0, 30)
+#define TAS2505_DACFLAG1		TAS2505_REG(0, 37)
+#define TAS2505_DACFLAG2		TAS2505_REG(0, 38)
+#define TAS2505_STICKYFLAG1		TAS2505_REG(0, 42)
+#define TAS2505_INTFLAG1		TAS2505_REG(0, 43)
+#define TAS2505_STICKYFLAG2		TAS2505_REG(0, 44)
+#define TAS2505_INTFLAG2		TAS2505_REG(0, 46)
+#define TAS2505_DACINSTRSET		TAS2505_REG(0, 60)
+#define TAS2505_DACSETUP1		TAS2505_REG(0, 63)
+#define TAS2505_DACSETUP2		TAS2505_REG(0, 64)
+#define TAS2505_DACVOL			TAS2505_REG(0, 65)
+#define TAS2505_REF_POR_LDO_BGAP_CTRL	TAS2505_REG(1, 1)
+#define TAS2505_LDO_CTRL		TAS2505_REG(1, 2)
+#define TAS2505_PLAYBACKCONF1		TAS2505_REG(1, 3)
+#define TAS2505_SPKAMPCTRL1		TAS2505_REG(1, 45)
+#define TAS2505_SPKVOL1			TAS2505_REG(1, 46)
+#define TAS2505_SPKVOL2			TAS2505_REG(1, 48)
+#define TAS2505_DACANLGAINFLAG		TAS2505_REG(1, 63)
+
+#define TAS2505_PLLPR_P_MASK				0x70
+#define TAS2505_PLLPR_R_MASK				0xf
+#define TAS2505_PLL_DAC_MASK				0x7f
+#define TAS2505_BCLKNDIV_MASK				0x7f
+#define TAS2505_IFACE1_DATALEN_MASK			0x30
+#define TAS2505_IFACE1_WCLKDIR_MASK			0x4
+#define TAS2505_IFACE1_BCLKDIR_MASK			0x8
+#define TAS2505_IFACE1_INTERFACE_MASK			0xc0
+#define TAS2505_IFACE3_BDIVCLKIN_MASK			0x1
+#define TAS2505_IFACE3_BCLKINV_MASK			0x8
+#define TAS2505_DACSETUP2_MUTE_MASK			0x8
+#define TAS2505_PM_MASK					0x80
+#define TAS2505_LDO_PLL_HP_LVL_MASK			0x8
+#define TAS2505_REF_POR_LDO_BGAP_MASTER_REF_MASK	0x10
+
+#define TAS2505_PLLPR_P_SHIFT		4
+#define TAS2505_PLL_CLKIN_SHIFT		2
+#define TAS2505_IFACE1_DATALEN_SHIFT	4
+#define TAS2505_IFACE1_INTERFACE_SHIFT	6
+#define TAS2505_IFACE3_BCLKINV_SHIFT	4
+
+#define TAS2505_WORD_LEN_20BITS		1
+#define TAS2505_WORD_LEN_24BITS		2
+#define TAS2505_WORD_LEN_32BITS		3
+
+#define TAS2505_DSP_MODE		1
+#define TAS2505_RJF_MODE		2
+#define TAS2505_LJF_MODE		3
+
+#define TAS2505_PLL_CLKIN_MCLK		0
+#define TAS2505_PLL_CLKIN_BCLK		1
+#define TAS2505_PLL_CLKIN_GPIO		2
+#define TAS2505_PLL_CLKIN_DIN		3
+#define TAS2505_CODEC_CLKIN_PLL		3
+
+#endif
diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c
index 1f3eff252..a29b46890 100644
--- a/sound/soc/fsl/fsl_sai.c
+++ b/sound/soc/fsl/fsl_sai.c
@@ -3,6 +3,7 @@
 // Freescale ALSA SoC Digital Audio Interface (SAI) driver.
 //
 // Copyright 2012-2015 Freescale Semiconductor, Inc.
+// Copyright 2022-2023 Panasonic Corporation
 
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
@@ -204,10 +205,12 @@ static int fsl_sai_set_mclk_rate(struct snd_soc_dai *dai, int clk_id,
 		unsigned int freq)
 {
 	struct fsl_sai *sai = snd_soc_dai_get_drvdata(dai);
-	struct clk *p = sai->mclk_clk[clk_id], *pll = 0, *npll = 0;
+	struct clk *p = sai->mclk_clk[clk_id], *pll = 0, *npll = 0, *clk;
 	u64 ratio = freq;
 	int ret;
 
+	clk = p;
+
 	while (p && sai->pll8k_clk && sai->pll11k_clk) {
 		struct clk *pp = clk_get_parent(p);
 
@@ -219,6 +222,8 @@ static int fsl_sai_set_mclk_rate(struct snd_soc_dai *dai, int clk_id,
 		p = pp;
 	}
 
+	clk_disable_unprepare(clk);
+
 	if (pll) {
 		npll = (do_div(ratio, 8000) ? sai->pll11k_clk : sai->pll8k_clk);
 		if (!clk_is_match(pll, npll)) {
@@ -235,6 +240,8 @@ static int fsl_sai_set_mclk_rate(struct snd_soc_dai *dai, int clk_id,
 		dev_err(dai->dev, "failed to set clock rate (%u): %d\n",
 			freq, ret);
 
+	clk_prepare_enable(clk);
+
 	return ret;
 }
 
@@ -247,6 +254,9 @@ static int fsl_sai_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
 	if (dir == SND_SOC_CLOCK_IN)
 		return 0;
 
+	if (sai->mclk_clkid != FSL_SAI_MCLK_MAX)
+		clk_id = sai->mclk_clkid;
+
 	if (freq > 0 && clk_id != FSL_SAI_CLK_BUS) {
 		if (clk_id < 0 || clk_id >= FSL_SAI_MCLK_MAX) {
 			dev_err(cpu_dai->dev, "Unknown clock id: %d\n", clk_id);
@@ -1360,6 +1370,9 @@ static int fsl_sai_probe(struct platform_device *pdev)
 	if (of_find_property(np, "fsl,sai-multi-lane", NULL))
 		sai->is_multi_lane = true;
 
+	if (of_property_read_u32(np, "fsl,mclk-clkid", &sai->mclk_clkid))
+		sai->mclk_clkid = FSL_SAI_MCLK_MAX;
+
 	/*dataline mask for rx and tx*/
 	ret = fsl_sai_read_dlcfg(pdev, "fsl,dataline", &sai->pcm_dl_cfg,
 					sai->soc_data->dataline);
diff --git a/sound/soc/fsl/fsl_sai.h b/sound/soc/fsl/fsl_sai.h
index 21c8f7d9d..242d9d203 100644
--- a/sound/soc/fsl/fsl_sai.h
+++ b/sound/soc/fsl/fsl_sai.h
@@ -1,6 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright 2012-2016 Freescale Semiconductor, Inc.
+ * Copyright 2022-2023 Panasonic Corporation
  */
 
 #ifndef __FSL_SAI_H
@@ -12,6 +13,7 @@
 
 #define FAL_SAI_NUM_RATES  20
 #define FSL_SAI_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\
+			 SNDRV_PCM_FMTBIT_S24_3LE |\
 			 SNDRV_PCM_FMTBIT_S24_LE |\
 			 SNDRV_PCM_FMTBIT_S32_LE |\
 			 SNDRV_PCM_FMTBIT_DSD_U8 |\
@@ -315,6 +317,8 @@ struct fsl_sai {
 	struct pinctrl_state *pins_state;
 	struct snd_pcm_hw_constraint_list constraint_rates;
 	unsigned int constraint_rates_list[FAL_SAI_NUM_RATES];
+
+	unsigned int mclk_clkid;
 };
 
 const struct attribute_group *fsl_sai_get_dev_attribute_group(bool monitor_spdif);
